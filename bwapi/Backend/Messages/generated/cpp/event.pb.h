// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: event.proto

#ifndef PROTOBUF_INCLUDED_event_2eproto
#define PROTOBUF_INCLUDED_event_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "data.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_event_2eproto 

namespace protobuf_event_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[19];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_event_2eproto
namespace bwapi {
namespace event {
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class MatchEnd;
class MatchEndDefaultTypeInternal;
extern MatchEndDefaultTypeInternal _MatchEnd_default_instance_;
class MatchFrame;
class MatchFrameDefaultTypeInternal;
extern MatchFrameDefaultTypeInternal _MatchFrame_default_instance_;
class MatchStart;
class MatchStartDefaultTypeInternal;
extern MatchStartDefaultTypeInternal _MatchStart_default_instance_;
class MenuFrame;
class MenuFrameDefaultTypeInternal;
extern MenuFrameDefaultTypeInternal _MenuFrame_default_instance_;
class NukeDetect;
class NukeDetectDefaultTypeInternal;
extern NukeDetectDefaultTypeInternal _NukeDetect_default_instance_;
class PlayerLeft;
class PlayerLeftDefaultTypeInternal;
extern PlayerLeftDefaultTypeInternal _PlayerLeft_default_instance_;
class ReceiveText;
class ReceiveTextDefaultTypeInternal;
extern ReceiveTextDefaultTypeInternal _ReceiveText_default_instance_;
class SaveGame;
class SaveGameDefaultTypeInternal;
extern SaveGameDefaultTypeInternal _SaveGame_default_instance_;
class SendText;
class SendTextDefaultTypeInternal;
extern SendTextDefaultTypeInternal _SendText_default_instance_;
class UnitComplete;
class UnitCompleteDefaultTypeInternal;
extern UnitCompleteDefaultTypeInternal _UnitComplete_default_instance_;
class UnitCreate;
class UnitCreateDefaultTypeInternal;
extern UnitCreateDefaultTypeInternal _UnitCreate_default_instance_;
class UnitDestroy;
class UnitDestroyDefaultTypeInternal;
extern UnitDestroyDefaultTypeInternal _UnitDestroy_default_instance_;
class UnitDiscover;
class UnitDiscoverDefaultTypeInternal;
extern UnitDiscoverDefaultTypeInternal _UnitDiscover_default_instance_;
class UnitEvade;
class UnitEvadeDefaultTypeInternal;
extern UnitEvadeDefaultTypeInternal _UnitEvade_default_instance_;
class UnitHide;
class UnitHideDefaultTypeInternal;
extern UnitHideDefaultTypeInternal _UnitHide_default_instance_;
class UnitMorph;
class UnitMorphDefaultTypeInternal;
extern UnitMorphDefaultTypeInternal _UnitMorph_default_instance_;
class UnitRenegade;
class UnitRenegadeDefaultTypeInternal;
extern UnitRenegadeDefaultTypeInternal _UnitRenegade_default_instance_;
class UnitShow;
class UnitShowDefaultTypeInternal;
extern UnitShowDefaultTypeInternal _UnitShow_default_instance_;
}  // namespace event
}  // namespace bwapi
namespace google {
namespace protobuf {
template<> ::bwapi::event::Event* Arena::CreateMaybeMessage<::bwapi::event::Event>(Arena*);
template<> ::bwapi::event::MatchEnd* Arena::CreateMaybeMessage<::bwapi::event::MatchEnd>(Arena*);
template<> ::bwapi::event::MatchFrame* Arena::CreateMaybeMessage<::bwapi::event::MatchFrame>(Arena*);
template<> ::bwapi::event::MatchStart* Arena::CreateMaybeMessage<::bwapi::event::MatchStart>(Arena*);
template<> ::bwapi::event::MenuFrame* Arena::CreateMaybeMessage<::bwapi::event::MenuFrame>(Arena*);
template<> ::bwapi::event::NukeDetect* Arena::CreateMaybeMessage<::bwapi::event::NukeDetect>(Arena*);
template<> ::bwapi::event::PlayerLeft* Arena::CreateMaybeMessage<::bwapi::event::PlayerLeft>(Arena*);
template<> ::bwapi::event::ReceiveText* Arena::CreateMaybeMessage<::bwapi::event::ReceiveText>(Arena*);
template<> ::bwapi::event::SaveGame* Arena::CreateMaybeMessage<::bwapi::event::SaveGame>(Arena*);
template<> ::bwapi::event::SendText* Arena::CreateMaybeMessage<::bwapi::event::SendText>(Arena*);
template<> ::bwapi::event::UnitComplete* Arena::CreateMaybeMessage<::bwapi::event::UnitComplete>(Arena*);
template<> ::bwapi::event::UnitCreate* Arena::CreateMaybeMessage<::bwapi::event::UnitCreate>(Arena*);
template<> ::bwapi::event::UnitDestroy* Arena::CreateMaybeMessage<::bwapi::event::UnitDestroy>(Arena*);
template<> ::bwapi::event::UnitDiscover* Arena::CreateMaybeMessage<::bwapi::event::UnitDiscover>(Arena*);
template<> ::bwapi::event::UnitEvade* Arena::CreateMaybeMessage<::bwapi::event::UnitEvade>(Arena*);
template<> ::bwapi::event::UnitHide* Arena::CreateMaybeMessage<::bwapi::event::UnitHide>(Arena*);
template<> ::bwapi::event::UnitMorph* Arena::CreateMaybeMessage<::bwapi::event::UnitMorph>(Arena*);
template<> ::bwapi::event::UnitRenegade* Arena::CreateMaybeMessage<::bwapi::event::UnitRenegade>(Arena*);
template<> ::bwapi::event::UnitShow* Arena::CreateMaybeMessage<::bwapi::event::UnitShow>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace bwapi {
namespace event {

// ===================================================================

class MatchStart : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.MatchStart) */ {
 public:
  MatchStart();
  virtual ~MatchStart();

  MatchStart(const MatchStart& from);

  inline MatchStart& operator=(const MatchStart& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchStart(MatchStart&& from) noexcept
    : MatchStart() {
    *this = ::std::move(from);
  }

  inline MatchStart& operator=(MatchStart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchStart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchStart* internal_default_instance() {
    return reinterpret_cast<const MatchStart*>(
               &_MatchStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MatchStart* other);
  friend void swap(MatchStart& a, MatchStart& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchStart* New() const final {
    return CreateMaybeMessage<MatchStart>(NULL);
  }

  MatchStart* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchStart>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchStart& from);
  void MergeFrom(const MatchStart& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchStart* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bwapi.event.MatchStart)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchEnd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.MatchEnd) */ {
 public:
  MatchEnd();
  virtual ~MatchEnd();

  MatchEnd(const MatchEnd& from);

  inline MatchEnd& operator=(const MatchEnd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchEnd(MatchEnd&& from) noexcept
    : MatchEnd() {
    *this = ::std::move(from);
  }

  inline MatchEnd& operator=(MatchEnd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchEnd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchEnd* internal_default_instance() {
    return reinterpret_cast<const MatchEnd*>(
               &_MatchEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MatchEnd* other);
  friend void swap(MatchEnd& a, MatchEnd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchEnd* New() const final {
    return CreateMaybeMessage<MatchEnd>(NULL);
  }

  MatchEnd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchEnd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchEnd& from);
  void MergeFrom(const MatchEnd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchEnd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool winner = 1;
  void clear_winner();
  static const int kWinnerFieldNumber = 1;
  bool winner() const;
  void set_winner(bool value);

  // @@protoc_insertion_point(class_scope:bwapi.event.MatchEnd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool winner_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.MatchFrame) */ {
 public:
  MatchFrame();
  virtual ~MatchFrame();

  MatchFrame(const MatchFrame& from);

  inline MatchFrame& operator=(const MatchFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchFrame(MatchFrame&& from) noexcept
    : MatchFrame() {
    *this = ::std::move(from);
  }

  inline MatchFrame& operator=(MatchFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchFrame* internal_default_instance() {
    return reinterpret_cast<const MatchFrame*>(
               &_MatchFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(MatchFrame* other);
  friend void swap(MatchFrame& a, MatchFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchFrame* New() const final {
    return CreateMaybeMessage<MatchFrame>(NULL);
  }

  MatchFrame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchFrame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchFrame& from);
  void MergeFrom(const MatchFrame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bwapi.event.MatchFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MenuFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.MenuFrame) */ {
 public:
  MenuFrame();
  virtual ~MenuFrame();

  MenuFrame(const MenuFrame& from);

  inline MenuFrame& operator=(const MenuFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MenuFrame(MenuFrame&& from) noexcept
    : MenuFrame() {
    *this = ::std::move(from);
  }

  inline MenuFrame& operator=(MenuFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MenuFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MenuFrame* internal_default_instance() {
    return reinterpret_cast<const MenuFrame*>(
               &_MenuFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MenuFrame* other);
  friend void swap(MenuFrame& a, MenuFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MenuFrame* New() const final {
    return CreateMaybeMessage<MenuFrame>(NULL);
  }

  MenuFrame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MenuFrame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MenuFrame& from);
  void MergeFrom(const MenuFrame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MenuFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bwapi.event.MenuFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SendText : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.SendText) */ {
 public:
  SendText();
  virtual ~SendText();

  SendText(const SendText& from);

  inline SendText& operator=(const SendText& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendText(SendText&& from) noexcept
    : SendText() {
    *this = ::std::move(from);
  }

  inline SendText& operator=(SendText&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendText& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendText* internal_default_instance() {
    return reinterpret_cast<const SendText*>(
               &_SendText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SendText* other);
  friend void swap(SendText& a, SendText& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendText* New() const final {
    return CreateMaybeMessage<SendText>(NULL);
  }

  SendText* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SendText>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SendText& from);
  void MergeFrom(const SendText& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendText* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:bwapi.event.SendText)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReceiveText : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.ReceiveText) */ {
 public:
  ReceiveText();
  virtual ~ReceiveText();

  ReceiveText(const ReceiveText& from);

  inline ReceiveText& operator=(const ReceiveText& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReceiveText(ReceiveText&& from) noexcept
    : ReceiveText() {
    *this = ::std::move(from);
  }

  inline ReceiveText& operator=(ReceiveText&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveText& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReceiveText* internal_default_instance() {
    return reinterpret_cast<const ReceiveText*>(
               &_ReceiveText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ReceiveText* other);
  friend void swap(ReceiveText& a, ReceiveText& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReceiveText* New() const final {
    return CreateMaybeMessage<ReceiveText>(NULL);
  }

  ReceiveText* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReceiveText>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReceiveText& from);
  void MergeFrom(const ReceiveText& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveText* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // .Player player = 1;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  private:
  const ::Player& _internal_player() const;
  public:
  const ::Player& player() const;
  ::Player* release_player();
  ::Player* mutable_player();
  void set_allocated_player(::Player* player);

  // @@protoc_insertion_point(class_scope:bwapi.event.ReceiveText)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::Player* player_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerLeft : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.PlayerLeft) */ {
 public:
  PlayerLeft();
  virtual ~PlayerLeft();

  PlayerLeft(const PlayerLeft& from);

  inline PlayerLeft& operator=(const PlayerLeft& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerLeft(PlayerLeft&& from) noexcept
    : PlayerLeft() {
    *this = ::std::move(from);
  }

  inline PlayerLeft& operator=(PlayerLeft&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLeft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLeft* internal_default_instance() {
    return reinterpret_cast<const PlayerLeft*>(
               &_PlayerLeft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PlayerLeft* other);
  friend void swap(PlayerLeft& a, PlayerLeft& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerLeft* New() const final {
    return CreateMaybeMessage<PlayerLeft>(NULL);
  }

  PlayerLeft* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerLeft>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerLeft& from);
  void MergeFrom(const PlayerLeft& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerLeft* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Player player = 1;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  private:
  const ::Player& _internal_player() const;
  public:
  const ::Player& player() const;
  ::Player* release_player();
  ::Player* mutable_player();
  void set_allocated_player(::Player* player);

  // @@protoc_insertion_point(class_scope:bwapi.event.PlayerLeft)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Player* player_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NukeDetect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.NukeDetect) */ {
 public:
  NukeDetect();
  virtual ~NukeDetect();

  NukeDetect(const NukeDetect& from);

  inline NukeDetect& operator=(const NukeDetect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NukeDetect(NukeDetect&& from) noexcept
    : NukeDetect() {
    *this = ::std::move(from);
  }

  inline NukeDetect& operator=(NukeDetect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NukeDetect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NukeDetect* internal_default_instance() {
    return reinterpret_cast<const NukeDetect*>(
               &_NukeDetect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NukeDetect* other);
  friend void swap(NukeDetect& a, NukeDetect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NukeDetect* New() const final {
    return CreateMaybeMessage<NukeDetect>(NULL);
  }

  NukeDetect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NukeDetect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NukeDetect& from);
  void MergeFrom(const NukeDetect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NukeDetect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Point target = 1;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  private:
  const ::Point& _internal_target() const;
  public:
  const ::Point& target() const;
  ::Point* release_target();
  ::Point* mutable_target();
  void set_allocated_target(::Point* target);

  // @@protoc_insertion_point(class_scope:bwapi.event.NukeDetect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Point* target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitDiscover : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.UnitDiscover) */ {
 public:
  UnitDiscover();
  virtual ~UnitDiscover();

  UnitDiscover(const UnitDiscover& from);

  inline UnitDiscover& operator=(const UnitDiscover& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitDiscover(UnitDiscover&& from) noexcept
    : UnitDiscover() {
    *this = ::std::move(from);
  }

  inline UnitDiscover& operator=(UnitDiscover&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitDiscover& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitDiscover* internal_default_instance() {
    return reinterpret_cast<const UnitDiscover*>(
               &_UnitDiscover_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(UnitDiscover* other);
  friend void swap(UnitDiscover& a, UnitDiscover& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitDiscover* New() const final {
    return CreateMaybeMessage<UnitDiscover>(NULL);
  }

  UnitDiscover* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitDiscover>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitDiscover& from);
  void MergeFrom(const UnitDiscover& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitDiscover* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Unit unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::Unit& _internal_unit() const;
  public:
  const ::Unit& unit() const;
  ::Unit* release_unit();
  ::Unit* mutable_unit();
  void set_allocated_unit(::Unit* unit);

  // @@protoc_insertion_point(class_scope:bwapi.event.UnitDiscover)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Unit* unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitEvade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.UnitEvade) */ {
 public:
  UnitEvade();
  virtual ~UnitEvade();

  UnitEvade(const UnitEvade& from);

  inline UnitEvade& operator=(const UnitEvade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitEvade(UnitEvade&& from) noexcept
    : UnitEvade() {
    *this = ::std::move(from);
  }

  inline UnitEvade& operator=(UnitEvade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitEvade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitEvade* internal_default_instance() {
    return reinterpret_cast<const UnitEvade*>(
               &_UnitEvade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(UnitEvade* other);
  friend void swap(UnitEvade& a, UnitEvade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitEvade* New() const final {
    return CreateMaybeMessage<UnitEvade>(NULL);
  }

  UnitEvade* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitEvade>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitEvade& from);
  void MergeFrom(const UnitEvade& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitEvade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Unit unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::Unit& _internal_unit() const;
  public:
  const ::Unit& unit() const;
  ::Unit* release_unit();
  ::Unit* mutable_unit();
  void set_allocated_unit(::Unit* unit);

  // @@protoc_insertion_point(class_scope:bwapi.event.UnitEvade)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Unit* unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitShow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.UnitShow) */ {
 public:
  UnitShow();
  virtual ~UnitShow();

  UnitShow(const UnitShow& from);

  inline UnitShow& operator=(const UnitShow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitShow(UnitShow&& from) noexcept
    : UnitShow() {
    *this = ::std::move(from);
  }

  inline UnitShow& operator=(UnitShow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitShow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitShow* internal_default_instance() {
    return reinterpret_cast<const UnitShow*>(
               &_UnitShow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(UnitShow* other);
  friend void swap(UnitShow& a, UnitShow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitShow* New() const final {
    return CreateMaybeMessage<UnitShow>(NULL);
  }

  UnitShow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitShow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitShow& from);
  void MergeFrom(const UnitShow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitShow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Unit unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::Unit& _internal_unit() const;
  public:
  const ::Unit& unit() const;
  ::Unit* release_unit();
  ::Unit* mutable_unit();
  void set_allocated_unit(::Unit* unit);

  // @@protoc_insertion_point(class_scope:bwapi.event.UnitShow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Unit* unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitHide : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.UnitHide) */ {
 public:
  UnitHide();
  virtual ~UnitHide();

  UnitHide(const UnitHide& from);

  inline UnitHide& operator=(const UnitHide& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitHide(UnitHide&& from) noexcept
    : UnitHide() {
    *this = ::std::move(from);
  }

  inline UnitHide& operator=(UnitHide&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitHide& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitHide* internal_default_instance() {
    return reinterpret_cast<const UnitHide*>(
               &_UnitHide_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(UnitHide* other);
  friend void swap(UnitHide& a, UnitHide& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitHide* New() const final {
    return CreateMaybeMessage<UnitHide>(NULL);
  }

  UnitHide* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitHide>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitHide& from);
  void MergeFrom(const UnitHide& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitHide* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Unit unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::Unit& _internal_unit() const;
  public:
  const ::Unit& unit() const;
  ::Unit* release_unit();
  ::Unit* mutable_unit();
  void set_allocated_unit(::Unit* unit);

  // @@protoc_insertion_point(class_scope:bwapi.event.UnitHide)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Unit* unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitCreate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.UnitCreate) */ {
 public:
  UnitCreate();
  virtual ~UnitCreate();

  UnitCreate(const UnitCreate& from);

  inline UnitCreate& operator=(const UnitCreate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitCreate(UnitCreate&& from) noexcept
    : UnitCreate() {
    *this = ::std::move(from);
  }

  inline UnitCreate& operator=(UnitCreate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitCreate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitCreate* internal_default_instance() {
    return reinterpret_cast<const UnitCreate*>(
               &_UnitCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(UnitCreate* other);
  friend void swap(UnitCreate& a, UnitCreate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitCreate* New() const final {
    return CreateMaybeMessage<UnitCreate>(NULL);
  }

  UnitCreate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitCreate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitCreate& from);
  void MergeFrom(const UnitCreate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitCreate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Unit unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::Unit& _internal_unit() const;
  public:
  const ::Unit& unit() const;
  ::Unit* release_unit();
  ::Unit* mutable_unit();
  void set_allocated_unit(::Unit* unit);

  // @@protoc_insertion_point(class_scope:bwapi.event.UnitCreate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Unit* unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitDestroy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.UnitDestroy) */ {
 public:
  UnitDestroy();
  virtual ~UnitDestroy();

  UnitDestroy(const UnitDestroy& from);

  inline UnitDestroy& operator=(const UnitDestroy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitDestroy(UnitDestroy&& from) noexcept
    : UnitDestroy() {
    *this = ::std::move(from);
  }

  inline UnitDestroy& operator=(UnitDestroy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitDestroy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitDestroy* internal_default_instance() {
    return reinterpret_cast<const UnitDestroy*>(
               &_UnitDestroy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(UnitDestroy* other);
  friend void swap(UnitDestroy& a, UnitDestroy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitDestroy* New() const final {
    return CreateMaybeMessage<UnitDestroy>(NULL);
  }

  UnitDestroy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitDestroy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitDestroy& from);
  void MergeFrom(const UnitDestroy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitDestroy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Unit unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::Unit& _internal_unit() const;
  public:
  const ::Unit& unit() const;
  ::Unit* release_unit();
  ::Unit* mutable_unit();
  void set_allocated_unit(::Unit* unit);

  // @@protoc_insertion_point(class_scope:bwapi.event.UnitDestroy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Unit* unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitMorph : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.UnitMorph) */ {
 public:
  UnitMorph();
  virtual ~UnitMorph();

  UnitMorph(const UnitMorph& from);

  inline UnitMorph& operator=(const UnitMorph& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitMorph(UnitMorph&& from) noexcept
    : UnitMorph() {
    *this = ::std::move(from);
  }

  inline UnitMorph& operator=(UnitMorph&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitMorph& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitMorph* internal_default_instance() {
    return reinterpret_cast<const UnitMorph*>(
               &_UnitMorph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(UnitMorph* other);
  friend void swap(UnitMorph& a, UnitMorph& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitMorph* New() const final {
    return CreateMaybeMessage<UnitMorph>(NULL);
  }

  UnitMorph* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitMorph>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitMorph& from);
  void MergeFrom(const UnitMorph& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitMorph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Unit unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::Unit& _internal_unit() const;
  public:
  const ::Unit& unit() const;
  ::Unit* release_unit();
  ::Unit* mutable_unit();
  void set_allocated_unit(::Unit* unit);

  // @@protoc_insertion_point(class_scope:bwapi.event.UnitMorph)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Unit* unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitRenegade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.UnitRenegade) */ {
 public:
  UnitRenegade();
  virtual ~UnitRenegade();

  UnitRenegade(const UnitRenegade& from);

  inline UnitRenegade& operator=(const UnitRenegade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitRenegade(UnitRenegade&& from) noexcept
    : UnitRenegade() {
    *this = ::std::move(from);
  }

  inline UnitRenegade& operator=(UnitRenegade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitRenegade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitRenegade* internal_default_instance() {
    return reinterpret_cast<const UnitRenegade*>(
               &_UnitRenegade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(UnitRenegade* other);
  friend void swap(UnitRenegade& a, UnitRenegade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitRenegade* New() const final {
    return CreateMaybeMessage<UnitRenegade>(NULL);
  }

  UnitRenegade* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitRenegade>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitRenegade& from);
  void MergeFrom(const UnitRenegade& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitRenegade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Unit unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::Unit& _internal_unit() const;
  public:
  const ::Unit& unit() const;
  ::Unit* release_unit();
  ::Unit* mutable_unit();
  void set_allocated_unit(::Unit* unit);

  // @@protoc_insertion_point(class_scope:bwapi.event.UnitRenegade)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Unit* unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SaveGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.SaveGame) */ {
 public:
  SaveGame();
  virtual ~SaveGame();

  SaveGame(const SaveGame& from);

  inline SaveGame& operator=(const SaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SaveGame(SaveGame&& from) noexcept
    : SaveGame() {
    *this = ::std::move(from);
  }

  inline SaveGame& operator=(SaveGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SaveGame* internal_default_instance() {
    return reinterpret_cast<const SaveGame*>(
               &_SaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(SaveGame* other);
  friend void swap(SaveGame& a, SaveGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SaveGame* New() const final {
    return CreateMaybeMessage<SaveGame>(NULL);
  }

  SaveGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SaveGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SaveGame& from);
  void MergeFrom(const SaveGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:bwapi.event.SaveGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitComplete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.UnitComplete) */ {
 public:
  UnitComplete();
  virtual ~UnitComplete();

  UnitComplete(const UnitComplete& from);

  inline UnitComplete& operator=(const UnitComplete& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitComplete(UnitComplete&& from) noexcept
    : UnitComplete() {
    *this = ::std::move(from);
  }

  inline UnitComplete& operator=(UnitComplete&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitComplete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitComplete* internal_default_instance() {
    return reinterpret_cast<const UnitComplete*>(
               &_UnitComplete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(UnitComplete* other);
  friend void swap(UnitComplete& a, UnitComplete& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitComplete* New() const final {
    return CreateMaybeMessage<UnitComplete>(NULL);
  }

  UnitComplete* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitComplete>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitComplete& from);
  void MergeFrom(const UnitComplete& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitComplete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Unit unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::Unit& _internal_unit() const;
  public:
  const ::Unit& unit() const;
  ::Unit* release_unit();
  ::Unit* mutable_unit();
  void set_allocated_unit(::Unit* unit);

  // @@protoc_insertion_point(class_scope:bwapi.event.UnitComplete)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Unit* unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_event_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bwapi.event.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  enum EventCase {
    kMatchStart = 1,
    kMatchEnd = 2,
    kMatchFrame = 3,
    kMenuFrame = 4,
    kSendText = 5,
    kReceiveText = 6,
    kPlayerLeft = 7,
    kNukeDetect = 8,
    kUnitDiscover = 9,
    kUnitEvade = 10,
    kUnitShow = 11,
    kUnitHite = 12,
    kUnitCreate = 13,
    kUnitDestroy = 14,
    kUnitMorph = 15,
    kUnitRenegade = 16,
    kSaveGame = 17,
    kUnitComplete = 18,
    EVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bwapi.event.MatchStart matchStart = 1;
  bool has_matchstart() const;
  void clear_matchstart();
  static const int kMatchStartFieldNumber = 1;
  private:
  const ::bwapi::event::MatchStart& _internal_matchstart() const;
  public:
  const ::bwapi::event::MatchStart& matchstart() const;
  ::bwapi::event::MatchStart* release_matchstart();
  ::bwapi::event::MatchStart* mutable_matchstart();
  void set_allocated_matchstart(::bwapi::event::MatchStart* matchstart);

  // .bwapi.event.MatchEnd matchEnd = 2;
  bool has_matchend() const;
  void clear_matchend();
  static const int kMatchEndFieldNumber = 2;
  private:
  const ::bwapi::event::MatchEnd& _internal_matchend() const;
  public:
  const ::bwapi::event::MatchEnd& matchend() const;
  ::bwapi::event::MatchEnd* release_matchend();
  ::bwapi::event::MatchEnd* mutable_matchend();
  void set_allocated_matchend(::bwapi::event::MatchEnd* matchend);

  // .bwapi.event.MatchFrame matchFrame = 3;
  bool has_matchframe() const;
  void clear_matchframe();
  static const int kMatchFrameFieldNumber = 3;
  private:
  const ::bwapi::event::MatchFrame& _internal_matchframe() const;
  public:
  const ::bwapi::event::MatchFrame& matchframe() const;
  ::bwapi::event::MatchFrame* release_matchframe();
  ::bwapi::event::MatchFrame* mutable_matchframe();
  void set_allocated_matchframe(::bwapi::event::MatchFrame* matchframe);

  // .bwapi.event.MenuFrame menuFrame = 4;
  bool has_menuframe() const;
  void clear_menuframe();
  static const int kMenuFrameFieldNumber = 4;
  private:
  const ::bwapi::event::MenuFrame& _internal_menuframe() const;
  public:
  const ::bwapi::event::MenuFrame& menuframe() const;
  ::bwapi::event::MenuFrame* release_menuframe();
  ::bwapi::event::MenuFrame* mutable_menuframe();
  void set_allocated_menuframe(::bwapi::event::MenuFrame* menuframe);

  // .bwapi.event.SendText sendText = 5;
  bool has_sendtext() const;
  void clear_sendtext();
  static const int kSendTextFieldNumber = 5;
  private:
  const ::bwapi::event::SendText& _internal_sendtext() const;
  public:
  const ::bwapi::event::SendText& sendtext() const;
  ::bwapi::event::SendText* release_sendtext();
  ::bwapi::event::SendText* mutable_sendtext();
  void set_allocated_sendtext(::bwapi::event::SendText* sendtext);

  // .bwapi.event.ReceiveText receiveText = 6;
  bool has_receivetext() const;
  void clear_receivetext();
  static const int kReceiveTextFieldNumber = 6;
  private:
  const ::bwapi::event::ReceiveText& _internal_receivetext() const;
  public:
  const ::bwapi::event::ReceiveText& receivetext() const;
  ::bwapi::event::ReceiveText* release_receivetext();
  ::bwapi::event::ReceiveText* mutable_receivetext();
  void set_allocated_receivetext(::bwapi::event::ReceiveText* receivetext);

  // .bwapi.event.PlayerLeft playerLeft = 7;
  bool has_playerleft() const;
  void clear_playerleft();
  static const int kPlayerLeftFieldNumber = 7;
  private:
  const ::bwapi::event::PlayerLeft& _internal_playerleft() const;
  public:
  const ::bwapi::event::PlayerLeft& playerleft() const;
  ::bwapi::event::PlayerLeft* release_playerleft();
  ::bwapi::event::PlayerLeft* mutable_playerleft();
  void set_allocated_playerleft(::bwapi::event::PlayerLeft* playerleft);

  // .bwapi.event.NukeDetect nukeDetect = 8;
  bool has_nukedetect() const;
  void clear_nukedetect();
  static const int kNukeDetectFieldNumber = 8;
  private:
  const ::bwapi::event::NukeDetect& _internal_nukedetect() const;
  public:
  const ::bwapi::event::NukeDetect& nukedetect() const;
  ::bwapi::event::NukeDetect* release_nukedetect();
  ::bwapi::event::NukeDetect* mutable_nukedetect();
  void set_allocated_nukedetect(::bwapi::event::NukeDetect* nukedetect);

  // .bwapi.event.UnitDiscover unitDiscover = 9;
  bool has_unitdiscover() const;
  void clear_unitdiscover();
  static const int kUnitDiscoverFieldNumber = 9;
  private:
  const ::bwapi::event::UnitDiscover& _internal_unitdiscover() const;
  public:
  const ::bwapi::event::UnitDiscover& unitdiscover() const;
  ::bwapi::event::UnitDiscover* release_unitdiscover();
  ::bwapi::event::UnitDiscover* mutable_unitdiscover();
  void set_allocated_unitdiscover(::bwapi::event::UnitDiscover* unitdiscover);

  // .bwapi.event.UnitEvade unitEvade = 10;
  bool has_unitevade() const;
  void clear_unitevade();
  static const int kUnitEvadeFieldNumber = 10;
  private:
  const ::bwapi::event::UnitEvade& _internal_unitevade() const;
  public:
  const ::bwapi::event::UnitEvade& unitevade() const;
  ::bwapi::event::UnitEvade* release_unitevade();
  ::bwapi::event::UnitEvade* mutable_unitevade();
  void set_allocated_unitevade(::bwapi::event::UnitEvade* unitevade);

  // .bwapi.event.UnitShow unitShow = 11;
  bool has_unitshow() const;
  void clear_unitshow();
  static const int kUnitShowFieldNumber = 11;
  private:
  const ::bwapi::event::UnitShow& _internal_unitshow() const;
  public:
  const ::bwapi::event::UnitShow& unitshow() const;
  ::bwapi::event::UnitShow* release_unitshow();
  ::bwapi::event::UnitShow* mutable_unitshow();
  void set_allocated_unitshow(::bwapi::event::UnitShow* unitshow);

  // .bwapi.event.UnitHide unitHite = 12;
  bool has_unithite() const;
  void clear_unithite();
  static const int kUnitHiteFieldNumber = 12;
  private:
  const ::bwapi::event::UnitHide& _internal_unithite() const;
  public:
  const ::bwapi::event::UnitHide& unithite() const;
  ::bwapi::event::UnitHide* release_unithite();
  ::bwapi::event::UnitHide* mutable_unithite();
  void set_allocated_unithite(::bwapi::event::UnitHide* unithite);

  // .bwapi.event.UnitCreate unitCreate = 13;
  bool has_unitcreate() const;
  void clear_unitcreate();
  static const int kUnitCreateFieldNumber = 13;
  private:
  const ::bwapi::event::UnitCreate& _internal_unitcreate() const;
  public:
  const ::bwapi::event::UnitCreate& unitcreate() const;
  ::bwapi::event::UnitCreate* release_unitcreate();
  ::bwapi::event::UnitCreate* mutable_unitcreate();
  void set_allocated_unitcreate(::bwapi::event::UnitCreate* unitcreate);

  // .bwapi.event.UnitDestroy unitDestroy = 14;
  bool has_unitdestroy() const;
  void clear_unitdestroy();
  static const int kUnitDestroyFieldNumber = 14;
  private:
  const ::bwapi::event::UnitDestroy& _internal_unitdestroy() const;
  public:
  const ::bwapi::event::UnitDestroy& unitdestroy() const;
  ::bwapi::event::UnitDestroy* release_unitdestroy();
  ::bwapi::event::UnitDestroy* mutable_unitdestroy();
  void set_allocated_unitdestroy(::bwapi::event::UnitDestroy* unitdestroy);

  // .bwapi.event.UnitMorph unitMorph = 15;
  bool has_unitmorph() const;
  void clear_unitmorph();
  static const int kUnitMorphFieldNumber = 15;
  private:
  const ::bwapi::event::UnitMorph& _internal_unitmorph() const;
  public:
  const ::bwapi::event::UnitMorph& unitmorph() const;
  ::bwapi::event::UnitMorph* release_unitmorph();
  ::bwapi::event::UnitMorph* mutable_unitmorph();
  void set_allocated_unitmorph(::bwapi::event::UnitMorph* unitmorph);

  // .bwapi.event.UnitRenegade unitRenegade = 16;
  bool has_unitrenegade() const;
  void clear_unitrenegade();
  static const int kUnitRenegadeFieldNumber = 16;
  private:
  const ::bwapi::event::UnitRenegade& _internal_unitrenegade() const;
  public:
  const ::bwapi::event::UnitRenegade& unitrenegade() const;
  ::bwapi::event::UnitRenegade* release_unitrenegade();
  ::bwapi::event::UnitRenegade* mutable_unitrenegade();
  void set_allocated_unitrenegade(::bwapi::event::UnitRenegade* unitrenegade);

  // .bwapi.event.SaveGame saveGame = 17;
  bool has_savegame() const;
  void clear_savegame();
  static const int kSaveGameFieldNumber = 17;
  private:
  const ::bwapi::event::SaveGame& _internal_savegame() const;
  public:
  const ::bwapi::event::SaveGame& savegame() const;
  ::bwapi::event::SaveGame* release_savegame();
  ::bwapi::event::SaveGame* mutable_savegame();
  void set_allocated_savegame(::bwapi::event::SaveGame* savegame);

  // .bwapi.event.UnitComplete unitComplete = 18;
  bool has_unitcomplete() const;
  void clear_unitcomplete();
  static const int kUnitCompleteFieldNumber = 18;
  private:
  const ::bwapi::event::UnitComplete& _internal_unitcomplete() const;
  public:
  const ::bwapi::event::UnitComplete& unitcomplete() const;
  ::bwapi::event::UnitComplete* release_unitcomplete();
  ::bwapi::event::UnitComplete* mutable_unitcomplete();
  void set_allocated_unitcomplete(::bwapi::event::UnitComplete* unitcomplete);

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:bwapi.event.Event)
 private:
  void set_has_matchstart();
  void set_has_matchend();
  void set_has_matchframe();
  void set_has_menuframe();
  void set_has_sendtext();
  void set_has_receivetext();
  void set_has_playerleft();
  void set_has_nukedetect();
  void set_has_unitdiscover();
  void set_has_unitevade();
  void set_has_unitshow();
  void set_has_unithite();
  void set_has_unitcreate();
  void set_has_unitdestroy();
  void set_has_unitmorph();
  void set_has_unitrenegade();
  void set_has_savegame();
  void set_has_unitcomplete();

  inline bool has_event() const;
  inline void clear_has_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union EventUnion {
    EventUnion() {}
    ::bwapi::event::MatchStart* matchstart_;
    ::bwapi::event::MatchEnd* matchend_;
    ::bwapi::event::MatchFrame* matchframe_;
    ::bwapi::event::MenuFrame* menuframe_;
    ::bwapi::event::SendText* sendtext_;
    ::bwapi::event::ReceiveText* receivetext_;
    ::bwapi::event::PlayerLeft* playerleft_;
    ::bwapi::event::NukeDetect* nukedetect_;
    ::bwapi::event::UnitDiscover* unitdiscover_;
    ::bwapi::event::UnitEvade* unitevade_;
    ::bwapi::event::UnitShow* unitshow_;
    ::bwapi::event::UnitHide* unithite_;
    ::bwapi::event::UnitCreate* unitcreate_;
    ::bwapi::event::UnitDestroy* unitdestroy_;
    ::bwapi::event::UnitMorph* unitmorph_;
    ::bwapi::event::UnitRenegade* unitrenegade_;
    ::bwapi::event::SaveGame* savegame_;
    ::bwapi::event::UnitComplete* unitcomplete_;
  } event_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_event_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MatchStart

// -------------------------------------------------------------------

// MatchEnd

// bool winner = 1;
inline void MatchEnd::clear_winner() {
  winner_ = false;
}
inline bool MatchEnd::winner() const {
  // @@protoc_insertion_point(field_get:bwapi.event.MatchEnd.winner)
  return winner_;
}
inline void MatchEnd::set_winner(bool value) {
  
  winner_ = value;
  // @@protoc_insertion_point(field_set:bwapi.event.MatchEnd.winner)
}

// -------------------------------------------------------------------

// MatchFrame

// -------------------------------------------------------------------

// MenuFrame

// -------------------------------------------------------------------

// SendText

// string text = 1;
inline void SendText::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendText::text() const {
  // @@protoc_insertion_point(field_get:bwapi.event.SendText.text)
  return text_.GetNoArena();
}
inline void SendText::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bwapi.event.SendText.text)
}
#if LANG_CXX11
inline void SendText::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bwapi.event.SendText.text)
}
#endif
inline void SendText::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bwapi.event.SendText.text)
}
inline void SendText::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bwapi.event.SendText.text)
}
inline ::std::string* SendText::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:bwapi.event.SendText.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendText::release_text() {
  // @@protoc_insertion_point(field_release:bwapi.event.SendText.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendText::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.SendText.text)
}

// -------------------------------------------------------------------

// ReceiveText

// .Player player = 1;
inline bool ReceiveText::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline const ::Player& ReceiveText::_internal_player() const {
  return *player_;
}
inline const ::Player& ReceiveText::player() const {
  const ::Player* p = player_;
  // @@protoc_insertion_point(field_get:bwapi.event.ReceiveText.player)
  return p != NULL ? *p : *reinterpret_cast<const ::Player*>(
      &::_Player_default_instance_);
}
inline ::Player* ReceiveText::release_player() {
  // @@protoc_insertion_point(field_release:bwapi.event.ReceiveText.player)
  
  ::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::Player* ReceiveText::mutable_player() {
  
  if (player_ == NULL) {
    auto* p = CreateMaybeMessage<::Player>(GetArenaNoVirtual());
    player_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.ReceiveText.player)
  return player_;
}
inline void ReceiveText::set_allocated_player(::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(player_);
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.ReceiveText.player)
}

// string text = 2;
inline void ReceiveText::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReceiveText::text() const {
  // @@protoc_insertion_point(field_get:bwapi.event.ReceiveText.text)
  return text_.GetNoArena();
}
inline void ReceiveText::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bwapi.event.ReceiveText.text)
}
#if LANG_CXX11
inline void ReceiveText::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bwapi.event.ReceiveText.text)
}
#endif
inline void ReceiveText::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bwapi.event.ReceiveText.text)
}
inline void ReceiveText::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bwapi.event.ReceiveText.text)
}
inline ::std::string* ReceiveText::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:bwapi.event.ReceiveText.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceiveText::release_text() {
  // @@protoc_insertion_point(field_release:bwapi.event.ReceiveText.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveText::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.ReceiveText.text)
}

// -------------------------------------------------------------------

// PlayerLeft

// .Player player = 1;
inline bool PlayerLeft::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline const ::Player& PlayerLeft::_internal_player() const {
  return *player_;
}
inline const ::Player& PlayerLeft::player() const {
  const ::Player* p = player_;
  // @@protoc_insertion_point(field_get:bwapi.event.PlayerLeft.player)
  return p != NULL ? *p : *reinterpret_cast<const ::Player*>(
      &::_Player_default_instance_);
}
inline ::Player* PlayerLeft::release_player() {
  // @@protoc_insertion_point(field_release:bwapi.event.PlayerLeft.player)
  
  ::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::Player* PlayerLeft::mutable_player() {
  
  if (player_ == NULL) {
    auto* p = CreateMaybeMessage<::Player>(GetArenaNoVirtual());
    player_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.PlayerLeft.player)
  return player_;
}
inline void PlayerLeft::set_allocated_player(::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(player_);
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.PlayerLeft.player)
}

// -------------------------------------------------------------------

// NukeDetect

// .Point target = 1;
inline bool NukeDetect::has_target() const {
  return this != internal_default_instance() && target_ != NULL;
}
inline const ::Point& NukeDetect::_internal_target() const {
  return *target_;
}
inline const ::Point& NukeDetect::target() const {
  const ::Point* p = target_;
  // @@protoc_insertion_point(field_get:bwapi.event.NukeDetect.target)
  return p != NULL ? *p : *reinterpret_cast<const ::Point*>(
      &::_Point_default_instance_);
}
inline ::Point* NukeDetect::release_target() {
  // @@protoc_insertion_point(field_release:bwapi.event.NukeDetect.target)
  
  ::Point* temp = target_;
  target_ = NULL;
  return temp;
}
inline ::Point* NukeDetect::mutable_target() {
  
  if (target_ == NULL) {
    auto* p = CreateMaybeMessage<::Point>(GetArenaNoVirtual());
    target_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.NukeDetect.target)
  return target_;
}
inline void NukeDetect::set_allocated_target(::Point* target) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(target_);
  }
  if (target) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.NukeDetect.target)
}

// -------------------------------------------------------------------

// UnitDiscover

// .Unit unit = 1;
inline bool UnitDiscover::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
inline const ::Unit& UnitDiscover::_internal_unit() const {
  return *unit_;
}
inline const ::Unit& UnitDiscover::unit() const {
  const ::Unit* p = unit_;
  // @@protoc_insertion_point(field_get:bwapi.event.UnitDiscover.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::Unit*>(
      &::_Unit_default_instance_);
}
inline ::Unit* UnitDiscover::release_unit() {
  // @@protoc_insertion_point(field_release:bwapi.event.UnitDiscover.unit)
  
  ::Unit* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::Unit* UnitDiscover::mutable_unit() {
  
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::Unit>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.UnitDiscover.unit)
  return unit_;
}
inline void UnitDiscover::set_allocated_unit(::Unit* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_);
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.UnitDiscover.unit)
}

// -------------------------------------------------------------------

// UnitEvade

// .Unit unit = 1;
inline bool UnitEvade::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
inline const ::Unit& UnitEvade::_internal_unit() const {
  return *unit_;
}
inline const ::Unit& UnitEvade::unit() const {
  const ::Unit* p = unit_;
  // @@protoc_insertion_point(field_get:bwapi.event.UnitEvade.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::Unit*>(
      &::_Unit_default_instance_);
}
inline ::Unit* UnitEvade::release_unit() {
  // @@protoc_insertion_point(field_release:bwapi.event.UnitEvade.unit)
  
  ::Unit* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::Unit* UnitEvade::mutable_unit() {
  
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::Unit>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.UnitEvade.unit)
  return unit_;
}
inline void UnitEvade::set_allocated_unit(::Unit* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_);
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.UnitEvade.unit)
}

// -------------------------------------------------------------------

// UnitShow

// .Unit unit = 1;
inline bool UnitShow::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
inline const ::Unit& UnitShow::_internal_unit() const {
  return *unit_;
}
inline const ::Unit& UnitShow::unit() const {
  const ::Unit* p = unit_;
  // @@protoc_insertion_point(field_get:bwapi.event.UnitShow.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::Unit*>(
      &::_Unit_default_instance_);
}
inline ::Unit* UnitShow::release_unit() {
  // @@protoc_insertion_point(field_release:bwapi.event.UnitShow.unit)
  
  ::Unit* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::Unit* UnitShow::mutable_unit() {
  
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::Unit>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.UnitShow.unit)
  return unit_;
}
inline void UnitShow::set_allocated_unit(::Unit* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_);
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.UnitShow.unit)
}

// -------------------------------------------------------------------

// UnitHide

// .Unit unit = 1;
inline bool UnitHide::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
inline const ::Unit& UnitHide::_internal_unit() const {
  return *unit_;
}
inline const ::Unit& UnitHide::unit() const {
  const ::Unit* p = unit_;
  // @@protoc_insertion_point(field_get:bwapi.event.UnitHide.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::Unit*>(
      &::_Unit_default_instance_);
}
inline ::Unit* UnitHide::release_unit() {
  // @@protoc_insertion_point(field_release:bwapi.event.UnitHide.unit)
  
  ::Unit* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::Unit* UnitHide::mutable_unit() {
  
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::Unit>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.UnitHide.unit)
  return unit_;
}
inline void UnitHide::set_allocated_unit(::Unit* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_);
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.UnitHide.unit)
}

// -------------------------------------------------------------------

// UnitCreate

// .Unit unit = 1;
inline bool UnitCreate::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
inline const ::Unit& UnitCreate::_internal_unit() const {
  return *unit_;
}
inline const ::Unit& UnitCreate::unit() const {
  const ::Unit* p = unit_;
  // @@protoc_insertion_point(field_get:bwapi.event.UnitCreate.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::Unit*>(
      &::_Unit_default_instance_);
}
inline ::Unit* UnitCreate::release_unit() {
  // @@protoc_insertion_point(field_release:bwapi.event.UnitCreate.unit)
  
  ::Unit* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::Unit* UnitCreate::mutable_unit() {
  
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::Unit>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.UnitCreate.unit)
  return unit_;
}
inline void UnitCreate::set_allocated_unit(::Unit* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_);
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.UnitCreate.unit)
}

// -------------------------------------------------------------------

// UnitDestroy

// .Unit unit = 1;
inline bool UnitDestroy::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
inline const ::Unit& UnitDestroy::_internal_unit() const {
  return *unit_;
}
inline const ::Unit& UnitDestroy::unit() const {
  const ::Unit* p = unit_;
  // @@protoc_insertion_point(field_get:bwapi.event.UnitDestroy.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::Unit*>(
      &::_Unit_default_instance_);
}
inline ::Unit* UnitDestroy::release_unit() {
  // @@protoc_insertion_point(field_release:bwapi.event.UnitDestroy.unit)
  
  ::Unit* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::Unit* UnitDestroy::mutable_unit() {
  
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::Unit>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.UnitDestroy.unit)
  return unit_;
}
inline void UnitDestroy::set_allocated_unit(::Unit* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_);
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.UnitDestroy.unit)
}

// -------------------------------------------------------------------

// UnitMorph

// .Unit unit = 1;
inline bool UnitMorph::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
inline const ::Unit& UnitMorph::_internal_unit() const {
  return *unit_;
}
inline const ::Unit& UnitMorph::unit() const {
  const ::Unit* p = unit_;
  // @@protoc_insertion_point(field_get:bwapi.event.UnitMorph.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::Unit*>(
      &::_Unit_default_instance_);
}
inline ::Unit* UnitMorph::release_unit() {
  // @@protoc_insertion_point(field_release:bwapi.event.UnitMorph.unit)
  
  ::Unit* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::Unit* UnitMorph::mutable_unit() {
  
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::Unit>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.UnitMorph.unit)
  return unit_;
}
inline void UnitMorph::set_allocated_unit(::Unit* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_);
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.UnitMorph.unit)
}

// -------------------------------------------------------------------

// UnitRenegade

// .Unit unit = 1;
inline bool UnitRenegade::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
inline const ::Unit& UnitRenegade::_internal_unit() const {
  return *unit_;
}
inline const ::Unit& UnitRenegade::unit() const {
  const ::Unit* p = unit_;
  // @@protoc_insertion_point(field_get:bwapi.event.UnitRenegade.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::Unit*>(
      &::_Unit_default_instance_);
}
inline ::Unit* UnitRenegade::release_unit() {
  // @@protoc_insertion_point(field_release:bwapi.event.UnitRenegade.unit)
  
  ::Unit* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::Unit* UnitRenegade::mutable_unit() {
  
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::Unit>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.UnitRenegade.unit)
  return unit_;
}
inline void UnitRenegade::set_allocated_unit(::Unit* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_);
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.UnitRenegade.unit)
}

// -------------------------------------------------------------------

// SaveGame

// string text = 1;
inline void SaveGame::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SaveGame::text() const {
  // @@protoc_insertion_point(field_get:bwapi.event.SaveGame.text)
  return text_.GetNoArena();
}
inline void SaveGame::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bwapi.event.SaveGame.text)
}
#if LANG_CXX11
inline void SaveGame::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bwapi.event.SaveGame.text)
}
#endif
inline void SaveGame::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bwapi.event.SaveGame.text)
}
inline void SaveGame::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bwapi.event.SaveGame.text)
}
inline ::std::string* SaveGame::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:bwapi.event.SaveGame.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SaveGame::release_text() {
  // @@protoc_insertion_point(field_release:bwapi.event.SaveGame.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SaveGame::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.SaveGame.text)
}

// -------------------------------------------------------------------

// UnitComplete

// .Unit unit = 1;
inline bool UnitComplete::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
inline const ::Unit& UnitComplete::_internal_unit() const {
  return *unit_;
}
inline const ::Unit& UnitComplete::unit() const {
  const ::Unit* p = unit_;
  // @@protoc_insertion_point(field_get:bwapi.event.UnitComplete.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::Unit*>(
      &::_Unit_default_instance_);
}
inline ::Unit* UnitComplete::release_unit() {
  // @@protoc_insertion_point(field_release:bwapi.event.UnitComplete.unit)
  
  ::Unit* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::Unit* UnitComplete::mutable_unit() {
  
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::Unit>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.UnitComplete.unit)
  return unit_;
}
inline void UnitComplete::set_allocated_unit(::Unit* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_);
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:bwapi.event.UnitComplete.unit)
}

// -------------------------------------------------------------------

// Event

// .bwapi.event.MatchStart matchStart = 1;
inline bool Event::has_matchstart() const {
  return event_case() == kMatchStart;
}
inline void Event::set_has_matchstart() {
  _oneof_case_[0] = kMatchStart;
}
inline void Event::clear_matchstart() {
  if (has_matchstart()) {
    delete event_.matchstart_;
    clear_has_event();
  }
}
inline const ::bwapi::event::MatchStart& Event::_internal_matchstart() const {
  return *event_.matchstart_;
}
inline ::bwapi::event::MatchStart* Event::release_matchstart() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.matchStart)
  if (has_matchstart()) {
    clear_has_event();
      ::bwapi::event::MatchStart* temp = event_.matchstart_;
    event_.matchstart_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::MatchStart& Event::matchstart() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.matchStart)
  return has_matchstart()
      ? *event_.matchstart_
      : *reinterpret_cast< ::bwapi::event::MatchStart*>(&::bwapi::event::_MatchStart_default_instance_);
}
inline ::bwapi::event::MatchStart* Event::mutable_matchstart() {
  if (!has_matchstart()) {
    clear_event();
    set_has_matchstart();
    event_.matchstart_ = CreateMaybeMessage< ::bwapi::event::MatchStart >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.matchStart)
  return event_.matchstart_;
}

// .bwapi.event.MatchEnd matchEnd = 2;
inline bool Event::has_matchend() const {
  return event_case() == kMatchEnd;
}
inline void Event::set_has_matchend() {
  _oneof_case_[0] = kMatchEnd;
}
inline void Event::clear_matchend() {
  if (has_matchend()) {
    delete event_.matchend_;
    clear_has_event();
  }
}
inline const ::bwapi::event::MatchEnd& Event::_internal_matchend() const {
  return *event_.matchend_;
}
inline ::bwapi::event::MatchEnd* Event::release_matchend() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.matchEnd)
  if (has_matchend()) {
    clear_has_event();
      ::bwapi::event::MatchEnd* temp = event_.matchend_;
    event_.matchend_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::MatchEnd& Event::matchend() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.matchEnd)
  return has_matchend()
      ? *event_.matchend_
      : *reinterpret_cast< ::bwapi::event::MatchEnd*>(&::bwapi::event::_MatchEnd_default_instance_);
}
inline ::bwapi::event::MatchEnd* Event::mutable_matchend() {
  if (!has_matchend()) {
    clear_event();
    set_has_matchend();
    event_.matchend_ = CreateMaybeMessage< ::bwapi::event::MatchEnd >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.matchEnd)
  return event_.matchend_;
}

// .bwapi.event.MatchFrame matchFrame = 3;
inline bool Event::has_matchframe() const {
  return event_case() == kMatchFrame;
}
inline void Event::set_has_matchframe() {
  _oneof_case_[0] = kMatchFrame;
}
inline void Event::clear_matchframe() {
  if (has_matchframe()) {
    delete event_.matchframe_;
    clear_has_event();
  }
}
inline const ::bwapi::event::MatchFrame& Event::_internal_matchframe() const {
  return *event_.matchframe_;
}
inline ::bwapi::event::MatchFrame* Event::release_matchframe() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.matchFrame)
  if (has_matchframe()) {
    clear_has_event();
      ::bwapi::event::MatchFrame* temp = event_.matchframe_;
    event_.matchframe_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::MatchFrame& Event::matchframe() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.matchFrame)
  return has_matchframe()
      ? *event_.matchframe_
      : *reinterpret_cast< ::bwapi::event::MatchFrame*>(&::bwapi::event::_MatchFrame_default_instance_);
}
inline ::bwapi::event::MatchFrame* Event::mutable_matchframe() {
  if (!has_matchframe()) {
    clear_event();
    set_has_matchframe();
    event_.matchframe_ = CreateMaybeMessage< ::bwapi::event::MatchFrame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.matchFrame)
  return event_.matchframe_;
}

// .bwapi.event.MenuFrame menuFrame = 4;
inline bool Event::has_menuframe() const {
  return event_case() == kMenuFrame;
}
inline void Event::set_has_menuframe() {
  _oneof_case_[0] = kMenuFrame;
}
inline void Event::clear_menuframe() {
  if (has_menuframe()) {
    delete event_.menuframe_;
    clear_has_event();
  }
}
inline const ::bwapi::event::MenuFrame& Event::_internal_menuframe() const {
  return *event_.menuframe_;
}
inline ::bwapi::event::MenuFrame* Event::release_menuframe() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.menuFrame)
  if (has_menuframe()) {
    clear_has_event();
      ::bwapi::event::MenuFrame* temp = event_.menuframe_;
    event_.menuframe_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::MenuFrame& Event::menuframe() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.menuFrame)
  return has_menuframe()
      ? *event_.menuframe_
      : *reinterpret_cast< ::bwapi::event::MenuFrame*>(&::bwapi::event::_MenuFrame_default_instance_);
}
inline ::bwapi::event::MenuFrame* Event::mutable_menuframe() {
  if (!has_menuframe()) {
    clear_event();
    set_has_menuframe();
    event_.menuframe_ = CreateMaybeMessage< ::bwapi::event::MenuFrame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.menuFrame)
  return event_.menuframe_;
}

// .bwapi.event.SendText sendText = 5;
inline bool Event::has_sendtext() const {
  return event_case() == kSendText;
}
inline void Event::set_has_sendtext() {
  _oneof_case_[0] = kSendText;
}
inline void Event::clear_sendtext() {
  if (has_sendtext()) {
    delete event_.sendtext_;
    clear_has_event();
  }
}
inline const ::bwapi::event::SendText& Event::_internal_sendtext() const {
  return *event_.sendtext_;
}
inline ::bwapi::event::SendText* Event::release_sendtext() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.sendText)
  if (has_sendtext()) {
    clear_has_event();
      ::bwapi::event::SendText* temp = event_.sendtext_;
    event_.sendtext_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::SendText& Event::sendtext() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.sendText)
  return has_sendtext()
      ? *event_.sendtext_
      : *reinterpret_cast< ::bwapi::event::SendText*>(&::bwapi::event::_SendText_default_instance_);
}
inline ::bwapi::event::SendText* Event::mutable_sendtext() {
  if (!has_sendtext()) {
    clear_event();
    set_has_sendtext();
    event_.sendtext_ = CreateMaybeMessage< ::bwapi::event::SendText >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.sendText)
  return event_.sendtext_;
}

// .bwapi.event.ReceiveText receiveText = 6;
inline bool Event::has_receivetext() const {
  return event_case() == kReceiveText;
}
inline void Event::set_has_receivetext() {
  _oneof_case_[0] = kReceiveText;
}
inline void Event::clear_receivetext() {
  if (has_receivetext()) {
    delete event_.receivetext_;
    clear_has_event();
  }
}
inline const ::bwapi::event::ReceiveText& Event::_internal_receivetext() const {
  return *event_.receivetext_;
}
inline ::bwapi::event::ReceiveText* Event::release_receivetext() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.receiveText)
  if (has_receivetext()) {
    clear_has_event();
      ::bwapi::event::ReceiveText* temp = event_.receivetext_;
    event_.receivetext_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::ReceiveText& Event::receivetext() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.receiveText)
  return has_receivetext()
      ? *event_.receivetext_
      : *reinterpret_cast< ::bwapi::event::ReceiveText*>(&::bwapi::event::_ReceiveText_default_instance_);
}
inline ::bwapi::event::ReceiveText* Event::mutable_receivetext() {
  if (!has_receivetext()) {
    clear_event();
    set_has_receivetext();
    event_.receivetext_ = CreateMaybeMessage< ::bwapi::event::ReceiveText >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.receiveText)
  return event_.receivetext_;
}

// .bwapi.event.PlayerLeft playerLeft = 7;
inline bool Event::has_playerleft() const {
  return event_case() == kPlayerLeft;
}
inline void Event::set_has_playerleft() {
  _oneof_case_[0] = kPlayerLeft;
}
inline void Event::clear_playerleft() {
  if (has_playerleft()) {
    delete event_.playerleft_;
    clear_has_event();
  }
}
inline const ::bwapi::event::PlayerLeft& Event::_internal_playerleft() const {
  return *event_.playerleft_;
}
inline ::bwapi::event::PlayerLeft* Event::release_playerleft() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.playerLeft)
  if (has_playerleft()) {
    clear_has_event();
      ::bwapi::event::PlayerLeft* temp = event_.playerleft_;
    event_.playerleft_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::PlayerLeft& Event::playerleft() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.playerLeft)
  return has_playerleft()
      ? *event_.playerleft_
      : *reinterpret_cast< ::bwapi::event::PlayerLeft*>(&::bwapi::event::_PlayerLeft_default_instance_);
}
inline ::bwapi::event::PlayerLeft* Event::mutable_playerleft() {
  if (!has_playerleft()) {
    clear_event();
    set_has_playerleft();
    event_.playerleft_ = CreateMaybeMessage< ::bwapi::event::PlayerLeft >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.playerLeft)
  return event_.playerleft_;
}

// .bwapi.event.NukeDetect nukeDetect = 8;
inline bool Event::has_nukedetect() const {
  return event_case() == kNukeDetect;
}
inline void Event::set_has_nukedetect() {
  _oneof_case_[0] = kNukeDetect;
}
inline void Event::clear_nukedetect() {
  if (has_nukedetect()) {
    delete event_.nukedetect_;
    clear_has_event();
  }
}
inline const ::bwapi::event::NukeDetect& Event::_internal_nukedetect() const {
  return *event_.nukedetect_;
}
inline ::bwapi::event::NukeDetect* Event::release_nukedetect() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.nukeDetect)
  if (has_nukedetect()) {
    clear_has_event();
      ::bwapi::event::NukeDetect* temp = event_.nukedetect_;
    event_.nukedetect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::NukeDetect& Event::nukedetect() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.nukeDetect)
  return has_nukedetect()
      ? *event_.nukedetect_
      : *reinterpret_cast< ::bwapi::event::NukeDetect*>(&::bwapi::event::_NukeDetect_default_instance_);
}
inline ::bwapi::event::NukeDetect* Event::mutable_nukedetect() {
  if (!has_nukedetect()) {
    clear_event();
    set_has_nukedetect();
    event_.nukedetect_ = CreateMaybeMessage< ::bwapi::event::NukeDetect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.nukeDetect)
  return event_.nukedetect_;
}

// .bwapi.event.UnitDiscover unitDiscover = 9;
inline bool Event::has_unitdiscover() const {
  return event_case() == kUnitDiscover;
}
inline void Event::set_has_unitdiscover() {
  _oneof_case_[0] = kUnitDiscover;
}
inline void Event::clear_unitdiscover() {
  if (has_unitdiscover()) {
    delete event_.unitdiscover_;
    clear_has_event();
  }
}
inline const ::bwapi::event::UnitDiscover& Event::_internal_unitdiscover() const {
  return *event_.unitdiscover_;
}
inline ::bwapi::event::UnitDiscover* Event::release_unitdiscover() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.unitDiscover)
  if (has_unitdiscover()) {
    clear_has_event();
      ::bwapi::event::UnitDiscover* temp = event_.unitdiscover_;
    event_.unitdiscover_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::UnitDiscover& Event::unitdiscover() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.unitDiscover)
  return has_unitdiscover()
      ? *event_.unitdiscover_
      : *reinterpret_cast< ::bwapi::event::UnitDiscover*>(&::bwapi::event::_UnitDiscover_default_instance_);
}
inline ::bwapi::event::UnitDiscover* Event::mutable_unitdiscover() {
  if (!has_unitdiscover()) {
    clear_event();
    set_has_unitdiscover();
    event_.unitdiscover_ = CreateMaybeMessage< ::bwapi::event::UnitDiscover >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.unitDiscover)
  return event_.unitdiscover_;
}

// .bwapi.event.UnitEvade unitEvade = 10;
inline bool Event::has_unitevade() const {
  return event_case() == kUnitEvade;
}
inline void Event::set_has_unitevade() {
  _oneof_case_[0] = kUnitEvade;
}
inline void Event::clear_unitevade() {
  if (has_unitevade()) {
    delete event_.unitevade_;
    clear_has_event();
  }
}
inline const ::bwapi::event::UnitEvade& Event::_internal_unitevade() const {
  return *event_.unitevade_;
}
inline ::bwapi::event::UnitEvade* Event::release_unitevade() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.unitEvade)
  if (has_unitevade()) {
    clear_has_event();
      ::bwapi::event::UnitEvade* temp = event_.unitevade_;
    event_.unitevade_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::UnitEvade& Event::unitevade() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.unitEvade)
  return has_unitevade()
      ? *event_.unitevade_
      : *reinterpret_cast< ::bwapi::event::UnitEvade*>(&::bwapi::event::_UnitEvade_default_instance_);
}
inline ::bwapi::event::UnitEvade* Event::mutable_unitevade() {
  if (!has_unitevade()) {
    clear_event();
    set_has_unitevade();
    event_.unitevade_ = CreateMaybeMessage< ::bwapi::event::UnitEvade >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.unitEvade)
  return event_.unitevade_;
}

// .bwapi.event.UnitShow unitShow = 11;
inline bool Event::has_unitshow() const {
  return event_case() == kUnitShow;
}
inline void Event::set_has_unitshow() {
  _oneof_case_[0] = kUnitShow;
}
inline void Event::clear_unitshow() {
  if (has_unitshow()) {
    delete event_.unitshow_;
    clear_has_event();
  }
}
inline const ::bwapi::event::UnitShow& Event::_internal_unitshow() const {
  return *event_.unitshow_;
}
inline ::bwapi::event::UnitShow* Event::release_unitshow() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.unitShow)
  if (has_unitshow()) {
    clear_has_event();
      ::bwapi::event::UnitShow* temp = event_.unitshow_;
    event_.unitshow_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::UnitShow& Event::unitshow() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.unitShow)
  return has_unitshow()
      ? *event_.unitshow_
      : *reinterpret_cast< ::bwapi::event::UnitShow*>(&::bwapi::event::_UnitShow_default_instance_);
}
inline ::bwapi::event::UnitShow* Event::mutable_unitshow() {
  if (!has_unitshow()) {
    clear_event();
    set_has_unitshow();
    event_.unitshow_ = CreateMaybeMessage< ::bwapi::event::UnitShow >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.unitShow)
  return event_.unitshow_;
}

// .bwapi.event.UnitHide unitHite = 12;
inline bool Event::has_unithite() const {
  return event_case() == kUnitHite;
}
inline void Event::set_has_unithite() {
  _oneof_case_[0] = kUnitHite;
}
inline void Event::clear_unithite() {
  if (has_unithite()) {
    delete event_.unithite_;
    clear_has_event();
  }
}
inline const ::bwapi::event::UnitHide& Event::_internal_unithite() const {
  return *event_.unithite_;
}
inline ::bwapi::event::UnitHide* Event::release_unithite() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.unitHite)
  if (has_unithite()) {
    clear_has_event();
      ::bwapi::event::UnitHide* temp = event_.unithite_;
    event_.unithite_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::UnitHide& Event::unithite() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.unitHite)
  return has_unithite()
      ? *event_.unithite_
      : *reinterpret_cast< ::bwapi::event::UnitHide*>(&::bwapi::event::_UnitHide_default_instance_);
}
inline ::bwapi::event::UnitHide* Event::mutable_unithite() {
  if (!has_unithite()) {
    clear_event();
    set_has_unithite();
    event_.unithite_ = CreateMaybeMessage< ::bwapi::event::UnitHide >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.unitHite)
  return event_.unithite_;
}

// .bwapi.event.UnitCreate unitCreate = 13;
inline bool Event::has_unitcreate() const {
  return event_case() == kUnitCreate;
}
inline void Event::set_has_unitcreate() {
  _oneof_case_[0] = kUnitCreate;
}
inline void Event::clear_unitcreate() {
  if (has_unitcreate()) {
    delete event_.unitcreate_;
    clear_has_event();
  }
}
inline const ::bwapi::event::UnitCreate& Event::_internal_unitcreate() const {
  return *event_.unitcreate_;
}
inline ::bwapi::event::UnitCreate* Event::release_unitcreate() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.unitCreate)
  if (has_unitcreate()) {
    clear_has_event();
      ::bwapi::event::UnitCreate* temp = event_.unitcreate_;
    event_.unitcreate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::UnitCreate& Event::unitcreate() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.unitCreate)
  return has_unitcreate()
      ? *event_.unitcreate_
      : *reinterpret_cast< ::bwapi::event::UnitCreate*>(&::bwapi::event::_UnitCreate_default_instance_);
}
inline ::bwapi::event::UnitCreate* Event::mutable_unitcreate() {
  if (!has_unitcreate()) {
    clear_event();
    set_has_unitcreate();
    event_.unitcreate_ = CreateMaybeMessage< ::bwapi::event::UnitCreate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.unitCreate)
  return event_.unitcreate_;
}

// .bwapi.event.UnitDestroy unitDestroy = 14;
inline bool Event::has_unitdestroy() const {
  return event_case() == kUnitDestroy;
}
inline void Event::set_has_unitdestroy() {
  _oneof_case_[0] = kUnitDestroy;
}
inline void Event::clear_unitdestroy() {
  if (has_unitdestroy()) {
    delete event_.unitdestroy_;
    clear_has_event();
  }
}
inline const ::bwapi::event::UnitDestroy& Event::_internal_unitdestroy() const {
  return *event_.unitdestroy_;
}
inline ::bwapi::event::UnitDestroy* Event::release_unitdestroy() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.unitDestroy)
  if (has_unitdestroy()) {
    clear_has_event();
      ::bwapi::event::UnitDestroy* temp = event_.unitdestroy_;
    event_.unitdestroy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::UnitDestroy& Event::unitdestroy() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.unitDestroy)
  return has_unitdestroy()
      ? *event_.unitdestroy_
      : *reinterpret_cast< ::bwapi::event::UnitDestroy*>(&::bwapi::event::_UnitDestroy_default_instance_);
}
inline ::bwapi::event::UnitDestroy* Event::mutable_unitdestroy() {
  if (!has_unitdestroy()) {
    clear_event();
    set_has_unitdestroy();
    event_.unitdestroy_ = CreateMaybeMessage< ::bwapi::event::UnitDestroy >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.unitDestroy)
  return event_.unitdestroy_;
}

// .bwapi.event.UnitMorph unitMorph = 15;
inline bool Event::has_unitmorph() const {
  return event_case() == kUnitMorph;
}
inline void Event::set_has_unitmorph() {
  _oneof_case_[0] = kUnitMorph;
}
inline void Event::clear_unitmorph() {
  if (has_unitmorph()) {
    delete event_.unitmorph_;
    clear_has_event();
  }
}
inline const ::bwapi::event::UnitMorph& Event::_internal_unitmorph() const {
  return *event_.unitmorph_;
}
inline ::bwapi::event::UnitMorph* Event::release_unitmorph() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.unitMorph)
  if (has_unitmorph()) {
    clear_has_event();
      ::bwapi::event::UnitMorph* temp = event_.unitmorph_;
    event_.unitmorph_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::UnitMorph& Event::unitmorph() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.unitMorph)
  return has_unitmorph()
      ? *event_.unitmorph_
      : *reinterpret_cast< ::bwapi::event::UnitMorph*>(&::bwapi::event::_UnitMorph_default_instance_);
}
inline ::bwapi::event::UnitMorph* Event::mutable_unitmorph() {
  if (!has_unitmorph()) {
    clear_event();
    set_has_unitmorph();
    event_.unitmorph_ = CreateMaybeMessage< ::bwapi::event::UnitMorph >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.unitMorph)
  return event_.unitmorph_;
}

// .bwapi.event.UnitRenegade unitRenegade = 16;
inline bool Event::has_unitrenegade() const {
  return event_case() == kUnitRenegade;
}
inline void Event::set_has_unitrenegade() {
  _oneof_case_[0] = kUnitRenegade;
}
inline void Event::clear_unitrenegade() {
  if (has_unitrenegade()) {
    delete event_.unitrenegade_;
    clear_has_event();
  }
}
inline const ::bwapi::event::UnitRenegade& Event::_internal_unitrenegade() const {
  return *event_.unitrenegade_;
}
inline ::bwapi::event::UnitRenegade* Event::release_unitrenegade() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.unitRenegade)
  if (has_unitrenegade()) {
    clear_has_event();
      ::bwapi::event::UnitRenegade* temp = event_.unitrenegade_;
    event_.unitrenegade_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::UnitRenegade& Event::unitrenegade() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.unitRenegade)
  return has_unitrenegade()
      ? *event_.unitrenegade_
      : *reinterpret_cast< ::bwapi::event::UnitRenegade*>(&::bwapi::event::_UnitRenegade_default_instance_);
}
inline ::bwapi::event::UnitRenegade* Event::mutable_unitrenegade() {
  if (!has_unitrenegade()) {
    clear_event();
    set_has_unitrenegade();
    event_.unitrenegade_ = CreateMaybeMessage< ::bwapi::event::UnitRenegade >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.unitRenegade)
  return event_.unitrenegade_;
}

// .bwapi.event.SaveGame saveGame = 17;
inline bool Event::has_savegame() const {
  return event_case() == kSaveGame;
}
inline void Event::set_has_savegame() {
  _oneof_case_[0] = kSaveGame;
}
inline void Event::clear_savegame() {
  if (has_savegame()) {
    delete event_.savegame_;
    clear_has_event();
  }
}
inline const ::bwapi::event::SaveGame& Event::_internal_savegame() const {
  return *event_.savegame_;
}
inline ::bwapi::event::SaveGame* Event::release_savegame() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.saveGame)
  if (has_savegame()) {
    clear_has_event();
      ::bwapi::event::SaveGame* temp = event_.savegame_;
    event_.savegame_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::SaveGame& Event::savegame() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.saveGame)
  return has_savegame()
      ? *event_.savegame_
      : *reinterpret_cast< ::bwapi::event::SaveGame*>(&::bwapi::event::_SaveGame_default_instance_);
}
inline ::bwapi::event::SaveGame* Event::mutable_savegame() {
  if (!has_savegame()) {
    clear_event();
    set_has_savegame();
    event_.savegame_ = CreateMaybeMessage< ::bwapi::event::SaveGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.saveGame)
  return event_.savegame_;
}

// .bwapi.event.UnitComplete unitComplete = 18;
inline bool Event::has_unitcomplete() const {
  return event_case() == kUnitComplete;
}
inline void Event::set_has_unitcomplete() {
  _oneof_case_[0] = kUnitComplete;
}
inline void Event::clear_unitcomplete() {
  if (has_unitcomplete()) {
    delete event_.unitcomplete_;
    clear_has_event();
  }
}
inline const ::bwapi::event::UnitComplete& Event::_internal_unitcomplete() const {
  return *event_.unitcomplete_;
}
inline ::bwapi::event::UnitComplete* Event::release_unitcomplete() {
  // @@protoc_insertion_point(field_release:bwapi.event.Event.unitComplete)
  if (has_unitcomplete()) {
    clear_has_event();
      ::bwapi::event::UnitComplete* temp = event_.unitcomplete_;
    event_.unitcomplete_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::bwapi::event::UnitComplete& Event::unitcomplete() const {
  // @@protoc_insertion_point(field_get:bwapi.event.Event.unitComplete)
  return has_unitcomplete()
      ? *event_.unitcomplete_
      : *reinterpret_cast< ::bwapi::event::UnitComplete*>(&::bwapi::event::_UnitComplete_default_instance_);
}
inline ::bwapi::event::UnitComplete* Event::mutable_unitcomplete() {
  if (!has_unitcomplete()) {
    clear_event();
    set_has_unitcomplete();
    event_.unitcomplete_ = CreateMaybeMessage< ::bwapi::event::UnitComplete >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bwapi.event.Event.unitComplete)
  return event_.unitcomplete_;
}

inline bool Event::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void Event::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline Event::EventCase Event::event_case() const {
  return Event::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace event
}  // namespace bwapi

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_event_2eproto
