// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data.proto

#ifndef PROTOBUF_INCLUDED_data_2eproto
#define PROTOBUF_INCLUDED_data_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_data_2eproto 

namespace protobuf_data_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_data_2eproto
namespace SCRAPIProtocol {
class AbilityData;
class AbilityDataDefaultTypeInternal;
extern AbilityDataDefaultTypeInternal _AbilityData_default_instance_;
class BuffData;
class BuffDataDefaultTypeInternal;
extern BuffDataDefaultTypeInternal _BuffData_default_instance_;
class DamageBonus;
class DamageBonusDefaultTypeInternal;
extern DamageBonusDefaultTypeInternal _DamageBonus_default_instance_;
class EffectData;
class EffectDataDefaultTypeInternal;
extern EffectDataDefaultTypeInternal _EffectData_default_instance_;
class UnitTypeData;
class UnitTypeDataDefaultTypeInternal;
extern UnitTypeDataDefaultTypeInternal _UnitTypeData_default_instance_;
class UpgradeData;
class UpgradeDataDefaultTypeInternal;
extern UpgradeDataDefaultTypeInternal _UpgradeData_default_instance_;
class Weapon;
class WeaponDefaultTypeInternal;
extern WeaponDefaultTypeInternal _Weapon_default_instance_;
}  // namespace SCRAPIProtocol
namespace google {
namespace protobuf {
template<> ::SCRAPIProtocol::AbilityData* Arena::CreateMaybeMessage<::SCRAPIProtocol::AbilityData>(Arena*);
template<> ::SCRAPIProtocol::BuffData* Arena::CreateMaybeMessage<::SCRAPIProtocol::BuffData>(Arena*);
template<> ::SCRAPIProtocol::DamageBonus* Arena::CreateMaybeMessage<::SCRAPIProtocol::DamageBonus>(Arena*);
template<> ::SCRAPIProtocol::EffectData* Arena::CreateMaybeMessage<::SCRAPIProtocol::EffectData>(Arena*);
template<> ::SCRAPIProtocol::UnitTypeData* Arena::CreateMaybeMessage<::SCRAPIProtocol::UnitTypeData>(Arena*);
template<> ::SCRAPIProtocol::UpgradeData* Arena::CreateMaybeMessage<::SCRAPIProtocol::UpgradeData>(Arena*);
template<> ::SCRAPIProtocol::Weapon* Arena::CreateMaybeMessage<::SCRAPIProtocol::Weapon>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace SCRAPIProtocol {

enum AbilityData_Target {
  AbilityData_Target_None = 1,
  AbilityData_Target_Point = 2,
  AbilityData_Target_Unit = 3,
  AbilityData_Target_PointOrUnit = 4,
  AbilityData_Target_PointOrNone = 5
};
bool AbilityData_Target_IsValid(int value);
const AbilityData_Target AbilityData_Target_Target_MIN = AbilityData_Target_None;
const AbilityData_Target AbilityData_Target_Target_MAX = AbilityData_Target_PointOrNone;
const int AbilityData_Target_Target_ARRAYSIZE = AbilityData_Target_Target_MAX + 1;

const ::google::protobuf::EnumDescriptor* AbilityData_Target_descriptor();
inline const ::std::string& AbilityData_Target_Name(AbilityData_Target value) {
  return ::google::protobuf::internal::NameOfEnum(
    AbilityData_Target_descriptor(), value);
}
inline bool AbilityData_Target_Parse(
    const ::std::string& name, AbilityData_Target* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AbilityData_Target>(
    AbilityData_Target_descriptor(), name, value);
}
enum Weapon_TargetType {
  Weapon_TargetType_Ground = 1,
  Weapon_TargetType_Air = 2,
  Weapon_TargetType_Any = 3
};
bool Weapon_TargetType_IsValid(int value);
const Weapon_TargetType Weapon_TargetType_TargetType_MIN = Weapon_TargetType_Ground;
const Weapon_TargetType Weapon_TargetType_TargetType_MAX = Weapon_TargetType_Any;
const int Weapon_TargetType_TargetType_ARRAYSIZE = Weapon_TargetType_TargetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Weapon_TargetType_descriptor();
inline const ::std::string& Weapon_TargetType_Name(Weapon_TargetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Weapon_TargetType_descriptor(), value);
}
inline bool Weapon_TargetType_Parse(
    const ::std::string& name, Weapon_TargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Weapon_TargetType>(
    Weapon_TargetType_descriptor(), name, value);
}
enum Attribute {
  Light = 1,
  Armored = 2,
  Biological = 3,
  Mechanical = 4,
  Robotic = 5,
  Psionic = 6,
  Massive = 7,
  Structure = 8,
  Hover = 9,
  Heroic = 10,
  Summoned = 11
};
bool Attribute_IsValid(int value);
const Attribute Attribute_MIN = Light;
const Attribute Attribute_MAX = Summoned;
const int Attribute_ARRAYSIZE = Attribute_MAX + 1;

const ::google::protobuf::EnumDescriptor* Attribute_descriptor();
inline const ::std::string& Attribute_Name(Attribute value) {
  return ::google::protobuf::internal::NameOfEnum(
    Attribute_descriptor(), value);
}
inline bool Attribute_Parse(
    const ::std::string& name, Attribute* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Attribute>(
    Attribute_descriptor(), name, value);
}
// ===================================================================

class AbilityData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.AbilityData) */ {
 public:
  AbilityData();
  virtual ~AbilityData();

  AbilityData(const AbilityData& from);

  inline AbilityData& operator=(const AbilityData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AbilityData(AbilityData&& from) noexcept
    : AbilityData() {
    *this = ::std::move(from);
  }

  inline AbilityData& operator=(AbilityData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AbilityData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AbilityData* internal_default_instance() {
    return reinterpret_cast<const AbilityData*>(
               &_AbilityData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AbilityData* other);
  friend void swap(AbilityData& a, AbilityData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AbilityData* New() const final {
    return CreateMaybeMessage<AbilityData>(NULL);
  }

  AbilityData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AbilityData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AbilityData& from);
  void MergeFrom(const AbilityData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbilityData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AbilityData_Target Target;
  static const Target None =
    AbilityData_Target_None;
  static const Target Point =
    AbilityData_Target_Point;
  static const Target Unit =
    AbilityData_Target_Unit;
  static const Target PointOrUnit =
    AbilityData_Target_PointOrUnit;
  static const Target PointOrNone =
    AbilityData_Target_PointOrNone;
  static inline bool Target_IsValid(int value) {
    return AbilityData_Target_IsValid(value);
  }
  static const Target Target_MIN =
    AbilityData_Target_Target_MIN;
  static const Target Target_MAX =
    AbilityData_Target_Target_MAX;
  static const int Target_ARRAYSIZE =
    AbilityData_Target_Target_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Target_descriptor() {
    return AbilityData_Target_descriptor();
  }
  static inline const ::std::string& Target_Name(Target value) {
    return AbilityData_Target_Name(value);
  }
  static inline bool Target_Parse(const ::std::string& name,
      Target* value) {
    return AbilityData_Target_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  #if LANG_CXX11
  void set_link_name(::std::string&& value);
  #endif
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // optional string button_name = 4;
  bool has_button_name() const;
  void clear_button_name();
  static const int kButtonNameFieldNumber = 4;
  const ::std::string& button_name() const;
  void set_button_name(const ::std::string& value);
  #if LANG_CXX11
  void set_button_name(::std::string&& value);
  #endif
  void set_button_name(const char* value);
  void set_button_name(const char* value, size_t size);
  ::std::string* mutable_button_name();
  ::std::string* release_button_name();
  void set_allocated_button_name(::std::string* button_name);

  // optional string friendly_name = 5;
  bool has_friendly_name() const;
  void clear_friendly_name();
  static const int kFriendlyNameFieldNumber = 5;
  const ::std::string& friendly_name() const;
  void set_friendly_name(const ::std::string& value);
  #if LANG_CXX11
  void set_friendly_name(::std::string&& value);
  #endif
  void set_friendly_name(const char* value);
  void set_friendly_name(const char* value, size_t size);
  ::std::string* mutable_friendly_name();
  ::std::string* release_friendly_name();
  void set_allocated_friendly_name(::std::string* friendly_name);

  // optional string hotkey = 6;
  bool has_hotkey() const;
  void clear_hotkey();
  static const int kHotkeyFieldNumber = 6;
  const ::std::string& hotkey() const;
  void set_hotkey(const ::std::string& value);
  #if LANG_CXX11
  void set_hotkey(::std::string&& value);
  #endif
  void set_hotkey(const char* value);
  void set_hotkey(const char* value, size_t size);
  ::std::string* mutable_hotkey();
  ::std::string* release_hotkey();
  void set_allocated_hotkey(::std::string* hotkey);

  // optional uint32 ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  ::google::protobuf::uint32 ability_id() const;
  void set_ability_id(::google::protobuf::uint32 value);

  // optional uint32 link_index = 3;
  bool has_link_index() const;
  void clear_link_index();
  static const int kLinkIndexFieldNumber = 3;
  ::google::protobuf::uint32 link_index() const;
  void set_link_index(::google::protobuf::uint32 value);

  // optional uint32 remaps_to_ability_id = 7;
  bool has_remaps_to_ability_id() const;
  void clear_remaps_to_ability_id();
  static const int kRemapsToAbilityIdFieldNumber = 7;
  ::google::protobuf::uint32 remaps_to_ability_id() const;
  void set_remaps_to_ability_id(::google::protobuf::uint32 value);

  // optional bool available = 8;
  bool has_available() const;
  void clear_available();
  static const int kAvailableFieldNumber = 8;
  bool available() const;
  void set_available(bool value);

  // optional bool allow_minimap = 10;
  bool has_allow_minimap() const;
  void clear_allow_minimap();
  static const int kAllowMinimapFieldNumber = 10;
  bool allow_minimap() const;
  void set_allow_minimap(bool value);

  // optional bool allow_autocast = 11;
  bool has_allow_autocast() const;
  void clear_allow_autocast();
  static const int kAllowAutocastFieldNumber = 11;
  bool allow_autocast() const;
  void set_allow_autocast(bool value);

  // optional bool is_building = 12;
  bool has_is_building() const;
  void clear_is_building();
  static const int kIsBuildingFieldNumber = 12;
  bool is_building() const;
  void set_is_building(bool value);

  // optional float footprint_radius = 13;
  bool has_footprint_radius() const;
  void clear_footprint_radius();
  static const int kFootprintRadiusFieldNumber = 13;
  float footprint_radius() const;
  void set_footprint_radius(float value);

  // optional bool is_instant_placement = 14;
  bool has_is_instant_placement() const;
  void clear_is_instant_placement();
  static const int kIsInstantPlacementFieldNumber = 14;
  bool is_instant_placement() const;
  void set_is_instant_placement(bool value);

  // optional float cast_range = 15;
  bool has_cast_range() const;
  void clear_cast_range();
  static const int kCastRangeFieldNumber = 15;
  float cast_range() const;
  void set_cast_range(float value);

  // optional .SCRAPIProtocol.AbilityData.Target target = 9;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 9;
  ::SCRAPIProtocol::AbilityData_Target target() const;
  void set_target(::SCRAPIProtocol::AbilityData_Target value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.AbilityData)
 private:
  void set_has_ability_id();
  void clear_has_ability_id();
  void set_has_link_name();
  void clear_has_link_name();
  void set_has_link_index();
  void clear_has_link_index();
  void set_has_button_name();
  void clear_has_button_name();
  void set_has_friendly_name();
  void clear_has_friendly_name();
  void set_has_hotkey();
  void clear_has_hotkey();
  void set_has_remaps_to_ability_id();
  void clear_has_remaps_to_ability_id();
  void set_has_available();
  void clear_has_available();
  void set_has_target();
  void clear_has_target();
  void set_has_allow_minimap();
  void clear_has_allow_minimap();
  void set_has_allow_autocast();
  void clear_has_allow_autocast();
  void set_has_is_building();
  void clear_has_is_building();
  void set_has_footprint_radius();
  void clear_has_footprint_radius();
  void set_has_is_instant_placement();
  void clear_has_is_instant_placement();
  void set_has_cast_range();
  void clear_has_cast_range();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::google::protobuf::internal::ArenaStringPtr button_name_;
  ::google::protobuf::internal::ArenaStringPtr friendly_name_;
  ::google::protobuf::internal::ArenaStringPtr hotkey_;
  ::google::protobuf::uint32 ability_id_;
  ::google::protobuf::uint32 link_index_;
  ::google::protobuf::uint32 remaps_to_ability_id_;
  bool available_;
  bool allow_minimap_;
  bool allow_autocast_;
  bool is_building_;
  float footprint_radius_;
  bool is_instant_placement_;
  float cast_range_;
  int target_;
  friend struct ::protobuf_data_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DamageBonus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DamageBonus) */ {
 public:
  DamageBonus();
  virtual ~DamageBonus();

  DamageBonus(const DamageBonus& from);

  inline DamageBonus& operator=(const DamageBonus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DamageBonus(DamageBonus&& from) noexcept
    : DamageBonus() {
    *this = ::std::move(from);
  }

  inline DamageBonus& operator=(DamageBonus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DamageBonus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DamageBonus* internal_default_instance() {
    return reinterpret_cast<const DamageBonus*>(
               &_DamageBonus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DamageBonus* other);
  friend void swap(DamageBonus& a, DamageBonus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DamageBonus* New() const final {
    return CreateMaybeMessage<DamageBonus>(NULL);
  }

  DamageBonus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DamageBonus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DamageBonus& from);
  void MergeFrom(const DamageBonus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DamageBonus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float bonus = 2;
  bool has_bonus() const;
  void clear_bonus();
  static const int kBonusFieldNumber = 2;
  float bonus() const;
  void set_bonus(float value);

  // optional .SCRAPIProtocol.Attribute attribute = 1;
  bool has_attribute() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 1;
  ::SCRAPIProtocol::Attribute attribute() const;
  void set_attribute(::SCRAPIProtocol::Attribute value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DamageBonus)
 private:
  void set_has_attribute();
  void clear_has_attribute();
  void set_has_bonus();
  void clear_has_bonus();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float bonus_;
  int attribute_;
  friend struct ::protobuf_data_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Weapon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.Weapon) */ {
 public:
  Weapon();
  virtual ~Weapon();

  Weapon(const Weapon& from);

  inline Weapon& operator=(const Weapon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Weapon(Weapon&& from) noexcept
    : Weapon() {
    *this = ::std::move(from);
  }

  inline Weapon& operator=(Weapon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Weapon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Weapon* internal_default_instance() {
    return reinterpret_cast<const Weapon*>(
               &_Weapon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Weapon* other);
  friend void swap(Weapon& a, Weapon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Weapon* New() const final {
    return CreateMaybeMessage<Weapon>(NULL);
  }

  Weapon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Weapon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Weapon& from);
  void MergeFrom(const Weapon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Weapon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Weapon_TargetType TargetType;
  static const TargetType Ground =
    Weapon_TargetType_Ground;
  static const TargetType Air =
    Weapon_TargetType_Air;
  static const TargetType Any =
    Weapon_TargetType_Any;
  static inline bool TargetType_IsValid(int value) {
    return Weapon_TargetType_IsValid(value);
  }
  static const TargetType TargetType_MIN =
    Weapon_TargetType_TargetType_MIN;
  static const TargetType TargetType_MAX =
    Weapon_TargetType_TargetType_MAX;
  static const int TargetType_ARRAYSIZE =
    Weapon_TargetType_TargetType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TargetType_descriptor() {
    return Weapon_TargetType_descriptor();
  }
  static inline const ::std::string& TargetType_Name(TargetType value) {
    return Weapon_TargetType_Name(value);
  }
  static inline bool TargetType_Parse(const ::std::string& name,
      TargetType* value) {
    return Weapon_TargetType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.DamageBonus damage_bonus = 3;
  int damage_bonus_size() const;
  void clear_damage_bonus();
  static const int kDamageBonusFieldNumber = 3;
  ::SCRAPIProtocol::DamageBonus* mutable_damage_bonus(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DamageBonus >*
      mutable_damage_bonus();
  const ::SCRAPIProtocol::DamageBonus& damage_bonus(int index) const;
  ::SCRAPIProtocol::DamageBonus* add_damage_bonus();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DamageBonus >&
      damage_bonus() const;

  // optional float damage = 2;
  bool has_damage() const;
  void clear_damage();
  static const int kDamageFieldNumber = 2;
  float damage() const;
  void set_damage(float value);

  // optional uint32 attacks = 4;
  bool has_attacks() const;
  void clear_attacks();
  static const int kAttacksFieldNumber = 4;
  ::google::protobuf::uint32 attacks() const;
  void set_attacks(::google::protobuf::uint32 value);

  // optional float range = 5;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 5;
  float range() const;
  void set_range(float value);

  // optional float speed = 6;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 6;
  float speed() const;
  void set_speed(float value);

  // optional .SCRAPIProtocol.Weapon.TargetType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::SCRAPIProtocol::Weapon_TargetType type() const;
  void set_type(::SCRAPIProtocol::Weapon_TargetType value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.Weapon)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_damage();
  void clear_has_damage();
  void set_has_attacks();
  void clear_has_attacks();
  void set_has_range();
  void clear_has_range();
  void set_has_speed();
  void clear_has_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DamageBonus > damage_bonus_;
  float damage_;
  ::google::protobuf::uint32 attacks_;
  float range_;
  float speed_;
  int type_;
  friend struct ::protobuf_data_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitTypeData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.UnitTypeData) */ {
 public:
  UnitTypeData();
  virtual ~UnitTypeData();

  UnitTypeData(const UnitTypeData& from);

  inline UnitTypeData& operator=(const UnitTypeData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitTypeData(UnitTypeData&& from) noexcept
    : UnitTypeData() {
    *this = ::std::move(from);
  }

  inline UnitTypeData& operator=(UnitTypeData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitTypeData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitTypeData* internal_default_instance() {
    return reinterpret_cast<const UnitTypeData*>(
               &_UnitTypeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(UnitTypeData* other);
  friend void swap(UnitTypeData& a, UnitTypeData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitTypeData* New() const final {
    return CreateMaybeMessage<UnitTypeData>(NULL);
  }

  UnitTypeData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitTypeData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitTypeData& from);
  void MergeFrom(const UnitTypeData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitTypeData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.Attribute attributes = 8;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 8;
  ::SCRAPIProtocol::Attribute attributes(int index) const;
  void set_attributes(int index, ::SCRAPIProtocol::Attribute value);
  void add_attributes(::SCRAPIProtocol::Attribute value);
  const ::google::protobuf::RepeatedField<int>& attributes() const;
  ::google::protobuf::RepeatedField<int>* mutable_attributes();

  // repeated .SCRAPIProtocol.Weapon weapons = 11;
  int weapons_size() const;
  void clear_weapons();
  static const int kWeaponsFieldNumber = 11;
  ::SCRAPIProtocol::Weapon* mutable_weapons(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Weapon >*
      mutable_weapons();
  const ::SCRAPIProtocol::Weapon& weapons(int index) const;
  ::SCRAPIProtocol::Weapon* add_weapons();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Weapon >&
      weapons() const;

  // repeated uint32 tech_alias = 21;
  int tech_alias_size() const;
  void clear_tech_alias();
  static const int kTechAliasFieldNumber = 21;
  ::google::protobuf::uint32 tech_alias(int index) const;
  void set_tech_alias(int index, ::google::protobuf::uint32 value);
  void add_tech_alias(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tech_alias() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tech_alias();

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 unit_id = 1;
  bool has_unit_id() const;
  void clear_unit_id();
  static const int kUnitIdFieldNumber = 1;
  ::google::protobuf::uint32 unit_id() const;
  void set_unit_id(::google::protobuf::uint32 value);

  // optional uint32 cargo_size = 4;
  bool has_cargo_size() const;
  void clear_cargo_size();
  static const int kCargoSizeFieldNumber = 4;
  ::google::protobuf::uint32 cargo_size() const;
  void set_cargo_size(::google::protobuf::uint32 value);

  // optional float movement_speed = 9;
  bool has_movement_speed() const;
  void clear_movement_speed();
  static const int kMovementSpeedFieldNumber = 9;
  float movement_speed() const;
  void set_movement_speed(float value);

  // optional float armor = 10;
  bool has_armor() const;
  void clear_armor();
  static const int kArmorFieldNumber = 10;
  float armor() const;
  void set_armor(float value);

  // optional uint32 mineral_cost = 12;
  bool has_mineral_cost() const;
  void clear_mineral_cost();
  static const int kMineralCostFieldNumber = 12;
  ::google::protobuf::uint32 mineral_cost() const;
  void set_mineral_cost(::google::protobuf::uint32 value);

  // optional uint32 vespene_cost = 13;
  bool has_vespene_cost() const;
  void clear_vespene_cost();
  static const int kVespeneCostFieldNumber = 13;
  ::google::protobuf::uint32 vespene_cost() const;
  void set_vespene_cost(::google::protobuf::uint32 value);

  // optional float food_required = 14;
  bool has_food_required() const;
  void clear_food_required();
  static const int kFoodRequiredFieldNumber = 14;
  float food_required() const;
  void set_food_required(float value);

  // optional uint32 ability_id = 15;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 15;
  ::google::protobuf::uint32 ability_id() const;
  void set_ability_id(::google::protobuf::uint32 value);

  // optional .SCRAPIProtocol.Race race = 16;
  bool has_race() const;
  void clear_race();
  static const int kRaceFieldNumber = 16;
  ::SCRAPIProtocol::Race race() const;
  void set_race(::SCRAPIProtocol::Race value);

  // optional bool available = 3;
  bool has_available() const;
  void clear_available();
  static const int kAvailableFieldNumber = 3;
  bool available() const;
  void set_available(bool value);

  // optional bool has_vespene = 19;
  bool has_has_vespene() const;
  void clear_has_vespene();
  static const int kHasVespeneFieldNumber = 19;
  bool has_vespene() const;
  void set_has_vespene(bool value);

  // optional bool has_minerals = 20;
  bool has_has_minerals() const;
  void clear_has_minerals();
  static const int kHasMineralsFieldNumber = 20;
  bool has_minerals() const;
  void set_has_minerals(bool value);

  // optional bool require_attached = 24;
  bool has_require_attached() const;
  void clear_require_attached();
  static const int kRequireAttachedFieldNumber = 24;
  bool require_attached() const;
  void set_require_attached(bool value);

  // optional float build_time = 17;
  bool has_build_time() const;
  void clear_build_time();
  static const int kBuildTimeFieldNumber = 17;
  float build_time() const;
  void set_build_time(float value);

  // optional float food_provided = 18;
  bool has_food_provided() const;
  void clear_food_provided();
  static const int kFoodProvidedFieldNumber = 18;
  float food_provided() const;
  void set_food_provided(float value);

  // optional uint32 unit_alias = 22;
  bool has_unit_alias() const;
  void clear_unit_alias();
  static const int kUnitAliasFieldNumber = 22;
  ::google::protobuf::uint32 unit_alias() const;
  void set_unit_alias(::google::protobuf::uint32 value);

  // optional uint32 tech_requirement = 23;
  bool has_tech_requirement() const;
  void clear_tech_requirement();
  static const int kTechRequirementFieldNumber = 23;
  ::google::protobuf::uint32 tech_requirement() const;
  void set_tech_requirement(::google::protobuf::uint32 value);

  // optional float sight_range = 25;
  bool has_sight_range() const;
  void clear_sight_range();
  static const int kSightRangeFieldNumber = 25;
  float sight_range() const;
  void set_sight_range(float value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.UnitTypeData)
 private:
  void set_has_unit_id();
  void clear_has_unit_id();
  void set_has_name();
  void clear_has_name();
  void set_has_available();
  void clear_has_available();
  void set_has_cargo_size();
  void clear_has_cargo_size();
  void set_has_mineral_cost();
  void clear_has_mineral_cost();
  void set_has_vespene_cost();
  void clear_has_vespene_cost();
  void set_has_food_required();
  void clear_has_food_required();
  void set_has_food_provided();
  void clear_has_food_provided();
  void set_has_ability_id();
  void clear_has_ability_id();
  void set_has_race();
  void clear_has_race();
  void set_has_build_time();
  void clear_has_build_time();
  void set_has_has_vespene();
  void clear_has_has_vespene();
  void set_has_has_minerals();
  void clear_has_has_minerals();
  void set_has_sight_range();
  void clear_has_sight_range();
  void set_has_unit_alias();
  void clear_has_unit_alias();
  void set_has_tech_requirement();
  void clear_has_tech_requirement();
  void set_has_require_attached();
  void clear_has_require_attached();
  void set_has_movement_speed();
  void clear_has_movement_speed();
  void set_has_armor();
  void clear_has_armor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> attributes_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Weapon > weapons_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tech_alias_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 unit_id_;
  ::google::protobuf::uint32 cargo_size_;
  float movement_speed_;
  float armor_;
  ::google::protobuf::uint32 mineral_cost_;
  ::google::protobuf::uint32 vespene_cost_;
  float food_required_;
  ::google::protobuf::uint32 ability_id_;
  int race_;
  bool available_;
  bool has_vespene_;
  bool has_minerals_;
  bool require_attached_;
  float build_time_;
  float food_provided_;
  ::google::protobuf::uint32 unit_alias_;
  ::google::protobuf::uint32 tech_requirement_;
  float sight_range_;
  friend struct ::protobuf_data_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpgradeData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.UpgradeData) */ {
 public:
  UpgradeData();
  virtual ~UpgradeData();

  UpgradeData(const UpgradeData& from);

  inline UpgradeData& operator=(const UpgradeData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpgradeData(UpgradeData&& from) noexcept
    : UpgradeData() {
    *this = ::std::move(from);
  }

  inline UpgradeData& operator=(UpgradeData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpgradeData* internal_default_instance() {
    return reinterpret_cast<const UpgradeData*>(
               &_UpgradeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UpgradeData* other);
  friend void swap(UpgradeData& a, UpgradeData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpgradeData* New() const final {
    return CreateMaybeMessage<UpgradeData>(NULL);
  }

  UpgradeData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpgradeData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpgradeData& from);
  void MergeFrom(const UpgradeData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpgradeData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 upgrade_id = 1;
  bool has_upgrade_id() const;
  void clear_upgrade_id();
  static const int kUpgradeIdFieldNumber = 1;
  ::google::protobuf::uint32 upgrade_id() const;
  void set_upgrade_id(::google::protobuf::uint32 value);

  // optional uint32 mineral_cost = 3;
  bool has_mineral_cost() const;
  void clear_mineral_cost();
  static const int kMineralCostFieldNumber = 3;
  ::google::protobuf::uint32 mineral_cost() const;
  void set_mineral_cost(::google::protobuf::uint32 value);

  // optional uint32 vespene_cost = 4;
  bool has_vespene_cost() const;
  void clear_vespene_cost();
  static const int kVespeneCostFieldNumber = 4;
  ::google::protobuf::uint32 vespene_cost() const;
  void set_vespene_cost(::google::protobuf::uint32 value);

  // optional float research_time = 5;
  bool has_research_time() const;
  void clear_research_time();
  static const int kResearchTimeFieldNumber = 5;
  float research_time() const;
  void set_research_time(float value);

  // optional uint32 ability_id = 6;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 6;
  ::google::protobuf::uint32 ability_id() const;
  void set_ability_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.UpgradeData)
 private:
  void set_has_upgrade_id();
  void clear_has_upgrade_id();
  void set_has_name();
  void clear_has_name();
  void set_has_mineral_cost();
  void clear_has_mineral_cost();
  void set_has_vespene_cost();
  void clear_has_vespene_cost();
  void set_has_research_time();
  void clear_has_research_time();
  void set_has_ability_id();
  void clear_has_ability_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 upgrade_id_;
  ::google::protobuf::uint32 mineral_cost_;
  ::google::protobuf::uint32 vespene_cost_;
  float research_time_;
  ::google::protobuf::uint32 ability_id_;
  friend struct ::protobuf_data_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BuffData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.BuffData) */ {
 public:
  BuffData();
  virtual ~BuffData();

  BuffData(const BuffData& from);

  inline BuffData& operator=(const BuffData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuffData(BuffData&& from) noexcept
    : BuffData() {
    *this = ::std::move(from);
  }

  inline BuffData& operator=(BuffData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuffData* internal_default_instance() {
    return reinterpret_cast<const BuffData*>(
               &_BuffData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BuffData* other);
  friend void swap(BuffData& a, BuffData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuffData* New() const final {
    return CreateMaybeMessage<BuffData>(NULL);
  }

  BuffData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuffData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuffData& from);
  void MergeFrom(const BuffData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuffData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 buff_id = 1;
  bool has_buff_id() const;
  void clear_buff_id();
  static const int kBuffIdFieldNumber = 1;
  ::google::protobuf::uint32 buff_id() const;
  void set_buff_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.BuffData)
 private:
  void set_has_buff_id();
  void clear_has_buff_id();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 buff_id_;
  friend struct ::protobuf_data_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EffectData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.EffectData) */ {
 public:
  EffectData();
  virtual ~EffectData();

  EffectData(const EffectData& from);

  inline EffectData& operator=(const EffectData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EffectData(EffectData&& from) noexcept
    : EffectData() {
    *this = ::std::move(from);
  }

  inline EffectData& operator=(EffectData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EffectData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EffectData* internal_default_instance() {
    return reinterpret_cast<const EffectData*>(
               &_EffectData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(EffectData* other);
  friend void swap(EffectData& a, EffectData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EffectData* New() const final {
    return CreateMaybeMessage<EffectData>(NULL);
  }

  EffectData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EffectData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EffectData& from);
  void MergeFrom(const EffectData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EffectData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string friendly_name = 3;
  bool has_friendly_name() const;
  void clear_friendly_name();
  static const int kFriendlyNameFieldNumber = 3;
  const ::std::string& friendly_name() const;
  void set_friendly_name(const ::std::string& value);
  #if LANG_CXX11
  void set_friendly_name(::std::string&& value);
  #endif
  void set_friendly_name(const char* value);
  void set_friendly_name(const char* value, size_t size);
  ::std::string* mutable_friendly_name();
  ::std::string* release_friendly_name();
  void set_allocated_friendly_name(::std::string* friendly_name);

  // optional uint32 effect_id = 1;
  bool has_effect_id() const;
  void clear_effect_id();
  static const int kEffectIdFieldNumber = 1;
  ::google::protobuf::uint32 effect_id() const;
  void set_effect_id(::google::protobuf::uint32 value);

  // optional float radius = 4;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 4;
  float radius() const;
  void set_radius(float value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.EffectData)
 private:
  void set_has_effect_id();
  void clear_has_effect_id();
  void set_has_name();
  void clear_has_name();
  void set_has_friendly_name();
  void clear_has_friendly_name();
  void set_has_radius();
  void clear_has_radius();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr friendly_name_;
  ::google::protobuf::uint32 effect_id_;
  float radius_;
  friend struct ::protobuf_data_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AbilityData

// optional uint32 ability_id = 1;
inline bool AbilityData::has_ability_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AbilityData::set_has_ability_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AbilityData::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AbilityData::clear_ability_id() {
  ability_id_ = 0u;
  clear_has_ability_id();
}
inline ::google::protobuf::uint32 AbilityData::ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.ability_id)
  return ability_id_;
}
inline void AbilityData::set_ability_id(::google::protobuf::uint32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.ability_id)
}

// optional string link_name = 2;
inline bool AbilityData::has_link_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AbilityData::set_has_link_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AbilityData::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AbilityData::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& AbilityData::link_name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.link_name)
  return link_name_.GetNoArena();
}
inline void AbilityData::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.link_name)
}
#if LANG_CXX11
inline void AbilityData::set_link_name(::std::string&& value) {
  set_has_link_name();
  link_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.AbilityData.link_name)
}
#endif
inline void AbilityData::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.AbilityData.link_name)
}
inline void AbilityData::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.AbilityData.link_name)
}
inline ::std::string* AbilityData::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.AbilityData.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AbilityData::release_link_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.AbilityData.link_name)
  if (!has_link_name()) {
    return NULL;
  }
  clear_has_link_name();
  return link_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AbilityData::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.AbilityData.link_name)
}

// optional uint32 link_index = 3;
inline bool AbilityData::has_link_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AbilityData::set_has_link_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AbilityData::clear_has_link_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AbilityData::clear_link_index() {
  link_index_ = 0u;
  clear_has_link_index();
}
inline ::google::protobuf::uint32 AbilityData::link_index() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.link_index)
  return link_index_;
}
inline void AbilityData::set_link_index(::google::protobuf::uint32 value) {
  set_has_link_index();
  link_index_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.link_index)
}

// optional string button_name = 4;
inline bool AbilityData::has_button_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AbilityData::set_has_button_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AbilityData::clear_has_button_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AbilityData::clear_button_name() {
  button_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_button_name();
}
inline const ::std::string& AbilityData::button_name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.button_name)
  return button_name_.GetNoArena();
}
inline void AbilityData::set_button_name(const ::std::string& value) {
  set_has_button_name();
  button_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.button_name)
}
#if LANG_CXX11
inline void AbilityData::set_button_name(::std::string&& value) {
  set_has_button_name();
  button_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.AbilityData.button_name)
}
#endif
inline void AbilityData::set_button_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_button_name();
  button_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.AbilityData.button_name)
}
inline void AbilityData::set_button_name(const char* value, size_t size) {
  set_has_button_name();
  button_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.AbilityData.button_name)
}
inline ::std::string* AbilityData::mutable_button_name() {
  set_has_button_name();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.AbilityData.button_name)
  return button_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AbilityData::release_button_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.AbilityData.button_name)
  if (!has_button_name()) {
    return NULL;
  }
  clear_has_button_name();
  return button_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AbilityData::set_allocated_button_name(::std::string* button_name) {
  if (button_name != NULL) {
    set_has_button_name();
  } else {
    clear_has_button_name();
  }
  button_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), button_name);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.AbilityData.button_name)
}

// optional string friendly_name = 5;
inline bool AbilityData::has_friendly_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AbilityData::set_has_friendly_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AbilityData::clear_has_friendly_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AbilityData::clear_friendly_name() {
  friendly_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_friendly_name();
}
inline const ::std::string& AbilityData::friendly_name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.friendly_name)
  return friendly_name_.GetNoArena();
}
inline void AbilityData::set_friendly_name(const ::std::string& value) {
  set_has_friendly_name();
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.friendly_name)
}
#if LANG_CXX11
inline void AbilityData::set_friendly_name(::std::string&& value) {
  set_has_friendly_name();
  friendly_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.AbilityData.friendly_name)
}
#endif
inline void AbilityData::set_friendly_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_friendly_name();
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.AbilityData.friendly_name)
}
inline void AbilityData::set_friendly_name(const char* value, size_t size) {
  set_has_friendly_name();
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.AbilityData.friendly_name)
}
inline ::std::string* AbilityData::mutable_friendly_name() {
  set_has_friendly_name();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.AbilityData.friendly_name)
  return friendly_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AbilityData::release_friendly_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.AbilityData.friendly_name)
  if (!has_friendly_name()) {
    return NULL;
  }
  clear_has_friendly_name();
  return friendly_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AbilityData::set_allocated_friendly_name(::std::string* friendly_name) {
  if (friendly_name != NULL) {
    set_has_friendly_name();
  } else {
    clear_has_friendly_name();
  }
  friendly_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), friendly_name);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.AbilityData.friendly_name)
}

// optional string hotkey = 6;
inline bool AbilityData::has_hotkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AbilityData::set_has_hotkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AbilityData::clear_has_hotkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AbilityData::clear_hotkey() {
  hotkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hotkey();
}
inline const ::std::string& AbilityData::hotkey() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.hotkey)
  return hotkey_.GetNoArena();
}
inline void AbilityData::set_hotkey(const ::std::string& value) {
  set_has_hotkey();
  hotkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.hotkey)
}
#if LANG_CXX11
inline void AbilityData::set_hotkey(::std::string&& value) {
  set_has_hotkey();
  hotkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.AbilityData.hotkey)
}
#endif
inline void AbilityData::set_hotkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hotkey();
  hotkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.AbilityData.hotkey)
}
inline void AbilityData::set_hotkey(const char* value, size_t size) {
  set_has_hotkey();
  hotkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.AbilityData.hotkey)
}
inline ::std::string* AbilityData::mutable_hotkey() {
  set_has_hotkey();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.AbilityData.hotkey)
  return hotkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AbilityData::release_hotkey() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.AbilityData.hotkey)
  if (!has_hotkey()) {
    return NULL;
  }
  clear_has_hotkey();
  return hotkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AbilityData::set_allocated_hotkey(::std::string* hotkey) {
  if (hotkey != NULL) {
    set_has_hotkey();
  } else {
    clear_has_hotkey();
  }
  hotkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hotkey);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.AbilityData.hotkey)
}

// optional uint32 remaps_to_ability_id = 7;
inline bool AbilityData::has_remaps_to_ability_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AbilityData::set_has_remaps_to_ability_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AbilityData::clear_has_remaps_to_ability_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AbilityData::clear_remaps_to_ability_id() {
  remaps_to_ability_id_ = 0u;
  clear_has_remaps_to_ability_id();
}
inline ::google::protobuf::uint32 AbilityData::remaps_to_ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.remaps_to_ability_id)
  return remaps_to_ability_id_;
}
inline void AbilityData::set_remaps_to_ability_id(::google::protobuf::uint32 value) {
  set_has_remaps_to_ability_id();
  remaps_to_ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.remaps_to_ability_id)
}

// optional bool available = 8;
inline bool AbilityData::has_available() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AbilityData::set_has_available() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AbilityData::clear_has_available() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AbilityData::clear_available() {
  available_ = false;
  clear_has_available();
}
inline bool AbilityData::available() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.available)
  return available_;
}
inline void AbilityData::set_available(bool value) {
  set_has_available();
  available_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.available)
}

// optional .SCRAPIProtocol.AbilityData.Target target = 9;
inline bool AbilityData::has_target() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AbilityData::set_has_target() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AbilityData::clear_has_target() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AbilityData::clear_target() {
  target_ = 1;
  clear_has_target();
}
inline ::SCRAPIProtocol::AbilityData_Target AbilityData::target() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.target)
  return static_cast< ::SCRAPIProtocol::AbilityData_Target >(target_);
}
inline void AbilityData::set_target(::SCRAPIProtocol::AbilityData_Target value) {
  assert(::SCRAPIProtocol::AbilityData_Target_IsValid(value));
  set_has_target();
  target_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.target)
}

// optional bool allow_minimap = 10;
inline bool AbilityData::has_allow_minimap() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AbilityData::set_has_allow_minimap() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AbilityData::clear_has_allow_minimap() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AbilityData::clear_allow_minimap() {
  allow_minimap_ = false;
  clear_has_allow_minimap();
}
inline bool AbilityData::allow_minimap() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.allow_minimap)
  return allow_minimap_;
}
inline void AbilityData::set_allow_minimap(bool value) {
  set_has_allow_minimap();
  allow_minimap_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.allow_minimap)
}

// optional bool allow_autocast = 11;
inline bool AbilityData::has_allow_autocast() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AbilityData::set_has_allow_autocast() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AbilityData::clear_has_allow_autocast() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AbilityData::clear_allow_autocast() {
  allow_autocast_ = false;
  clear_has_allow_autocast();
}
inline bool AbilityData::allow_autocast() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.allow_autocast)
  return allow_autocast_;
}
inline void AbilityData::set_allow_autocast(bool value) {
  set_has_allow_autocast();
  allow_autocast_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.allow_autocast)
}

// optional bool is_building = 12;
inline bool AbilityData::has_is_building() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AbilityData::set_has_is_building() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AbilityData::clear_has_is_building() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AbilityData::clear_is_building() {
  is_building_ = false;
  clear_has_is_building();
}
inline bool AbilityData::is_building() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.is_building)
  return is_building_;
}
inline void AbilityData::set_is_building(bool value) {
  set_has_is_building();
  is_building_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.is_building)
}

// optional float footprint_radius = 13;
inline bool AbilityData::has_footprint_radius() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AbilityData::set_has_footprint_radius() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AbilityData::clear_has_footprint_radius() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AbilityData::clear_footprint_radius() {
  footprint_radius_ = 0;
  clear_has_footprint_radius();
}
inline float AbilityData::footprint_radius() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.footprint_radius)
  return footprint_radius_;
}
inline void AbilityData::set_footprint_radius(float value) {
  set_has_footprint_radius();
  footprint_radius_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.footprint_radius)
}

// optional bool is_instant_placement = 14;
inline bool AbilityData::has_is_instant_placement() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AbilityData::set_has_is_instant_placement() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AbilityData::clear_has_is_instant_placement() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AbilityData::clear_is_instant_placement() {
  is_instant_placement_ = false;
  clear_has_is_instant_placement();
}
inline bool AbilityData::is_instant_placement() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.is_instant_placement)
  return is_instant_placement_;
}
inline void AbilityData::set_is_instant_placement(bool value) {
  set_has_is_instant_placement();
  is_instant_placement_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.is_instant_placement)
}

// optional float cast_range = 15;
inline bool AbilityData::has_cast_range() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AbilityData::set_has_cast_range() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AbilityData::clear_has_cast_range() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AbilityData::clear_cast_range() {
  cast_range_ = 0;
  clear_has_cast_range();
}
inline float AbilityData::cast_range() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.AbilityData.cast_range)
  return cast_range_;
}
inline void AbilityData::set_cast_range(float value) {
  set_has_cast_range();
  cast_range_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.AbilityData.cast_range)
}

// -------------------------------------------------------------------

// DamageBonus

// optional .SCRAPIProtocol.Attribute attribute = 1;
inline bool DamageBonus::has_attribute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DamageBonus::set_has_attribute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DamageBonus::clear_has_attribute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DamageBonus::clear_attribute() {
  attribute_ = 1;
  clear_has_attribute();
}
inline ::SCRAPIProtocol::Attribute DamageBonus::attribute() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DamageBonus.attribute)
  return static_cast< ::SCRAPIProtocol::Attribute >(attribute_);
}
inline void DamageBonus::set_attribute(::SCRAPIProtocol::Attribute value) {
  assert(::SCRAPIProtocol::Attribute_IsValid(value));
  set_has_attribute();
  attribute_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DamageBonus.attribute)
}

// optional float bonus = 2;
inline bool DamageBonus::has_bonus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DamageBonus::set_has_bonus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DamageBonus::clear_has_bonus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DamageBonus::clear_bonus() {
  bonus_ = 0;
  clear_has_bonus();
}
inline float DamageBonus::bonus() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DamageBonus.bonus)
  return bonus_;
}
inline void DamageBonus::set_bonus(float value) {
  set_has_bonus();
  bonus_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DamageBonus.bonus)
}

// -------------------------------------------------------------------

// Weapon

// optional .SCRAPIProtocol.Weapon.TargetType type = 1;
inline bool Weapon::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Weapon::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Weapon::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Weapon::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SCRAPIProtocol::Weapon_TargetType Weapon::type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Weapon.type)
  return static_cast< ::SCRAPIProtocol::Weapon_TargetType >(type_);
}
inline void Weapon::set_type(::SCRAPIProtocol::Weapon_TargetType value) {
  assert(::SCRAPIProtocol::Weapon_TargetType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Weapon.type)
}

// optional float damage = 2;
inline bool Weapon::has_damage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Weapon::set_has_damage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Weapon::clear_has_damage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Weapon::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline float Weapon::damage() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Weapon.damage)
  return damage_;
}
inline void Weapon::set_damage(float value) {
  set_has_damage();
  damage_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Weapon.damage)
}

// repeated .SCRAPIProtocol.DamageBonus damage_bonus = 3;
inline int Weapon::damage_bonus_size() const {
  return damage_bonus_.size();
}
inline void Weapon::clear_damage_bonus() {
  damage_bonus_.Clear();
}
inline ::SCRAPIProtocol::DamageBonus* Weapon::mutable_damage_bonus(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Weapon.damage_bonus)
  return damage_bonus_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DamageBonus >*
Weapon::mutable_damage_bonus() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.Weapon.damage_bonus)
  return &damage_bonus_;
}
inline const ::SCRAPIProtocol::DamageBonus& Weapon::damage_bonus(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Weapon.damage_bonus)
  return damage_bonus_.Get(index);
}
inline ::SCRAPIProtocol::DamageBonus* Weapon::add_damage_bonus() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.Weapon.damage_bonus)
  return damage_bonus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DamageBonus >&
Weapon::damage_bonus() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.Weapon.damage_bonus)
  return damage_bonus_;
}

// optional uint32 attacks = 4;
inline bool Weapon::has_attacks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Weapon::set_has_attacks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Weapon::clear_has_attacks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Weapon::clear_attacks() {
  attacks_ = 0u;
  clear_has_attacks();
}
inline ::google::protobuf::uint32 Weapon::attacks() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Weapon.attacks)
  return attacks_;
}
inline void Weapon::set_attacks(::google::protobuf::uint32 value) {
  set_has_attacks();
  attacks_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Weapon.attacks)
}

// optional float range = 5;
inline bool Weapon::has_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Weapon::set_has_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Weapon::clear_has_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Weapon::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline float Weapon::range() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Weapon.range)
  return range_;
}
inline void Weapon::set_range(float value) {
  set_has_range();
  range_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Weapon.range)
}

// optional float speed = 6;
inline bool Weapon::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Weapon::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Weapon::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Weapon::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float Weapon::speed() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Weapon.speed)
  return speed_;
}
inline void Weapon::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Weapon.speed)
}

// -------------------------------------------------------------------

// UnitTypeData

// optional uint32 unit_id = 1;
inline bool UnitTypeData::has_unit_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnitTypeData::set_has_unit_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnitTypeData::clear_has_unit_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnitTypeData::clear_unit_id() {
  unit_id_ = 0u;
  clear_has_unit_id();
}
inline ::google::protobuf::uint32 UnitTypeData::unit_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.unit_id)
  return unit_id_;
}
inline void UnitTypeData::set_unit_id(::google::protobuf::uint32 value) {
  set_has_unit_id();
  unit_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.unit_id)
}

// optional string name = 2;
inline bool UnitTypeData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitTypeData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitTypeData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitTypeData::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& UnitTypeData::name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.name)
  return name_.GetNoArena();
}
inline void UnitTypeData::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.name)
}
#if LANG_CXX11
inline void UnitTypeData::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.UnitTypeData.name)
}
#endif
inline void UnitTypeData::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.UnitTypeData.name)
}
inline void UnitTypeData::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.UnitTypeData.name)
}
inline ::std::string* UnitTypeData::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.UnitTypeData.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnitTypeData::release_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.UnitTypeData.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnitTypeData::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.UnitTypeData.name)
}

// optional bool available = 3;
inline bool UnitTypeData::has_available() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UnitTypeData::set_has_available() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UnitTypeData::clear_has_available() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UnitTypeData::clear_available() {
  available_ = false;
  clear_has_available();
}
inline bool UnitTypeData::available() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.available)
  return available_;
}
inline void UnitTypeData::set_available(bool value) {
  set_has_available();
  available_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.available)
}

// optional uint32 cargo_size = 4;
inline bool UnitTypeData::has_cargo_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnitTypeData::set_has_cargo_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnitTypeData::clear_has_cargo_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnitTypeData::clear_cargo_size() {
  cargo_size_ = 0u;
  clear_has_cargo_size();
}
inline ::google::protobuf::uint32 UnitTypeData::cargo_size() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.cargo_size)
  return cargo_size_;
}
inline void UnitTypeData::set_cargo_size(::google::protobuf::uint32 value) {
  set_has_cargo_size();
  cargo_size_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.cargo_size)
}

// optional uint32 mineral_cost = 12;
inline bool UnitTypeData::has_mineral_cost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UnitTypeData::set_has_mineral_cost() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UnitTypeData::clear_has_mineral_cost() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UnitTypeData::clear_mineral_cost() {
  mineral_cost_ = 0u;
  clear_has_mineral_cost();
}
inline ::google::protobuf::uint32 UnitTypeData::mineral_cost() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.mineral_cost)
  return mineral_cost_;
}
inline void UnitTypeData::set_mineral_cost(::google::protobuf::uint32 value) {
  set_has_mineral_cost();
  mineral_cost_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.mineral_cost)
}

// optional uint32 vespene_cost = 13;
inline bool UnitTypeData::has_vespene_cost() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UnitTypeData::set_has_vespene_cost() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UnitTypeData::clear_has_vespene_cost() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UnitTypeData::clear_vespene_cost() {
  vespene_cost_ = 0u;
  clear_has_vespene_cost();
}
inline ::google::protobuf::uint32 UnitTypeData::vespene_cost() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.vespene_cost)
  return vespene_cost_;
}
inline void UnitTypeData::set_vespene_cost(::google::protobuf::uint32 value) {
  set_has_vespene_cost();
  vespene_cost_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.vespene_cost)
}

// optional float food_required = 14;
inline bool UnitTypeData::has_food_required() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UnitTypeData::set_has_food_required() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UnitTypeData::clear_has_food_required() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UnitTypeData::clear_food_required() {
  food_required_ = 0;
  clear_has_food_required();
}
inline float UnitTypeData::food_required() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.food_required)
  return food_required_;
}
inline void UnitTypeData::set_food_required(float value) {
  set_has_food_required();
  food_required_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.food_required)
}

// optional float food_provided = 18;
inline bool UnitTypeData::has_food_provided() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UnitTypeData::set_has_food_provided() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UnitTypeData::clear_has_food_provided() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UnitTypeData::clear_food_provided() {
  food_provided_ = 0;
  clear_has_food_provided();
}
inline float UnitTypeData::food_provided() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.food_provided)
  return food_provided_;
}
inline void UnitTypeData::set_food_provided(float value) {
  set_has_food_provided();
  food_provided_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.food_provided)
}

// optional uint32 ability_id = 15;
inline bool UnitTypeData::has_ability_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UnitTypeData::set_has_ability_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UnitTypeData::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UnitTypeData::clear_ability_id() {
  ability_id_ = 0u;
  clear_has_ability_id();
}
inline ::google::protobuf::uint32 UnitTypeData::ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.ability_id)
  return ability_id_;
}
inline void UnitTypeData::set_ability_id(::google::protobuf::uint32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.ability_id)
}

// optional .SCRAPIProtocol.Race race = 16;
inline bool UnitTypeData::has_race() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UnitTypeData::set_has_race() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UnitTypeData::clear_has_race() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UnitTypeData::clear_race() {
  race_ = 0;
  clear_has_race();
}
inline ::SCRAPIProtocol::Race UnitTypeData::race() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.race)
  return static_cast< ::SCRAPIProtocol::Race >(race_);
}
inline void UnitTypeData::set_race(::SCRAPIProtocol::Race value) {
  assert(::SCRAPIProtocol::Race_IsValid(value));
  set_has_race();
  race_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.race)
}

// optional float build_time = 17;
inline bool UnitTypeData::has_build_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UnitTypeData::set_has_build_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UnitTypeData::clear_has_build_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UnitTypeData::clear_build_time() {
  build_time_ = 0;
  clear_has_build_time();
}
inline float UnitTypeData::build_time() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.build_time)
  return build_time_;
}
inline void UnitTypeData::set_build_time(float value) {
  set_has_build_time();
  build_time_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.build_time)
}

// optional bool has_vespene = 19;
inline bool UnitTypeData::has_has_vespene() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UnitTypeData::set_has_has_vespene() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UnitTypeData::clear_has_has_vespene() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UnitTypeData::clear_has_vespene() {
  has_vespene_ = false;
  clear_has_has_vespene();
}
inline bool UnitTypeData::has_vespene() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.has_vespene)
  return has_vespene_;
}
inline void UnitTypeData::set_has_vespene(bool value) {
  set_has_has_vespene();
  has_vespene_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.has_vespene)
}

// optional bool has_minerals = 20;
inline bool UnitTypeData::has_has_minerals() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UnitTypeData::set_has_has_minerals() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UnitTypeData::clear_has_has_minerals() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UnitTypeData::clear_has_minerals() {
  has_minerals_ = false;
  clear_has_has_minerals();
}
inline bool UnitTypeData::has_minerals() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.has_minerals)
  return has_minerals_;
}
inline void UnitTypeData::set_has_minerals(bool value) {
  set_has_has_minerals();
  has_minerals_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.has_minerals)
}

// optional float sight_range = 25;
inline bool UnitTypeData::has_sight_range() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UnitTypeData::set_has_sight_range() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UnitTypeData::clear_has_sight_range() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UnitTypeData::clear_sight_range() {
  sight_range_ = 0;
  clear_has_sight_range();
}
inline float UnitTypeData::sight_range() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.sight_range)
  return sight_range_;
}
inline void UnitTypeData::set_sight_range(float value) {
  set_has_sight_range();
  sight_range_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.sight_range)
}

// repeated uint32 tech_alias = 21;
inline int UnitTypeData::tech_alias_size() const {
  return tech_alias_.size();
}
inline void UnitTypeData::clear_tech_alias() {
  tech_alias_.Clear();
}
inline ::google::protobuf::uint32 UnitTypeData::tech_alias(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.tech_alias)
  return tech_alias_.Get(index);
}
inline void UnitTypeData::set_tech_alias(int index, ::google::protobuf::uint32 value) {
  tech_alias_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.tech_alias)
}
inline void UnitTypeData::add_tech_alias(::google::protobuf::uint32 value) {
  tech_alias_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.UnitTypeData.tech_alias)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UnitTypeData::tech_alias() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.UnitTypeData.tech_alias)
  return tech_alias_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UnitTypeData::mutable_tech_alias() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.UnitTypeData.tech_alias)
  return &tech_alias_;
}

// optional uint32 unit_alias = 22;
inline bool UnitTypeData::has_unit_alias() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UnitTypeData::set_has_unit_alias() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UnitTypeData::clear_has_unit_alias() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UnitTypeData::clear_unit_alias() {
  unit_alias_ = 0u;
  clear_has_unit_alias();
}
inline ::google::protobuf::uint32 UnitTypeData::unit_alias() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.unit_alias)
  return unit_alias_;
}
inline void UnitTypeData::set_unit_alias(::google::protobuf::uint32 value) {
  set_has_unit_alias();
  unit_alias_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.unit_alias)
}

// optional uint32 tech_requirement = 23;
inline bool UnitTypeData::has_tech_requirement() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UnitTypeData::set_has_tech_requirement() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UnitTypeData::clear_has_tech_requirement() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UnitTypeData::clear_tech_requirement() {
  tech_requirement_ = 0u;
  clear_has_tech_requirement();
}
inline ::google::protobuf::uint32 UnitTypeData::tech_requirement() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.tech_requirement)
  return tech_requirement_;
}
inline void UnitTypeData::set_tech_requirement(::google::protobuf::uint32 value) {
  set_has_tech_requirement();
  tech_requirement_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.tech_requirement)
}

// optional bool require_attached = 24;
inline bool UnitTypeData::has_require_attached() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UnitTypeData::set_has_require_attached() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UnitTypeData::clear_has_require_attached() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UnitTypeData::clear_require_attached() {
  require_attached_ = false;
  clear_has_require_attached();
}
inline bool UnitTypeData::require_attached() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.require_attached)
  return require_attached_;
}
inline void UnitTypeData::set_require_attached(bool value) {
  set_has_require_attached();
  require_attached_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.require_attached)
}

// repeated .SCRAPIProtocol.Attribute attributes = 8;
inline int UnitTypeData::attributes_size() const {
  return attributes_.size();
}
inline void UnitTypeData::clear_attributes() {
  attributes_.Clear();
}
inline ::SCRAPIProtocol::Attribute UnitTypeData::attributes(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.attributes)
  return static_cast< ::SCRAPIProtocol::Attribute >(attributes_.Get(index));
}
inline void UnitTypeData::set_attributes(int index, ::SCRAPIProtocol::Attribute value) {
  assert(::SCRAPIProtocol::Attribute_IsValid(value));
  attributes_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.attributes)
}
inline void UnitTypeData::add_attributes(::SCRAPIProtocol::Attribute value) {
  assert(::SCRAPIProtocol::Attribute_IsValid(value));
  attributes_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.UnitTypeData.attributes)
}
inline const ::google::protobuf::RepeatedField<int>&
UnitTypeData::attributes() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.UnitTypeData.attributes)
  return attributes_;
}
inline ::google::protobuf::RepeatedField<int>*
UnitTypeData::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.UnitTypeData.attributes)
  return &attributes_;
}

// optional float movement_speed = 9;
inline bool UnitTypeData::has_movement_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnitTypeData::set_has_movement_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnitTypeData::clear_has_movement_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnitTypeData::clear_movement_speed() {
  movement_speed_ = 0;
  clear_has_movement_speed();
}
inline float UnitTypeData::movement_speed() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.movement_speed)
  return movement_speed_;
}
inline void UnitTypeData::set_movement_speed(float value) {
  set_has_movement_speed();
  movement_speed_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.movement_speed)
}

// optional float armor = 10;
inline bool UnitTypeData::has_armor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UnitTypeData::set_has_armor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UnitTypeData::clear_has_armor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UnitTypeData::clear_armor() {
  armor_ = 0;
  clear_has_armor();
}
inline float UnitTypeData::armor() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.armor)
  return armor_;
}
inline void UnitTypeData::set_armor(float value) {
  set_has_armor();
  armor_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitTypeData.armor)
}

// repeated .SCRAPIProtocol.Weapon weapons = 11;
inline int UnitTypeData::weapons_size() const {
  return weapons_.size();
}
inline void UnitTypeData::clear_weapons() {
  weapons_.Clear();
}
inline ::SCRAPIProtocol::Weapon* UnitTypeData::mutable_weapons(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.UnitTypeData.weapons)
  return weapons_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Weapon >*
UnitTypeData::mutable_weapons() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.UnitTypeData.weapons)
  return &weapons_;
}
inline const ::SCRAPIProtocol::Weapon& UnitTypeData::weapons(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitTypeData.weapons)
  return weapons_.Get(index);
}
inline ::SCRAPIProtocol::Weapon* UnitTypeData::add_weapons() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.UnitTypeData.weapons)
  return weapons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Weapon >&
UnitTypeData::weapons() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.UnitTypeData.weapons)
  return weapons_;
}

// -------------------------------------------------------------------

// UpgradeData

// optional uint32 upgrade_id = 1;
inline bool UpgradeData::has_upgrade_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeData::set_has_upgrade_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeData::clear_has_upgrade_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeData::clear_upgrade_id() {
  upgrade_id_ = 0u;
  clear_has_upgrade_id();
}
inline ::google::protobuf::uint32 UpgradeData::upgrade_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UpgradeData.upgrade_id)
  return upgrade_id_;
}
inline void UpgradeData::set_upgrade_id(::google::protobuf::uint32 value) {
  set_has_upgrade_id();
  upgrade_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UpgradeData.upgrade_id)
}

// optional string name = 2;
inline bool UpgradeData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeData::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& UpgradeData::name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UpgradeData.name)
  return name_.GetNoArena();
}
inline void UpgradeData::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UpgradeData.name)
}
#if LANG_CXX11
inline void UpgradeData::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.UpgradeData.name)
}
#endif
inline void UpgradeData::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.UpgradeData.name)
}
inline void UpgradeData::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.UpgradeData.name)
}
inline ::std::string* UpgradeData::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.UpgradeData.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpgradeData::release_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.UpgradeData.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpgradeData::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.UpgradeData.name)
}

// optional uint32 mineral_cost = 3;
inline bool UpgradeData::has_mineral_cost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpgradeData::set_has_mineral_cost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpgradeData::clear_has_mineral_cost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpgradeData::clear_mineral_cost() {
  mineral_cost_ = 0u;
  clear_has_mineral_cost();
}
inline ::google::protobuf::uint32 UpgradeData::mineral_cost() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UpgradeData.mineral_cost)
  return mineral_cost_;
}
inline void UpgradeData::set_mineral_cost(::google::protobuf::uint32 value) {
  set_has_mineral_cost();
  mineral_cost_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UpgradeData.mineral_cost)
}

// optional uint32 vespene_cost = 4;
inline bool UpgradeData::has_vespene_cost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpgradeData::set_has_vespene_cost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpgradeData::clear_has_vespene_cost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpgradeData::clear_vespene_cost() {
  vespene_cost_ = 0u;
  clear_has_vespene_cost();
}
inline ::google::protobuf::uint32 UpgradeData::vespene_cost() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UpgradeData.vespene_cost)
  return vespene_cost_;
}
inline void UpgradeData::set_vespene_cost(::google::protobuf::uint32 value) {
  set_has_vespene_cost();
  vespene_cost_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UpgradeData.vespene_cost)
}

// optional float research_time = 5;
inline bool UpgradeData::has_research_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpgradeData::set_has_research_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpgradeData::clear_has_research_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpgradeData::clear_research_time() {
  research_time_ = 0;
  clear_has_research_time();
}
inline float UpgradeData::research_time() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UpgradeData.research_time)
  return research_time_;
}
inline void UpgradeData::set_research_time(float value) {
  set_has_research_time();
  research_time_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UpgradeData.research_time)
}

// optional uint32 ability_id = 6;
inline bool UpgradeData::has_ability_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpgradeData::set_has_ability_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpgradeData::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpgradeData::clear_ability_id() {
  ability_id_ = 0u;
  clear_has_ability_id();
}
inline ::google::protobuf::uint32 UpgradeData::ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UpgradeData.ability_id)
  return ability_id_;
}
inline void UpgradeData::set_ability_id(::google::protobuf::uint32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UpgradeData.ability_id)
}

// -------------------------------------------------------------------

// BuffData

// optional uint32 buff_id = 1;
inline bool BuffData::has_buff_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffData::set_has_buff_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffData::clear_has_buff_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffData::clear_buff_id() {
  buff_id_ = 0u;
  clear_has_buff_id();
}
inline ::google::protobuf::uint32 BuffData::buff_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.BuffData.buff_id)
  return buff_id_;
}
inline void BuffData::set_buff_id(::google::protobuf::uint32 value) {
  set_has_buff_id();
  buff_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.BuffData.buff_id)
}

// optional string name = 2;
inline bool BuffData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffData::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& BuffData::name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.BuffData.name)
  return name_.GetNoArena();
}
inline void BuffData::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.BuffData.name)
}
#if LANG_CXX11
inline void BuffData::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.BuffData.name)
}
#endif
inline void BuffData::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.BuffData.name)
}
inline void BuffData::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.BuffData.name)
}
inline ::std::string* BuffData::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.BuffData.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuffData::release_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.BuffData.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuffData::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.BuffData.name)
}

// -------------------------------------------------------------------

// EffectData

// optional uint32 effect_id = 1;
inline bool EffectData::has_effect_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EffectData::set_has_effect_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EffectData::clear_has_effect_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EffectData::clear_effect_id() {
  effect_id_ = 0u;
  clear_has_effect_id();
}
inline ::google::protobuf::uint32 EffectData::effect_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.EffectData.effect_id)
  return effect_id_;
}
inline void EffectData::set_effect_id(::google::protobuf::uint32 value) {
  set_has_effect_id();
  effect_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.EffectData.effect_id)
}

// optional string name = 2;
inline bool EffectData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EffectData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EffectData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EffectData::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& EffectData::name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.EffectData.name)
  return name_.GetNoArena();
}
inline void EffectData::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.EffectData.name)
}
#if LANG_CXX11
inline void EffectData::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.EffectData.name)
}
#endif
inline void EffectData::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.EffectData.name)
}
inline void EffectData::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.EffectData.name)
}
inline ::std::string* EffectData::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.EffectData.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EffectData::release_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.EffectData.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EffectData::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.EffectData.name)
}

// optional string friendly_name = 3;
inline bool EffectData::has_friendly_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EffectData::set_has_friendly_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EffectData::clear_has_friendly_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EffectData::clear_friendly_name() {
  friendly_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_friendly_name();
}
inline const ::std::string& EffectData::friendly_name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.EffectData.friendly_name)
  return friendly_name_.GetNoArena();
}
inline void EffectData::set_friendly_name(const ::std::string& value) {
  set_has_friendly_name();
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.EffectData.friendly_name)
}
#if LANG_CXX11
inline void EffectData::set_friendly_name(::std::string&& value) {
  set_has_friendly_name();
  friendly_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.EffectData.friendly_name)
}
#endif
inline void EffectData::set_friendly_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_friendly_name();
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.EffectData.friendly_name)
}
inline void EffectData::set_friendly_name(const char* value, size_t size) {
  set_has_friendly_name();
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.EffectData.friendly_name)
}
inline ::std::string* EffectData::mutable_friendly_name() {
  set_has_friendly_name();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.EffectData.friendly_name)
  return friendly_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EffectData::release_friendly_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.EffectData.friendly_name)
  if (!has_friendly_name()) {
    return NULL;
  }
  clear_has_friendly_name();
  return friendly_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EffectData::set_allocated_friendly_name(::std::string* friendly_name) {
  if (friendly_name != NULL) {
    set_has_friendly_name();
  } else {
    clear_has_friendly_name();
  }
  friendly_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), friendly_name);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.EffectData.friendly_name)
}

// optional float radius = 4;
inline bool EffectData::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EffectData::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EffectData::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EffectData::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float EffectData::radius() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.EffectData.radius)
  return radius_;
}
inline void EffectData::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.EffectData.radius)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SCRAPIProtocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SCRAPIProtocol::AbilityData_Target> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::AbilityData_Target>() {
  return ::SCRAPIProtocol::AbilityData_Target_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::Weapon_TargetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::Weapon_TargetType>() {
  return ::SCRAPIProtocol::Weapon_TargetType_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::Attribute> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::Attribute>() {
  return ::SCRAPIProtocol::Attribute_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_data_2eproto
