// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: debug.proto

#ifndef PROTOBUF_INCLUDED_debug_2eproto
#define PROTOBUF_INCLUDED_debug_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_debug_2eproto 

namespace protobuf_debug_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_debug_2eproto
namespace SCRAPIProtocol {
class Color;
class ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class DebugBox;
class DebugBoxDefaultTypeInternal;
extern DebugBoxDefaultTypeInternal _DebugBox_default_instance_;
class DebugCommand;
class DebugCommandDefaultTypeInternal;
extern DebugCommandDefaultTypeInternal _DebugCommand_default_instance_;
class DebugCreateUnit;
class DebugCreateUnitDefaultTypeInternal;
extern DebugCreateUnitDefaultTypeInternal _DebugCreateUnit_default_instance_;
class DebugDraw;
class DebugDrawDefaultTypeInternal;
extern DebugDrawDefaultTypeInternal _DebugDraw_default_instance_;
class DebugEndGame;
class DebugEndGameDefaultTypeInternal;
extern DebugEndGameDefaultTypeInternal _DebugEndGame_default_instance_;
class DebugKillUnit;
class DebugKillUnitDefaultTypeInternal;
extern DebugKillUnitDefaultTypeInternal _DebugKillUnit_default_instance_;
class DebugLine;
class DebugLineDefaultTypeInternal;
extern DebugLineDefaultTypeInternal _DebugLine_default_instance_;
class DebugSetScore;
class DebugSetScoreDefaultTypeInternal;
extern DebugSetScoreDefaultTypeInternal _DebugSetScore_default_instance_;
class DebugSetUnitValue;
class DebugSetUnitValueDefaultTypeInternal;
extern DebugSetUnitValueDefaultTypeInternal _DebugSetUnitValue_default_instance_;
class DebugSphere;
class DebugSphereDefaultTypeInternal;
extern DebugSphereDefaultTypeInternal _DebugSphere_default_instance_;
class DebugTestProcess;
class DebugTestProcessDefaultTypeInternal;
extern DebugTestProcessDefaultTypeInternal _DebugTestProcess_default_instance_;
class DebugText;
class DebugTextDefaultTypeInternal;
extern DebugTextDefaultTypeInternal _DebugText_default_instance_;
class Line;
class LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
}  // namespace SCRAPIProtocol
namespace google {
namespace protobuf {
template<> ::SCRAPIProtocol::Color* Arena::CreateMaybeMessage<::SCRAPIProtocol::Color>(Arena*);
template<> ::SCRAPIProtocol::DebugBox* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugBox>(Arena*);
template<> ::SCRAPIProtocol::DebugCommand* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugCommand>(Arena*);
template<> ::SCRAPIProtocol::DebugCreateUnit* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugCreateUnit>(Arena*);
template<> ::SCRAPIProtocol::DebugDraw* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugDraw>(Arena*);
template<> ::SCRAPIProtocol::DebugEndGame* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugEndGame>(Arena*);
template<> ::SCRAPIProtocol::DebugKillUnit* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugKillUnit>(Arena*);
template<> ::SCRAPIProtocol::DebugLine* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugLine>(Arena*);
template<> ::SCRAPIProtocol::DebugSetScore* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugSetScore>(Arena*);
template<> ::SCRAPIProtocol::DebugSetUnitValue* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugSetUnitValue>(Arena*);
template<> ::SCRAPIProtocol::DebugSphere* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugSphere>(Arena*);
template<> ::SCRAPIProtocol::DebugTestProcess* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugTestProcess>(Arena*);
template<> ::SCRAPIProtocol::DebugText* Arena::CreateMaybeMessage<::SCRAPIProtocol::DebugText>(Arena*);
template<> ::SCRAPIProtocol::Line* Arena::CreateMaybeMessage<::SCRAPIProtocol::Line>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace SCRAPIProtocol {

enum DebugTestProcess_Test {
  DebugTestProcess_Test_hang = 1,
  DebugTestProcess_Test_crash = 2,
  DebugTestProcess_Test_exit = 3
};
bool DebugTestProcess_Test_IsValid(int value);
const DebugTestProcess_Test DebugTestProcess_Test_Test_MIN = DebugTestProcess_Test_hang;
const DebugTestProcess_Test DebugTestProcess_Test_Test_MAX = DebugTestProcess_Test_exit;
const int DebugTestProcess_Test_Test_ARRAYSIZE = DebugTestProcess_Test_Test_MAX + 1;

const ::google::protobuf::EnumDescriptor* DebugTestProcess_Test_descriptor();
inline const ::std::string& DebugTestProcess_Test_Name(DebugTestProcess_Test value) {
  return ::google::protobuf::internal::NameOfEnum(
    DebugTestProcess_Test_descriptor(), value);
}
inline bool DebugTestProcess_Test_Parse(
    const ::std::string& name, DebugTestProcess_Test* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DebugTestProcess_Test>(
    DebugTestProcess_Test_descriptor(), name, value);
}
enum DebugEndGame_EndResult {
  DebugEndGame_EndResult_Surrender = 1,
  DebugEndGame_EndResult_DeclareVictory = 2
};
bool DebugEndGame_EndResult_IsValid(int value);
const DebugEndGame_EndResult DebugEndGame_EndResult_EndResult_MIN = DebugEndGame_EndResult_Surrender;
const DebugEndGame_EndResult DebugEndGame_EndResult_EndResult_MAX = DebugEndGame_EndResult_DeclareVictory;
const int DebugEndGame_EndResult_EndResult_ARRAYSIZE = DebugEndGame_EndResult_EndResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* DebugEndGame_EndResult_descriptor();
inline const ::std::string& DebugEndGame_EndResult_Name(DebugEndGame_EndResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    DebugEndGame_EndResult_descriptor(), value);
}
inline bool DebugEndGame_EndResult_Parse(
    const ::std::string& name, DebugEndGame_EndResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DebugEndGame_EndResult>(
    DebugEndGame_EndResult_descriptor(), name, value);
}
enum DebugSetUnitValue_UnitValue {
  DebugSetUnitValue_UnitValue_Energy = 1,
  DebugSetUnitValue_UnitValue_Life = 2,
  DebugSetUnitValue_UnitValue_Shields = 3
};
bool DebugSetUnitValue_UnitValue_IsValid(int value);
const DebugSetUnitValue_UnitValue DebugSetUnitValue_UnitValue_UnitValue_MIN = DebugSetUnitValue_UnitValue_Energy;
const DebugSetUnitValue_UnitValue DebugSetUnitValue_UnitValue_UnitValue_MAX = DebugSetUnitValue_UnitValue_Shields;
const int DebugSetUnitValue_UnitValue_UnitValue_ARRAYSIZE = DebugSetUnitValue_UnitValue_UnitValue_MAX + 1;

const ::google::protobuf::EnumDescriptor* DebugSetUnitValue_UnitValue_descriptor();
inline const ::std::string& DebugSetUnitValue_UnitValue_Name(DebugSetUnitValue_UnitValue value) {
  return ::google::protobuf::internal::NameOfEnum(
    DebugSetUnitValue_UnitValue_descriptor(), value);
}
inline bool DebugSetUnitValue_UnitValue_Parse(
    const ::std::string& name, DebugSetUnitValue_UnitValue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DebugSetUnitValue_UnitValue>(
    DebugSetUnitValue_UnitValue_descriptor(), name, value);
}
enum DebugGameState {
  show_map = 1,
  control_enemy = 2,
  food = 3,
  free = 4,
  all_resources = 5,
  god = 6,
  minerals = 7,
  gas = 8,
  cooldown = 9,
  tech_tree = 10,
  upgrade = 11,
  fast_build = 12
};
bool DebugGameState_IsValid(int value);
const DebugGameState DebugGameState_MIN = show_map;
const DebugGameState DebugGameState_MAX = fast_build;
const int DebugGameState_ARRAYSIZE = DebugGameState_MAX + 1;

const ::google::protobuf::EnumDescriptor* DebugGameState_descriptor();
inline const ::std::string& DebugGameState_Name(DebugGameState value) {
  return ::google::protobuf::internal::NameOfEnum(
    DebugGameState_descriptor(), value);
}
inline bool DebugGameState_Parse(
    const ::std::string& name, DebugGameState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DebugGameState>(
    DebugGameState_descriptor(), name, value);
}
// ===================================================================

class DebugCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugCommand) */ {
 public:
  DebugCommand();
  virtual ~DebugCommand();

  DebugCommand(const DebugCommand& from);

  inline DebugCommand& operator=(const DebugCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugCommand(DebugCommand&& from) noexcept
    : DebugCommand() {
    *this = ::std::move(from);
  }

  inline DebugCommand& operator=(DebugCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugCommand& default_instance();

  enum CommandCase {
    kDraw = 1,
    kGameState = 2,
    kCreateUnit = 3,
    kKillUnit = 4,
    kTestProcess = 5,
    kScore = 6,
    kEndGame = 7,
    kUnitValue = 8,
    COMMAND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugCommand* internal_default_instance() {
    return reinterpret_cast<const DebugCommand*>(
               &_DebugCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(DebugCommand* other);
  friend void swap(DebugCommand& a, DebugCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugCommand* New() const final {
    return CreateMaybeMessage<DebugCommand>(NULL);
  }

  DebugCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugCommand& from);
  void MergeFrom(const DebugCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.DebugDraw draw = 1;
  bool has_draw() const;
  void clear_draw();
  static const int kDrawFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::DebugDraw& _internal_draw() const;
  public:
  const ::SCRAPIProtocol::DebugDraw& draw() const;
  ::SCRAPIProtocol::DebugDraw* release_draw();
  ::SCRAPIProtocol::DebugDraw* mutable_draw();
  void set_allocated_draw(::SCRAPIProtocol::DebugDraw* draw);

  // optional .SCRAPIProtocol.DebugGameState game_state = 2;
  bool has_game_state() const;
  void clear_game_state();
  static const int kGameStateFieldNumber = 2;
  ::SCRAPIProtocol::DebugGameState game_state() const;
  void set_game_state(::SCRAPIProtocol::DebugGameState value);

  // optional .SCRAPIProtocol.DebugCreateUnit create_unit = 3;
  bool has_create_unit() const;
  void clear_create_unit();
  static const int kCreateUnitFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::DebugCreateUnit& _internal_create_unit() const;
  public:
  const ::SCRAPIProtocol::DebugCreateUnit& create_unit() const;
  ::SCRAPIProtocol::DebugCreateUnit* release_create_unit();
  ::SCRAPIProtocol::DebugCreateUnit* mutable_create_unit();
  void set_allocated_create_unit(::SCRAPIProtocol::DebugCreateUnit* create_unit);

  // optional .SCRAPIProtocol.DebugKillUnit kill_unit = 4;
  bool has_kill_unit() const;
  void clear_kill_unit();
  static const int kKillUnitFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::DebugKillUnit& _internal_kill_unit() const;
  public:
  const ::SCRAPIProtocol::DebugKillUnit& kill_unit() const;
  ::SCRAPIProtocol::DebugKillUnit* release_kill_unit();
  ::SCRAPIProtocol::DebugKillUnit* mutable_kill_unit();
  void set_allocated_kill_unit(::SCRAPIProtocol::DebugKillUnit* kill_unit);

  // optional .SCRAPIProtocol.DebugTestProcess test_process = 5;
  bool has_test_process() const;
  void clear_test_process();
  static const int kTestProcessFieldNumber = 5;
  private:
  const ::SCRAPIProtocol::DebugTestProcess& _internal_test_process() const;
  public:
  const ::SCRAPIProtocol::DebugTestProcess& test_process() const;
  ::SCRAPIProtocol::DebugTestProcess* release_test_process();
  ::SCRAPIProtocol::DebugTestProcess* mutable_test_process();
  void set_allocated_test_process(::SCRAPIProtocol::DebugTestProcess* test_process);

  // optional .SCRAPIProtocol.DebugSetScore score = 6;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 6;
  private:
  const ::SCRAPIProtocol::DebugSetScore& _internal_score() const;
  public:
  const ::SCRAPIProtocol::DebugSetScore& score() const;
  ::SCRAPIProtocol::DebugSetScore* release_score();
  ::SCRAPIProtocol::DebugSetScore* mutable_score();
  void set_allocated_score(::SCRAPIProtocol::DebugSetScore* score);

  // optional .SCRAPIProtocol.DebugEndGame end_game = 7;
  bool has_end_game() const;
  void clear_end_game();
  static const int kEndGameFieldNumber = 7;
  private:
  const ::SCRAPIProtocol::DebugEndGame& _internal_end_game() const;
  public:
  const ::SCRAPIProtocol::DebugEndGame& end_game() const;
  ::SCRAPIProtocol::DebugEndGame* release_end_game();
  ::SCRAPIProtocol::DebugEndGame* mutable_end_game();
  void set_allocated_end_game(::SCRAPIProtocol::DebugEndGame* end_game);

  // optional .SCRAPIProtocol.DebugSetUnitValue unit_value = 8;
  bool has_unit_value() const;
  void clear_unit_value();
  static const int kUnitValueFieldNumber = 8;
  private:
  const ::SCRAPIProtocol::DebugSetUnitValue& _internal_unit_value() const;
  public:
  const ::SCRAPIProtocol::DebugSetUnitValue& unit_value() const;
  ::SCRAPIProtocol::DebugSetUnitValue* release_unit_value();
  ::SCRAPIProtocol::DebugSetUnitValue* mutable_unit_value();
  void set_allocated_unit_value(::SCRAPIProtocol::DebugSetUnitValue* unit_value);

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugCommand)
 private:
  void set_has_draw();
  void set_has_game_state();
  void set_has_create_unit();
  void set_has_kill_unit();
  void set_has_test_process();
  void set_has_score();
  void set_has_end_game();
  void set_has_unit_value();

  inline bool has_command() const;
  inline void clear_has_command();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union CommandUnion {
    CommandUnion() {}
    ::SCRAPIProtocol::DebugDraw* draw_;
    int game_state_;
    ::SCRAPIProtocol::DebugCreateUnit* create_unit_;
    ::SCRAPIProtocol::DebugKillUnit* kill_unit_;
    ::SCRAPIProtocol::DebugTestProcess* test_process_;
    ::SCRAPIProtocol::DebugSetScore* score_;
    ::SCRAPIProtocol::DebugEndGame* end_game_;
    ::SCRAPIProtocol::DebugSetUnitValue* unit_value_;
  } command_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugDraw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugDraw) */ {
 public:
  DebugDraw();
  virtual ~DebugDraw();

  DebugDraw(const DebugDraw& from);

  inline DebugDraw& operator=(const DebugDraw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugDraw(DebugDraw&& from) noexcept
    : DebugDraw() {
    *this = ::std::move(from);
  }

  inline DebugDraw& operator=(DebugDraw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugDraw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugDraw* internal_default_instance() {
    return reinterpret_cast<const DebugDraw*>(
               &_DebugDraw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DebugDraw* other);
  friend void swap(DebugDraw& a, DebugDraw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugDraw* New() const final {
    return CreateMaybeMessage<DebugDraw>(NULL);
  }

  DebugDraw* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugDraw>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugDraw& from);
  void MergeFrom(const DebugDraw& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugDraw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.DebugText text = 1;
  int text_size() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  ::SCRAPIProtocol::DebugText* mutable_text(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugText >*
      mutable_text();
  const ::SCRAPIProtocol::DebugText& text(int index) const;
  ::SCRAPIProtocol::DebugText* add_text();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugText >&
      text() const;

  // repeated .SCRAPIProtocol.DebugLine lines = 2;
  int lines_size() const;
  void clear_lines();
  static const int kLinesFieldNumber = 2;
  ::SCRAPIProtocol::DebugLine* mutable_lines(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugLine >*
      mutable_lines();
  const ::SCRAPIProtocol::DebugLine& lines(int index) const;
  ::SCRAPIProtocol::DebugLine* add_lines();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugLine >&
      lines() const;

  // repeated .SCRAPIProtocol.DebugBox boxes = 3;
  int boxes_size() const;
  void clear_boxes();
  static const int kBoxesFieldNumber = 3;
  ::SCRAPIProtocol::DebugBox* mutable_boxes(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugBox >*
      mutable_boxes();
  const ::SCRAPIProtocol::DebugBox& boxes(int index) const;
  ::SCRAPIProtocol::DebugBox* add_boxes();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugBox >&
      boxes() const;

  // repeated .SCRAPIProtocol.DebugSphere spheres = 4;
  int spheres_size() const;
  void clear_spheres();
  static const int kSpheresFieldNumber = 4;
  ::SCRAPIProtocol::DebugSphere* mutable_spheres(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugSphere >*
      mutable_spheres();
  const ::SCRAPIProtocol::DebugSphere& spheres(int index) const;
  ::SCRAPIProtocol::DebugSphere* add_spheres();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugSphere >&
      spheres() const;

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugDraw)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugText > text_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugLine > lines_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugBox > boxes_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugSphere > spheres_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Line : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.Line) */ {
 public:
  Line();
  virtual ~Line();

  Line(const Line& from);

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(Line&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Line& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Line* other);
  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Line* New() const final {
    return CreateMaybeMessage<Line>(NULL);
  }

  Line* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Line& from);
  void MergeFrom(const Line& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.Point p0 = 1;
  bool has_p0() const;
  void clear_p0();
  static const int kP0FieldNumber = 1;
  private:
  const ::SCRAPIProtocol::Point& _internal_p0() const;
  public:
  const ::SCRAPIProtocol::Point& p0() const;
  ::SCRAPIProtocol::Point* release_p0();
  ::SCRAPIProtocol::Point* mutable_p0();
  void set_allocated_p0(::SCRAPIProtocol::Point* p0);

  // optional .SCRAPIProtocol.Point p1 = 2;
  bool has_p1() const;
  void clear_p1();
  static const int kP1FieldNumber = 2;
  private:
  const ::SCRAPIProtocol::Point& _internal_p1() const;
  public:
  const ::SCRAPIProtocol::Point& p1() const;
  ::SCRAPIProtocol::Point* release_p1();
  ::SCRAPIProtocol::Point* mutable_p1();
  void set_allocated_p1(::SCRAPIProtocol::Point* p1);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.Line)
 private:
  void set_has_p0();
  void clear_has_p0();
  void set_has_p1();
  void clear_has_p1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::Point* p0_;
  ::SCRAPIProtocol::Point* p1_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Color : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.Color) */ {
 public:
  Color();
  virtual ~Color();

  Color(const Color& from);

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(Color&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Color& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Color* other);
  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Color* New() const final {
    return CreateMaybeMessage<Color>(NULL);
  }

  Color* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 r = 1;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 1;
  ::google::protobuf::uint32 r() const;
  void set_r(::google::protobuf::uint32 value);

  // optional uint32 g = 2;
  bool has_g() const;
  void clear_g();
  static const int kGFieldNumber = 2;
  ::google::protobuf::uint32 g() const;
  void set_g(::google::protobuf::uint32 value);

  // optional uint32 b = 3;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 3;
  ::google::protobuf::uint32 b() const;
  void set_b(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.Color)
 private:
  void set_has_r();
  void clear_has_r();
  void set_has_g();
  void clear_has_g();
  void set_has_b();
  void clear_has_b();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 g_;
  ::google::protobuf::uint32 b_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugText : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugText) */ {
 public:
  DebugText();
  virtual ~DebugText();

  DebugText(const DebugText& from);

  inline DebugText& operator=(const DebugText& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugText(DebugText&& from) noexcept
    : DebugText() {
    *this = ::std::move(from);
  }

  inline DebugText& operator=(DebugText&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugText& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugText* internal_default_instance() {
    return reinterpret_cast<const DebugText*>(
               &_DebugText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DebugText* other);
  friend void swap(DebugText& a, DebugText& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugText* New() const final {
    return CreateMaybeMessage<DebugText>(NULL);
  }

  DebugText* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugText>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugText& from);
  void MergeFrom(const DebugText& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugText* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional .SCRAPIProtocol.Color color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::Color& _internal_color() const;
  public:
  const ::SCRAPIProtocol::Color& color() const;
  ::SCRAPIProtocol::Color* release_color();
  ::SCRAPIProtocol::Color* mutable_color();
  void set_allocated_color(::SCRAPIProtocol::Color* color);

  // optional .SCRAPIProtocol.Point virtual_pos = 3;
  bool has_virtual_pos() const;
  void clear_virtual_pos();
  static const int kVirtualPosFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::Point& _internal_virtual_pos() const;
  public:
  const ::SCRAPIProtocol::Point& virtual_pos() const;
  ::SCRAPIProtocol::Point* release_virtual_pos();
  ::SCRAPIProtocol::Point* mutable_virtual_pos();
  void set_allocated_virtual_pos(::SCRAPIProtocol::Point* virtual_pos);

  // optional .SCRAPIProtocol.Point world_pos = 4;
  bool has_world_pos() const;
  void clear_world_pos();
  static const int kWorldPosFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::Point& _internal_world_pos() const;
  public:
  const ::SCRAPIProtocol::Point& world_pos() const;
  ::SCRAPIProtocol::Point* release_world_pos();
  ::SCRAPIProtocol::Point* mutable_world_pos();
  void set_allocated_world_pos(::SCRAPIProtocol::Point* world_pos);

  // optional uint32 size = 5;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 5;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugText)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_text();
  void clear_has_text();
  void set_has_virtual_pos();
  void clear_has_virtual_pos();
  void set_has_world_pos();
  void clear_has_world_pos();
  void set_has_size();
  void clear_has_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::SCRAPIProtocol::Color* color_;
  ::SCRAPIProtocol::Point* virtual_pos_;
  ::SCRAPIProtocol::Point* world_pos_;
  ::google::protobuf::uint32 size_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugLine) */ {
 public:
  DebugLine();
  virtual ~DebugLine();

  DebugLine(const DebugLine& from);

  inline DebugLine& operator=(const DebugLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLine(DebugLine&& from) noexcept
    : DebugLine() {
    *this = ::std::move(from);
  }

  inline DebugLine& operator=(DebugLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLine* internal_default_instance() {
    return reinterpret_cast<const DebugLine*>(
               &_DebugLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DebugLine* other);
  friend void swap(DebugLine& a, DebugLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLine* New() const final {
    return CreateMaybeMessage<DebugLine>(NULL);
  }

  DebugLine* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLine>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLine& from);
  void MergeFrom(const DebugLine& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.Color color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::Color& _internal_color() const;
  public:
  const ::SCRAPIProtocol::Color& color() const;
  ::SCRAPIProtocol::Color* release_color();
  ::SCRAPIProtocol::Color* mutable_color();
  void set_allocated_color(::SCRAPIProtocol::Color* color);

  // optional .SCRAPIProtocol.Line line = 2;
  bool has_line() const;
  void clear_line();
  static const int kLineFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::Line& _internal_line() const;
  public:
  const ::SCRAPIProtocol::Line& line() const;
  ::SCRAPIProtocol::Line* release_line();
  ::SCRAPIProtocol::Line* mutable_line();
  void set_allocated_line(::SCRAPIProtocol::Line* line);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugLine)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_line();
  void clear_has_line();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::Color* color_;
  ::SCRAPIProtocol::Line* line_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugBox) */ {
 public:
  DebugBox();
  virtual ~DebugBox();

  DebugBox(const DebugBox& from);

  inline DebugBox& operator=(const DebugBox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugBox(DebugBox&& from) noexcept
    : DebugBox() {
    *this = ::std::move(from);
  }

  inline DebugBox& operator=(DebugBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugBox* internal_default_instance() {
    return reinterpret_cast<const DebugBox*>(
               &_DebugBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(DebugBox* other);
  friend void swap(DebugBox& a, DebugBox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugBox* New() const final {
    return CreateMaybeMessage<DebugBox>(NULL);
  }

  DebugBox* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugBox>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugBox& from);
  void MergeFrom(const DebugBox& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugBox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.Color color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::Color& _internal_color() const;
  public:
  const ::SCRAPIProtocol::Color& color() const;
  ::SCRAPIProtocol::Color* release_color();
  ::SCRAPIProtocol::Color* mutable_color();
  void set_allocated_color(::SCRAPIProtocol::Color* color);

  // optional .SCRAPIProtocol.Point min = 2;
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::Point& _internal_min() const;
  public:
  const ::SCRAPIProtocol::Point& min() const;
  ::SCRAPIProtocol::Point* release_min();
  ::SCRAPIProtocol::Point* mutable_min();
  void set_allocated_min(::SCRAPIProtocol::Point* min);

  // optional .SCRAPIProtocol.Point max = 3;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::Point& _internal_max() const;
  public:
  const ::SCRAPIProtocol::Point& max() const;
  ::SCRAPIProtocol::Point* release_max();
  ::SCRAPIProtocol::Point* mutable_max();
  void set_allocated_max(::SCRAPIProtocol::Point* max);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugBox)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_min();
  void clear_has_min();
  void set_has_max();
  void clear_has_max();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::Color* color_;
  ::SCRAPIProtocol::Point* min_;
  ::SCRAPIProtocol::Point* max_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugSphere : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugSphere) */ {
 public:
  DebugSphere();
  virtual ~DebugSphere();

  DebugSphere(const DebugSphere& from);

  inline DebugSphere& operator=(const DebugSphere& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugSphere(DebugSphere&& from) noexcept
    : DebugSphere() {
    *this = ::std::move(from);
  }

  inline DebugSphere& operator=(DebugSphere&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugSphere& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugSphere* internal_default_instance() {
    return reinterpret_cast<const DebugSphere*>(
               &_DebugSphere_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DebugSphere* other);
  friend void swap(DebugSphere& a, DebugSphere& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugSphere* New() const final {
    return CreateMaybeMessage<DebugSphere>(NULL);
  }

  DebugSphere* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugSphere>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugSphere& from);
  void MergeFrom(const DebugSphere& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSphere* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.Color color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::Color& _internal_color() const;
  public:
  const ::SCRAPIProtocol::Color& color() const;
  ::SCRAPIProtocol::Color* release_color();
  ::SCRAPIProtocol::Color* mutable_color();
  void set_allocated_color(::SCRAPIProtocol::Color* color);

  // optional .SCRAPIProtocol.Point p = 2;
  bool has_p() const;
  void clear_p();
  static const int kPFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::Point& _internal_p() const;
  public:
  const ::SCRAPIProtocol::Point& p() const;
  ::SCRAPIProtocol::Point* release_p();
  ::SCRAPIProtocol::Point* mutable_p();
  void set_allocated_p(::SCRAPIProtocol::Point* p);

  // optional float r = 3;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 3;
  float r() const;
  void set_r(float value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugSphere)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_p();
  void clear_has_p();
  void set_has_r();
  void clear_has_r();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::Color* color_;
  ::SCRAPIProtocol::Point* p_;
  float r_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugCreateUnit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugCreateUnit) */ {
 public:
  DebugCreateUnit();
  virtual ~DebugCreateUnit();

  DebugCreateUnit(const DebugCreateUnit& from);

  inline DebugCreateUnit& operator=(const DebugCreateUnit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugCreateUnit(DebugCreateUnit&& from) noexcept
    : DebugCreateUnit() {
    *this = ::std::move(from);
  }

  inline DebugCreateUnit& operator=(DebugCreateUnit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugCreateUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugCreateUnit* internal_default_instance() {
    return reinterpret_cast<const DebugCreateUnit*>(
               &_DebugCreateUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DebugCreateUnit* other);
  friend void swap(DebugCreateUnit& a, DebugCreateUnit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugCreateUnit* New() const final {
    return CreateMaybeMessage<DebugCreateUnit>(NULL);
  }

  DebugCreateUnit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugCreateUnit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugCreateUnit& from);
  void MergeFrom(const DebugCreateUnit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugCreateUnit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.Point2D pos = 3;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::Point2D& _internal_pos() const;
  public:
  const ::SCRAPIProtocol::Point2D& pos() const;
  ::SCRAPIProtocol::Point2D* release_pos();
  ::SCRAPIProtocol::Point2D* mutable_pos();
  void set_allocated_pos(::SCRAPIProtocol::Point2D* pos);

  // optional uint32 unit_type = 1;
  bool has_unit_type() const;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 1;
  ::google::protobuf::uint32 unit_type() const;
  void set_unit_type(::google::protobuf::uint32 value);

  // optional int32 owner = 2;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 2;
  ::google::protobuf::int32 owner() const;
  void set_owner(::google::protobuf::int32 value);

  // optional uint32 quantity = 4;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  ::google::protobuf::uint32 quantity() const;
  void set_quantity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugCreateUnit)
 private:
  void set_has_unit_type();
  void clear_has_unit_type();
  void set_has_owner();
  void clear_has_owner();
  void set_has_pos();
  void clear_has_pos();
  void set_has_quantity();
  void clear_has_quantity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::Point2D* pos_;
  ::google::protobuf::uint32 unit_type_;
  ::google::protobuf::int32 owner_;
  ::google::protobuf::uint32 quantity_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugKillUnit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugKillUnit) */ {
 public:
  DebugKillUnit();
  virtual ~DebugKillUnit();

  DebugKillUnit(const DebugKillUnit& from);

  inline DebugKillUnit& operator=(const DebugKillUnit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugKillUnit(DebugKillUnit&& from) noexcept
    : DebugKillUnit() {
    *this = ::std::move(from);
  }

  inline DebugKillUnit& operator=(DebugKillUnit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugKillUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugKillUnit* internal_default_instance() {
    return reinterpret_cast<const DebugKillUnit*>(
               &_DebugKillUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(DebugKillUnit* other);
  friend void swap(DebugKillUnit& a, DebugKillUnit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugKillUnit* New() const final {
    return CreateMaybeMessage<DebugKillUnit>(NULL);
  }

  DebugKillUnit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugKillUnit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugKillUnit& from);
  void MergeFrom(const DebugKillUnit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugKillUnit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 tag = 1;
  int tag_size() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::google::protobuf::uint64 tag(int index) const;
  void set_tag(int index, ::google::protobuf::uint64 value);
  void add_tag(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      tag() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_tag();

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugKillUnit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > tag_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugTestProcess : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugTestProcess) */ {
 public:
  DebugTestProcess();
  virtual ~DebugTestProcess();

  DebugTestProcess(const DebugTestProcess& from);

  inline DebugTestProcess& operator=(const DebugTestProcess& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugTestProcess(DebugTestProcess&& from) noexcept
    : DebugTestProcess() {
    *this = ::std::move(from);
  }

  inline DebugTestProcess& operator=(DebugTestProcess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugTestProcess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugTestProcess* internal_default_instance() {
    return reinterpret_cast<const DebugTestProcess*>(
               &_DebugTestProcess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(DebugTestProcess* other);
  friend void swap(DebugTestProcess& a, DebugTestProcess& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugTestProcess* New() const final {
    return CreateMaybeMessage<DebugTestProcess>(NULL);
  }

  DebugTestProcess* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugTestProcess>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugTestProcess& from);
  void MergeFrom(const DebugTestProcess& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugTestProcess* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DebugTestProcess_Test Test;
  static const Test hang =
    DebugTestProcess_Test_hang;
  static const Test crash =
    DebugTestProcess_Test_crash;
  static const Test exit =
    DebugTestProcess_Test_exit;
  static inline bool Test_IsValid(int value) {
    return DebugTestProcess_Test_IsValid(value);
  }
  static const Test Test_MIN =
    DebugTestProcess_Test_Test_MIN;
  static const Test Test_MAX =
    DebugTestProcess_Test_Test_MAX;
  static const int Test_ARRAYSIZE =
    DebugTestProcess_Test_Test_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Test_descriptor() {
    return DebugTestProcess_Test_descriptor();
  }
  static inline const ::std::string& Test_Name(Test value) {
    return DebugTestProcess_Test_Name(value);
  }
  static inline bool Test_Parse(const ::std::string& name,
      Test* value) {
    return DebugTestProcess_Test_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 delay_ms = 2;
  bool has_delay_ms() const;
  void clear_delay_ms();
  static const int kDelayMsFieldNumber = 2;
  ::google::protobuf::int32 delay_ms() const;
  void set_delay_ms(::google::protobuf::int32 value);

  // optional .SCRAPIProtocol.DebugTestProcess.Test test = 1;
  bool has_test() const;
  void clear_test();
  static const int kTestFieldNumber = 1;
  ::SCRAPIProtocol::DebugTestProcess_Test test() const;
  void set_test(::SCRAPIProtocol::DebugTestProcess_Test value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugTestProcess)
 private:
  void set_has_test();
  void clear_has_test();
  void set_has_delay_ms();
  void clear_has_delay_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 delay_ms_;
  int test_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugSetScore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugSetScore) */ {
 public:
  DebugSetScore();
  virtual ~DebugSetScore();

  DebugSetScore(const DebugSetScore& from);

  inline DebugSetScore& operator=(const DebugSetScore& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugSetScore(DebugSetScore&& from) noexcept
    : DebugSetScore() {
    *this = ::std::move(from);
  }

  inline DebugSetScore& operator=(DebugSetScore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugSetScore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugSetScore* internal_default_instance() {
    return reinterpret_cast<const DebugSetScore*>(
               &_DebugSetScore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(DebugSetScore* other);
  friend void swap(DebugSetScore& a, DebugSetScore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugSetScore* New() const final {
    return CreateMaybeMessage<DebugSetScore>(NULL);
  }

  DebugSetScore* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugSetScore>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugSetScore& from);
  void MergeFrom(const DebugSetScore& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSetScore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float score = 1;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 1;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugSetScore)
 private:
  void set_has_score();
  void clear_has_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float score_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugEndGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugEndGame) */ {
 public:
  DebugEndGame();
  virtual ~DebugEndGame();

  DebugEndGame(const DebugEndGame& from);

  inline DebugEndGame& operator=(const DebugEndGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugEndGame(DebugEndGame&& from) noexcept
    : DebugEndGame() {
    *this = ::std::move(from);
  }

  inline DebugEndGame& operator=(DebugEndGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugEndGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugEndGame* internal_default_instance() {
    return reinterpret_cast<const DebugEndGame*>(
               &_DebugEndGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DebugEndGame* other);
  friend void swap(DebugEndGame& a, DebugEndGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugEndGame* New() const final {
    return CreateMaybeMessage<DebugEndGame>(NULL);
  }

  DebugEndGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugEndGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugEndGame& from);
  void MergeFrom(const DebugEndGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugEndGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DebugEndGame_EndResult EndResult;
  static const EndResult Surrender =
    DebugEndGame_EndResult_Surrender;
  static const EndResult DeclareVictory =
    DebugEndGame_EndResult_DeclareVictory;
  static inline bool EndResult_IsValid(int value) {
    return DebugEndGame_EndResult_IsValid(value);
  }
  static const EndResult EndResult_MIN =
    DebugEndGame_EndResult_EndResult_MIN;
  static const EndResult EndResult_MAX =
    DebugEndGame_EndResult_EndResult_MAX;
  static const int EndResult_ARRAYSIZE =
    DebugEndGame_EndResult_EndResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EndResult_descriptor() {
    return DebugEndGame_EndResult_descriptor();
  }
  static inline const ::std::string& EndResult_Name(EndResult value) {
    return DebugEndGame_EndResult_Name(value);
  }
  static inline bool EndResult_Parse(const ::std::string& name,
      EndResult* value) {
    return DebugEndGame_EndResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.DebugEndGame.EndResult end_result = 1;
  bool has_end_result() const;
  void clear_end_result();
  static const int kEndResultFieldNumber = 1;
  ::SCRAPIProtocol::DebugEndGame_EndResult end_result() const;
  void set_end_result(::SCRAPIProtocol::DebugEndGame_EndResult value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugEndGame)
 private:
  void set_has_end_result();
  void clear_has_end_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int end_result_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugSetUnitValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.DebugSetUnitValue) */ {
 public:
  DebugSetUnitValue();
  virtual ~DebugSetUnitValue();

  DebugSetUnitValue(const DebugSetUnitValue& from);

  inline DebugSetUnitValue& operator=(const DebugSetUnitValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugSetUnitValue(DebugSetUnitValue&& from) noexcept
    : DebugSetUnitValue() {
    *this = ::std::move(from);
  }

  inline DebugSetUnitValue& operator=(DebugSetUnitValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugSetUnitValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugSetUnitValue* internal_default_instance() {
    return reinterpret_cast<const DebugSetUnitValue*>(
               &_DebugSetUnitValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(DebugSetUnitValue* other);
  friend void swap(DebugSetUnitValue& a, DebugSetUnitValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugSetUnitValue* New() const final {
    return CreateMaybeMessage<DebugSetUnitValue>(NULL);
  }

  DebugSetUnitValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugSetUnitValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugSetUnitValue& from);
  void MergeFrom(const DebugSetUnitValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSetUnitValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DebugSetUnitValue_UnitValue UnitValue;
  static const UnitValue Energy =
    DebugSetUnitValue_UnitValue_Energy;
  static const UnitValue Life =
    DebugSetUnitValue_UnitValue_Life;
  static const UnitValue Shields =
    DebugSetUnitValue_UnitValue_Shields;
  static inline bool UnitValue_IsValid(int value) {
    return DebugSetUnitValue_UnitValue_IsValid(value);
  }
  static const UnitValue UnitValue_MIN =
    DebugSetUnitValue_UnitValue_UnitValue_MIN;
  static const UnitValue UnitValue_MAX =
    DebugSetUnitValue_UnitValue_UnitValue_MAX;
  static const int UnitValue_ARRAYSIZE =
    DebugSetUnitValue_UnitValue_UnitValue_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UnitValue_descriptor() {
    return DebugSetUnitValue_UnitValue_descriptor();
  }
  static inline const ::std::string& UnitValue_Name(UnitValue value) {
    return DebugSetUnitValue_UnitValue_Name(value);
  }
  static inline bool UnitValue_Parse(const ::std::string& name,
      UnitValue* value) {
    return DebugSetUnitValue_UnitValue_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint64 unit_tag = 3;
  bool has_unit_tag() const;
  void clear_unit_tag();
  static const int kUnitTagFieldNumber = 3;
  ::google::protobuf::uint64 unit_tag() const;
  void set_unit_tag(::google::protobuf::uint64 value);

  // optional float value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // optional .SCRAPIProtocol.DebugSetUnitValue.UnitValue unit_value = 1;
  bool has_unit_value() const;
  void clear_unit_value();
  static const int kUnitValueFieldNumber = 1;
  ::SCRAPIProtocol::DebugSetUnitValue_UnitValue unit_value() const;
  void set_unit_value(::SCRAPIProtocol::DebugSetUnitValue_UnitValue value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.DebugSetUnitValue)
 private:
  void set_has_unit_value();
  void clear_has_unit_value();
  void set_has_value();
  void clear_has_value();
  void set_has_unit_tag();
  void clear_has_unit_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 unit_tag_;
  float value_;
  int unit_value_;
  friend struct ::protobuf_debug_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DebugCommand

// optional .SCRAPIProtocol.DebugDraw draw = 1;
inline bool DebugCommand::has_draw() const {
  return command_case() == kDraw;
}
inline void DebugCommand::set_has_draw() {
  _oneof_case_[0] = kDraw;
}
inline void DebugCommand::clear_draw() {
  if (has_draw()) {
    delete command_.draw_;
    clear_has_command();
  }
}
inline const ::SCRAPIProtocol::DebugDraw& DebugCommand::_internal_draw() const {
  return *command_.draw_;
}
inline ::SCRAPIProtocol::DebugDraw* DebugCommand::release_draw() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugCommand.draw)
  if (has_draw()) {
    clear_has_command();
      ::SCRAPIProtocol::DebugDraw* temp = command_.draw_;
    command_.draw_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::DebugDraw& DebugCommand::draw() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCommand.draw)
  return has_draw()
      ? *command_.draw_
      : *reinterpret_cast< ::SCRAPIProtocol::DebugDraw*>(&::SCRAPIProtocol::_DebugDraw_default_instance_);
}
inline ::SCRAPIProtocol::DebugDraw* DebugCommand::mutable_draw() {
  if (!has_draw()) {
    clear_command();
    set_has_draw();
    command_.draw_ = CreateMaybeMessage< ::SCRAPIProtocol::DebugDraw >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugCommand.draw)
  return command_.draw_;
}

// optional .SCRAPIProtocol.DebugGameState game_state = 2;
inline bool DebugCommand::has_game_state() const {
  return command_case() == kGameState;
}
inline void DebugCommand::set_has_game_state() {
  _oneof_case_[0] = kGameState;
}
inline void DebugCommand::clear_game_state() {
  if (has_game_state()) {
    command_.game_state_ = 1;
    clear_has_command();
  }
}
inline ::SCRAPIProtocol::DebugGameState DebugCommand::game_state() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCommand.game_state)
  if (has_game_state()) {
    return static_cast< ::SCRAPIProtocol::DebugGameState >(command_.game_state_);
  }
  return static_cast< ::SCRAPIProtocol::DebugGameState >(1);
}
inline void DebugCommand::set_game_state(::SCRAPIProtocol::DebugGameState value) {
  assert(::SCRAPIProtocol::DebugGameState_IsValid(value));
  if (!has_game_state()) {
    clear_command();
    set_has_game_state();
  }
  command_.game_state_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugCommand.game_state)
}

// optional .SCRAPIProtocol.DebugCreateUnit create_unit = 3;
inline bool DebugCommand::has_create_unit() const {
  return command_case() == kCreateUnit;
}
inline void DebugCommand::set_has_create_unit() {
  _oneof_case_[0] = kCreateUnit;
}
inline void DebugCommand::clear_create_unit() {
  if (has_create_unit()) {
    delete command_.create_unit_;
    clear_has_command();
  }
}
inline const ::SCRAPIProtocol::DebugCreateUnit& DebugCommand::_internal_create_unit() const {
  return *command_.create_unit_;
}
inline ::SCRAPIProtocol::DebugCreateUnit* DebugCommand::release_create_unit() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugCommand.create_unit)
  if (has_create_unit()) {
    clear_has_command();
      ::SCRAPIProtocol::DebugCreateUnit* temp = command_.create_unit_;
    command_.create_unit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::DebugCreateUnit& DebugCommand::create_unit() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCommand.create_unit)
  return has_create_unit()
      ? *command_.create_unit_
      : *reinterpret_cast< ::SCRAPIProtocol::DebugCreateUnit*>(&::SCRAPIProtocol::_DebugCreateUnit_default_instance_);
}
inline ::SCRAPIProtocol::DebugCreateUnit* DebugCommand::mutable_create_unit() {
  if (!has_create_unit()) {
    clear_command();
    set_has_create_unit();
    command_.create_unit_ = CreateMaybeMessage< ::SCRAPIProtocol::DebugCreateUnit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugCommand.create_unit)
  return command_.create_unit_;
}

// optional .SCRAPIProtocol.DebugKillUnit kill_unit = 4;
inline bool DebugCommand::has_kill_unit() const {
  return command_case() == kKillUnit;
}
inline void DebugCommand::set_has_kill_unit() {
  _oneof_case_[0] = kKillUnit;
}
inline void DebugCommand::clear_kill_unit() {
  if (has_kill_unit()) {
    delete command_.kill_unit_;
    clear_has_command();
  }
}
inline const ::SCRAPIProtocol::DebugKillUnit& DebugCommand::_internal_kill_unit() const {
  return *command_.kill_unit_;
}
inline ::SCRAPIProtocol::DebugKillUnit* DebugCommand::release_kill_unit() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugCommand.kill_unit)
  if (has_kill_unit()) {
    clear_has_command();
      ::SCRAPIProtocol::DebugKillUnit* temp = command_.kill_unit_;
    command_.kill_unit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::DebugKillUnit& DebugCommand::kill_unit() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCommand.kill_unit)
  return has_kill_unit()
      ? *command_.kill_unit_
      : *reinterpret_cast< ::SCRAPIProtocol::DebugKillUnit*>(&::SCRAPIProtocol::_DebugKillUnit_default_instance_);
}
inline ::SCRAPIProtocol::DebugKillUnit* DebugCommand::mutable_kill_unit() {
  if (!has_kill_unit()) {
    clear_command();
    set_has_kill_unit();
    command_.kill_unit_ = CreateMaybeMessage< ::SCRAPIProtocol::DebugKillUnit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugCommand.kill_unit)
  return command_.kill_unit_;
}

// optional .SCRAPIProtocol.DebugTestProcess test_process = 5;
inline bool DebugCommand::has_test_process() const {
  return command_case() == kTestProcess;
}
inline void DebugCommand::set_has_test_process() {
  _oneof_case_[0] = kTestProcess;
}
inline void DebugCommand::clear_test_process() {
  if (has_test_process()) {
    delete command_.test_process_;
    clear_has_command();
  }
}
inline const ::SCRAPIProtocol::DebugTestProcess& DebugCommand::_internal_test_process() const {
  return *command_.test_process_;
}
inline ::SCRAPIProtocol::DebugTestProcess* DebugCommand::release_test_process() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugCommand.test_process)
  if (has_test_process()) {
    clear_has_command();
      ::SCRAPIProtocol::DebugTestProcess* temp = command_.test_process_;
    command_.test_process_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::DebugTestProcess& DebugCommand::test_process() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCommand.test_process)
  return has_test_process()
      ? *command_.test_process_
      : *reinterpret_cast< ::SCRAPIProtocol::DebugTestProcess*>(&::SCRAPIProtocol::_DebugTestProcess_default_instance_);
}
inline ::SCRAPIProtocol::DebugTestProcess* DebugCommand::mutable_test_process() {
  if (!has_test_process()) {
    clear_command();
    set_has_test_process();
    command_.test_process_ = CreateMaybeMessage< ::SCRAPIProtocol::DebugTestProcess >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugCommand.test_process)
  return command_.test_process_;
}

// optional .SCRAPIProtocol.DebugSetScore score = 6;
inline bool DebugCommand::has_score() const {
  return command_case() == kScore;
}
inline void DebugCommand::set_has_score() {
  _oneof_case_[0] = kScore;
}
inline void DebugCommand::clear_score() {
  if (has_score()) {
    delete command_.score_;
    clear_has_command();
  }
}
inline const ::SCRAPIProtocol::DebugSetScore& DebugCommand::_internal_score() const {
  return *command_.score_;
}
inline ::SCRAPIProtocol::DebugSetScore* DebugCommand::release_score() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugCommand.score)
  if (has_score()) {
    clear_has_command();
      ::SCRAPIProtocol::DebugSetScore* temp = command_.score_;
    command_.score_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::DebugSetScore& DebugCommand::score() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCommand.score)
  return has_score()
      ? *command_.score_
      : *reinterpret_cast< ::SCRAPIProtocol::DebugSetScore*>(&::SCRAPIProtocol::_DebugSetScore_default_instance_);
}
inline ::SCRAPIProtocol::DebugSetScore* DebugCommand::mutable_score() {
  if (!has_score()) {
    clear_command();
    set_has_score();
    command_.score_ = CreateMaybeMessage< ::SCRAPIProtocol::DebugSetScore >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugCommand.score)
  return command_.score_;
}

// optional .SCRAPIProtocol.DebugEndGame end_game = 7;
inline bool DebugCommand::has_end_game() const {
  return command_case() == kEndGame;
}
inline void DebugCommand::set_has_end_game() {
  _oneof_case_[0] = kEndGame;
}
inline void DebugCommand::clear_end_game() {
  if (has_end_game()) {
    delete command_.end_game_;
    clear_has_command();
  }
}
inline const ::SCRAPIProtocol::DebugEndGame& DebugCommand::_internal_end_game() const {
  return *command_.end_game_;
}
inline ::SCRAPIProtocol::DebugEndGame* DebugCommand::release_end_game() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugCommand.end_game)
  if (has_end_game()) {
    clear_has_command();
      ::SCRAPIProtocol::DebugEndGame* temp = command_.end_game_;
    command_.end_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::DebugEndGame& DebugCommand::end_game() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCommand.end_game)
  return has_end_game()
      ? *command_.end_game_
      : *reinterpret_cast< ::SCRAPIProtocol::DebugEndGame*>(&::SCRAPIProtocol::_DebugEndGame_default_instance_);
}
inline ::SCRAPIProtocol::DebugEndGame* DebugCommand::mutable_end_game() {
  if (!has_end_game()) {
    clear_command();
    set_has_end_game();
    command_.end_game_ = CreateMaybeMessage< ::SCRAPIProtocol::DebugEndGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugCommand.end_game)
  return command_.end_game_;
}

// optional .SCRAPIProtocol.DebugSetUnitValue unit_value = 8;
inline bool DebugCommand::has_unit_value() const {
  return command_case() == kUnitValue;
}
inline void DebugCommand::set_has_unit_value() {
  _oneof_case_[0] = kUnitValue;
}
inline void DebugCommand::clear_unit_value() {
  if (has_unit_value()) {
    delete command_.unit_value_;
    clear_has_command();
  }
}
inline const ::SCRAPIProtocol::DebugSetUnitValue& DebugCommand::_internal_unit_value() const {
  return *command_.unit_value_;
}
inline ::SCRAPIProtocol::DebugSetUnitValue* DebugCommand::release_unit_value() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugCommand.unit_value)
  if (has_unit_value()) {
    clear_has_command();
      ::SCRAPIProtocol::DebugSetUnitValue* temp = command_.unit_value_;
    command_.unit_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::DebugSetUnitValue& DebugCommand::unit_value() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCommand.unit_value)
  return has_unit_value()
      ? *command_.unit_value_
      : *reinterpret_cast< ::SCRAPIProtocol::DebugSetUnitValue*>(&::SCRAPIProtocol::_DebugSetUnitValue_default_instance_);
}
inline ::SCRAPIProtocol::DebugSetUnitValue* DebugCommand::mutable_unit_value() {
  if (!has_unit_value()) {
    clear_command();
    set_has_unit_value();
    command_.unit_value_ = CreateMaybeMessage< ::SCRAPIProtocol::DebugSetUnitValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugCommand.unit_value)
  return command_.unit_value_;
}

inline bool DebugCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void DebugCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline DebugCommand::CommandCase DebugCommand::command_case() const {
  return DebugCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DebugDraw

// repeated .SCRAPIProtocol.DebugText text = 1;
inline int DebugDraw::text_size() const {
  return text_.size();
}
inline void DebugDraw::clear_text() {
  text_.Clear();
}
inline ::SCRAPIProtocol::DebugText* DebugDraw::mutable_text(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugDraw.text)
  return text_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugText >*
DebugDraw::mutable_text() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.DebugDraw.text)
  return &text_;
}
inline const ::SCRAPIProtocol::DebugText& DebugDraw::text(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugDraw.text)
  return text_.Get(index);
}
inline ::SCRAPIProtocol::DebugText* DebugDraw::add_text() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.DebugDraw.text)
  return text_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugText >&
DebugDraw::text() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.DebugDraw.text)
  return text_;
}

// repeated .SCRAPIProtocol.DebugLine lines = 2;
inline int DebugDraw::lines_size() const {
  return lines_.size();
}
inline void DebugDraw::clear_lines() {
  lines_.Clear();
}
inline ::SCRAPIProtocol::DebugLine* DebugDraw::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugDraw.lines)
  return lines_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugLine >*
DebugDraw::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.DebugDraw.lines)
  return &lines_;
}
inline const ::SCRAPIProtocol::DebugLine& DebugDraw::lines(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugDraw.lines)
  return lines_.Get(index);
}
inline ::SCRAPIProtocol::DebugLine* DebugDraw::add_lines() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.DebugDraw.lines)
  return lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugLine >&
DebugDraw::lines() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.DebugDraw.lines)
  return lines_;
}

// repeated .SCRAPIProtocol.DebugBox boxes = 3;
inline int DebugDraw::boxes_size() const {
  return boxes_.size();
}
inline void DebugDraw::clear_boxes() {
  boxes_.Clear();
}
inline ::SCRAPIProtocol::DebugBox* DebugDraw::mutable_boxes(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugDraw.boxes)
  return boxes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugBox >*
DebugDraw::mutable_boxes() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.DebugDraw.boxes)
  return &boxes_;
}
inline const ::SCRAPIProtocol::DebugBox& DebugDraw::boxes(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugDraw.boxes)
  return boxes_.Get(index);
}
inline ::SCRAPIProtocol::DebugBox* DebugDraw::add_boxes() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.DebugDraw.boxes)
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugBox >&
DebugDraw::boxes() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.DebugDraw.boxes)
  return boxes_;
}

// repeated .SCRAPIProtocol.DebugSphere spheres = 4;
inline int DebugDraw::spheres_size() const {
  return spheres_.size();
}
inline void DebugDraw::clear_spheres() {
  spheres_.Clear();
}
inline ::SCRAPIProtocol::DebugSphere* DebugDraw::mutable_spheres(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugDraw.spheres)
  return spheres_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugSphere >*
DebugDraw::mutable_spheres() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.DebugDraw.spheres)
  return &spheres_;
}
inline const ::SCRAPIProtocol::DebugSphere& DebugDraw::spheres(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugDraw.spheres)
  return spheres_.Get(index);
}
inline ::SCRAPIProtocol::DebugSphere* DebugDraw::add_spheres() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.DebugDraw.spheres)
  return spheres_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugSphere >&
DebugDraw::spheres() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.DebugDraw.spheres)
  return spheres_;
}

// -------------------------------------------------------------------

// Line

// optional .SCRAPIProtocol.Point p0 = 1;
inline bool Line::has_p0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Line::set_has_p0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Line::clear_has_p0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::Point& Line::_internal_p0() const {
  return *p0_;
}
inline const ::SCRAPIProtocol::Point& Line::p0() const {
  const ::SCRAPIProtocol::Point* p = p0_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Line.p0)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* Line::release_p0() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Line.p0)
  clear_has_p0();
  ::SCRAPIProtocol::Point* temp = p0_;
  p0_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* Line::mutable_p0() {
  set_has_p0();
  if (p0_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    p0_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Line.p0)
  return p0_;
}
inline void Line::set_allocated_p0(::SCRAPIProtocol::Point* p0) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(p0_);
  }
  if (p0) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      p0 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, p0, submessage_arena);
    }
    set_has_p0();
  } else {
    clear_has_p0();
  }
  p0_ = p0;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Line.p0)
}

// optional .SCRAPIProtocol.Point p1 = 2;
inline bool Line::has_p1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Line::set_has_p1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Line::clear_has_p1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::Point& Line::_internal_p1() const {
  return *p1_;
}
inline const ::SCRAPIProtocol::Point& Line::p1() const {
  const ::SCRAPIProtocol::Point* p = p1_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Line.p1)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* Line::release_p1() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Line.p1)
  clear_has_p1();
  ::SCRAPIProtocol::Point* temp = p1_;
  p1_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* Line::mutable_p1() {
  set_has_p1();
  if (p1_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    p1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Line.p1)
  return p1_;
}
inline void Line::set_allocated_p1(::SCRAPIProtocol::Point* p1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(p1_);
  }
  if (p1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      p1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, p1, submessage_arena);
    }
    set_has_p1();
  } else {
    clear_has_p1();
  }
  p1_ = p1;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Line.p1)
}

// -------------------------------------------------------------------

// Color

// optional uint32 r = 1;
inline bool Color::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Color::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Color::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Color::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 Color::r() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Color.r)
  return r_;
}
inline void Color::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Color.r)
}

// optional uint32 g = 2;
inline bool Color::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Color::set_has_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Color::clear_has_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Color::clear_g() {
  g_ = 0u;
  clear_has_g();
}
inline ::google::protobuf::uint32 Color::g() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Color.g)
  return g_;
}
inline void Color::set_g(::google::protobuf::uint32 value) {
  set_has_g();
  g_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Color.g)
}

// optional uint32 b = 3;
inline bool Color::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Color::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Color::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Color::clear_b() {
  b_ = 0u;
  clear_has_b();
}
inline ::google::protobuf::uint32 Color::b() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Color.b)
  return b_;
}
inline void Color::set_b(::google::protobuf::uint32 value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Color.b)
}

// -------------------------------------------------------------------

// DebugText

// optional .SCRAPIProtocol.Color color = 1;
inline bool DebugText::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugText::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugText::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugText::clear_color() {
  if (color_ != NULL) color_->Clear();
  clear_has_color();
}
inline const ::SCRAPIProtocol::Color& DebugText::_internal_color() const {
  return *color_;
}
inline const ::SCRAPIProtocol::Color& DebugText::color() const {
  const ::SCRAPIProtocol::Color* p = color_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugText.color)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Color*>(
      &::SCRAPIProtocol::_Color_default_instance_);
}
inline ::SCRAPIProtocol::Color* DebugText::release_color() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugText.color)
  clear_has_color();
  ::SCRAPIProtocol::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Color* DebugText::mutable_color() {
  set_has_color();
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugText.color)
  return color_;
}
inline void DebugText::set_allocated_color(::SCRAPIProtocol::Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    set_has_color();
  } else {
    clear_has_color();
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugText.color)
}

// optional string text = 2;
inline bool DebugText::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugText::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugText::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugText::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& DebugText::text() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugText.text)
  return text_.GetNoArena();
}
inline void DebugText::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugText.text)
}
#if LANG_CXX11
inline void DebugText::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.DebugText.text)
}
#endif
inline void DebugText::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.DebugText.text)
}
inline void DebugText::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.DebugText.text)
}
inline ::std::string* DebugText::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugText.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugText::release_text() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugText.text)
  if (!has_text()) {
    return NULL;
  }
  clear_has_text();
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugText::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugText.text)
}

// optional .SCRAPIProtocol.Point virtual_pos = 3;
inline bool DebugText::has_virtual_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugText::set_has_virtual_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugText::clear_has_virtual_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SCRAPIProtocol::Point& DebugText::_internal_virtual_pos() const {
  return *virtual_pos_;
}
inline const ::SCRAPIProtocol::Point& DebugText::virtual_pos() const {
  const ::SCRAPIProtocol::Point* p = virtual_pos_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugText.virtual_pos)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* DebugText::release_virtual_pos() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugText.virtual_pos)
  clear_has_virtual_pos();
  ::SCRAPIProtocol::Point* temp = virtual_pos_;
  virtual_pos_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* DebugText::mutable_virtual_pos() {
  set_has_virtual_pos();
  if (virtual_pos_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    virtual_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugText.virtual_pos)
  return virtual_pos_;
}
inline void DebugText::set_allocated_virtual_pos(::SCRAPIProtocol::Point* virtual_pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(virtual_pos_);
  }
  if (virtual_pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      virtual_pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, virtual_pos, submessage_arena);
    }
    set_has_virtual_pos();
  } else {
    clear_has_virtual_pos();
  }
  virtual_pos_ = virtual_pos;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugText.virtual_pos)
}

// optional .SCRAPIProtocol.Point world_pos = 4;
inline bool DebugText::has_world_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugText::set_has_world_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DebugText::clear_has_world_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::SCRAPIProtocol::Point& DebugText::_internal_world_pos() const {
  return *world_pos_;
}
inline const ::SCRAPIProtocol::Point& DebugText::world_pos() const {
  const ::SCRAPIProtocol::Point* p = world_pos_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugText.world_pos)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* DebugText::release_world_pos() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugText.world_pos)
  clear_has_world_pos();
  ::SCRAPIProtocol::Point* temp = world_pos_;
  world_pos_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* DebugText::mutable_world_pos() {
  set_has_world_pos();
  if (world_pos_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    world_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugText.world_pos)
  return world_pos_;
}
inline void DebugText::set_allocated_world_pos(::SCRAPIProtocol::Point* world_pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(world_pos_);
  }
  if (world_pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_pos, submessage_arena);
    }
    set_has_world_pos();
  } else {
    clear_has_world_pos();
  }
  world_pos_ = world_pos;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugText.world_pos)
}

// optional uint32 size = 5;
inline bool DebugText::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugText::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DebugText::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DebugText::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 DebugText::size() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugText.size)
  return size_;
}
inline void DebugText::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugText.size)
}

// -------------------------------------------------------------------

// DebugLine

// optional .SCRAPIProtocol.Color color = 1;
inline bool DebugLine::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLine::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLine::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLine::clear_color() {
  if (color_ != NULL) color_->Clear();
  clear_has_color();
}
inline const ::SCRAPIProtocol::Color& DebugLine::_internal_color() const {
  return *color_;
}
inline const ::SCRAPIProtocol::Color& DebugLine::color() const {
  const ::SCRAPIProtocol::Color* p = color_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugLine.color)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Color*>(
      &::SCRAPIProtocol::_Color_default_instance_);
}
inline ::SCRAPIProtocol::Color* DebugLine::release_color() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugLine.color)
  clear_has_color();
  ::SCRAPIProtocol::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Color* DebugLine::mutable_color() {
  set_has_color();
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugLine.color)
  return color_;
}
inline void DebugLine::set_allocated_color(::SCRAPIProtocol::Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    set_has_color();
  } else {
    clear_has_color();
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugLine.color)
}

// optional .SCRAPIProtocol.Line line = 2;
inline bool DebugLine::has_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLine::set_has_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLine::clear_has_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLine::clear_line() {
  if (line_ != NULL) line_->Clear();
  clear_has_line();
}
inline const ::SCRAPIProtocol::Line& DebugLine::_internal_line() const {
  return *line_;
}
inline const ::SCRAPIProtocol::Line& DebugLine::line() const {
  const ::SCRAPIProtocol::Line* p = line_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugLine.line)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Line*>(
      &::SCRAPIProtocol::_Line_default_instance_);
}
inline ::SCRAPIProtocol::Line* DebugLine::release_line() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugLine.line)
  clear_has_line();
  ::SCRAPIProtocol::Line* temp = line_;
  line_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Line* DebugLine::mutable_line() {
  set_has_line();
  if (line_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Line>(GetArenaNoVirtual());
    line_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugLine.line)
  return line_;
}
inline void DebugLine::set_allocated_line(::SCRAPIProtocol::Line* line) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete line_;
  }
  if (line) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      line = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, line, submessage_arena);
    }
    set_has_line();
  } else {
    clear_has_line();
  }
  line_ = line;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugLine.line)
}

// -------------------------------------------------------------------

// DebugBox

// optional .SCRAPIProtocol.Color color = 1;
inline bool DebugBox::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugBox::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugBox::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugBox::clear_color() {
  if (color_ != NULL) color_->Clear();
  clear_has_color();
}
inline const ::SCRAPIProtocol::Color& DebugBox::_internal_color() const {
  return *color_;
}
inline const ::SCRAPIProtocol::Color& DebugBox::color() const {
  const ::SCRAPIProtocol::Color* p = color_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugBox.color)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Color*>(
      &::SCRAPIProtocol::_Color_default_instance_);
}
inline ::SCRAPIProtocol::Color* DebugBox::release_color() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugBox.color)
  clear_has_color();
  ::SCRAPIProtocol::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Color* DebugBox::mutable_color() {
  set_has_color();
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugBox.color)
  return color_;
}
inline void DebugBox::set_allocated_color(::SCRAPIProtocol::Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    set_has_color();
  } else {
    clear_has_color();
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugBox.color)
}

// optional .SCRAPIProtocol.Point min = 2;
inline bool DebugBox::has_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugBox::set_has_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugBox::clear_has_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::Point& DebugBox::_internal_min() const {
  return *min_;
}
inline const ::SCRAPIProtocol::Point& DebugBox::min() const {
  const ::SCRAPIProtocol::Point* p = min_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugBox.min)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* DebugBox::release_min() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugBox.min)
  clear_has_min();
  ::SCRAPIProtocol::Point* temp = min_;
  min_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* DebugBox::mutable_min() {
  set_has_min();
  if (min_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    min_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugBox.min)
  return min_;
}
inline void DebugBox::set_allocated_min(::SCRAPIProtocol::Point* min) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(min_);
  }
  if (min) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      min = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min, submessage_arena);
    }
    set_has_min();
  } else {
    clear_has_min();
  }
  min_ = min;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugBox.min)
}

// optional .SCRAPIProtocol.Point max = 3;
inline bool DebugBox::has_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugBox::set_has_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugBox::clear_has_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SCRAPIProtocol::Point& DebugBox::_internal_max() const {
  return *max_;
}
inline const ::SCRAPIProtocol::Point& DebugBox::max() const {
  const ::SCRAPIProtocol::Point* p = max_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugBox.max)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* DebugBox::release_max() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugBox.max)
  clear_has_max();
  ::SCRAPIProtocol::Point* temp = max_;
  max_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* DebugBox::mutable_max() {
  set_has_max();
  if (max_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    max_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugBox.max)
  return max_;
}
inline void DebugBox::set_allocated_max(::SCRAPIProtocol::Point* max) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(max_);
  }
  if (max) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      max = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, max, submessage_arena);
    }
    set_has_max();
  } else {
    clear_has_max();
  }
  max_ = max;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugBox.max)
}

// -------------------------------------------------------------------

// DebugSphere

// optional .SCRAPIProtocol.Color color = 1;
inline bool DebugSphere::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugSphere::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugSphere::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugSphere::clear_color() {
  if (color_ != NULL) color_->Clear();
  clear_has_color();
}
inline const ::SCRAPIProtocol::Color& DebugSphere::_internal_color() const {
  return *color_;
}
inline const ::SCRAPIProtocol::Color& DebugSphere::color() const {
  const ::SCRAPIProtocol::Color* p = color_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugSphere.color)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Color*>(
      &::SCRAPIProtocol::_Color_default_instance_);
}
inline ::SCRAPIProtocol::Color* DebugSphere::release_color() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugSphere.color)
  clear_has_color();
  ::SCRAPIProtocol::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Color* DebugSphere::mutable_color() {
  set_has_color();
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugSphere.color)
  return color_;
}
inline void DebugSphere::set_allocated_color(::SCRAPIProtocol::Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    set_has_color();
  } else {
    clear_has_color();
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugSphere.color)
}

// optional .SCRAPIProtocol.Point p = 2;
inline bool DebugSphere::has_p() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugSphere::set_has_p() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugSphere::clear_has_p() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::Point& DebugSphere::_internal_p() const {
  return *p_;
}
inline const ::SCRAPIProtocol::Point& DebugSphere::p() const {
  const ::SCRAPIProtocol::Point* p = p_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugSphere.p)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* DebugSphere::release_p() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugSphere.p)
  clear_has_p();
  ::SCRAPIProtocol::Point* temp = p_;
  p_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* DebugSphere::mutable_p() {
  set_has_p();
  if (p_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    p_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugSphere.p)
  return p_;
}
inline void DebugSphere::set_allocated_p(::SCRAPIProtocol::Point* p) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(p_);
  }
  if (p) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      p = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, p, submessage_arena);
    }
    set_has_p();
  } else {
    clear_has_p();
  }
  p_ = p;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugSphere.p)
}

// optional float r = 3;
inline bool DebugSphere::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugSphere::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugSphere::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugSphere::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline float DebugSphere::r() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugSphere.r)
  return r_;
}
inline void DebugSphere::set_r(float value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugSphere.r)
}

// -------------------------------------------------------------------

// DebugCreateUnit

// optional uint32 unit_type = 1;
inline bool DebugCreateUnit::has_unit_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugCreateUnit::set_has_unit_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugCreateUnit::clear_has_unit_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugCreateUnit::clear_unit_type() {
  unit_type_ = 0u;
  clear_has_unit_type();
}
inline ::google::protobuf::uint32 DebugCreateUnit::unit_type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCreateUnit.unit_type)
  return unit_type_;
}
inline void DebugCreateUnit::set_unit_type(::google::protobuf::uint32 value) {
  set_has_unit_type();
  unit_type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugCreateUnit.unit_type)
}

// optional int32 owner = 2;
inline bool DebugCreateUnit::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugCreateUnit::set_has_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugCreateUnit::clear_has_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugCreateUnit::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 DebugCreateUnit::owner() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCreateUnit.owner)
  return owner_;
}
inline void DebugCreateUnit::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugCreateUnit.owner)
}

// optional .SCRAPIProtocol.Point2D pos = 3;
inline bool DebugCreateUnit::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugCreateUnit::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugCreateUnit::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::Point2D& DebugCreateUnit::_internal_pos() const {
  return *pos_;
}
inline const ::SCRAPIProtocol::Point2D& DebugCreateUnit::pos() const {
  const ::SCRAPIProtocol::Point2D* p = pos_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCreateUnit.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point2D*>(
      &::SCRAPIProtocol::_Point2D_default_instance_);
}
inline ::SCRAPIProtocol::Point2D* DebugCreateUnit::release_pos() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.DebugCreateUnit.pos)
  clear_has_pos();
  ::SCRAPIProtocol::Point2D* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point2D* DebugCreateUnit::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point2D>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.DebugCreateUnit.pos)
  return pos_;
}
inline void DebugCreateUnit::set_allocated_pos(::SCRAPIProtocol::Point2D* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.DebugCreateUnit.pos)
}

// optional uint32 quantity = 4;
inline bool DebugCreateUnit::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugCreateUnit::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DebugCreateUnit::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DebugCreateUnit::clear_quantity() {
  quantity_ = 0u;
  clear_has_quantity();
}
inline ::google::protobuf::uint32 DebugCreateUnit::quantity() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugCreateUnit.quantity)
  return quantity_;
}
inline void DebugCreateUnit::set_quantity(::google::protobuf::uint32 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugCreateUnit.quantity)
}

// -------------------------------------------------------------------

// DebugKillUnit

// repeated uint64 tag = 1;
inline int DebugKillUnit::tag_size() const {
  return tag_.size();
}
inline void DebugKillUnit::clear_tag() {
  tag_.Clear();
}
inline ::google::protobuf::uint64 DebugKillUnit::tag(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugKillUnit.tag)
  return tag_.Get(index);
}
inline void DebugKillUnit::set_tag(int index, ::google::protobuf::uint64 value) {
  tag_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugKillUnit.tag)
}
inline void DebugKillUnit::add_tag(::google::protobuf::uint64 value) {
  tag_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.DebugKillUnit.tag)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DebugKillUnit::tag() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.DebugKillUnit.tag)
  return tag_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DebugKillUnit::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.DebugKillUnit.tag)
  return &tag_;
}

// -------------------------------------------------------------------

// DebugTestProcess

// optional .SCRAPIProtocol.DebugTestProcess.Test test = 1;
inline bool DebugTestProcess::has_test() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugTestProcess::set_has_test() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugTestProcess::clear_has_test() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugTestProcess::clear_test() {
  test_ = 1;
  clear_has_test();
}
inline ::SCRAPIProtocol::DebugTestProcess_Test DebugTestProcess::test() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugTestProcess.test)
  return static_cast< ::SCRAPIProtocol::DebugTestProcess_Test >(test_);
}
inline void DebugTestProcess::set_test(::SCRAPIProtocol::DebugTestProcess_Test value) {
  assert(::SCRAPIProtocol::DebugTestProcess_Test_IsValid(value));
  set_has_test();
  test_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugTestProcess.test)
}

// optional int32 delay_ms = 2;
inline bool DebugTestProcess::has_delay_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugTestProcess::set_has_delay_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugTestProcess::clear_has_delay_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugTestProcess::clear_delay_ms() {
  delay_ms_ = 0;
  clear_has_delay_ms();
}
inline ::google::protobuf::int32 DebugTestProcess::delay_ms() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugTestProcess.delay_ms)
  return delay_ms_;
}
inline void DebugTestProcess::set_delay_ms(::google::protobuf::int32 value) {
  set_has_delay_ms();
  delay_ms_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugTestProcess.delay_ms)
}

// -------------------------------------------------------------------

// DebugSetScore

// optional float score = 1;
inline bool DebugSetScore::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugSetScore::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugSetScore::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugSetScore::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float DebugSetScore::score() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugSetScore.score)
  return score_;
}
inline void DebugSetScore::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugSetScore.score)
}

// -------------------------------------------------------------------

// DebugEndGame

// optional .SCRAPIProtocol.DebugEndGame.EndResult end_result = 1;
inline bool DebugEndGame::has_end_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugEndGame::set_has_end_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugEndGame::clear_has_end_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugEndGame::clear_end_result() {
  end_result_ = 1;
  clear_has_end_result();
}
inline ::SCRAPIProtocol::DebugEndGame_EndResult DebugEndGame::end_result() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugEndGame.end_result)
  return static_cast< ::SCRAPIProtocol::DebugEndGame_EndResult >(end_result_);
}
inline void DebugEndGame::set_end_result(::SCRAPIProtocol::DebugEndGame_EndResult value) {
  assert(::SCRAPIProtocol::DebugEndGame_EndResult_IsValid(value));
  set_has_end_result();
  end_result_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugEndGame.end_result)
}

// -------------------------------------------------------------------

// DebugSetUnitValue

// optional .SCRAPIProtocol.DebugSetUnitValue.UnitValue unit_value = 1;
inline bool DebugSetUnitValue::has_unit_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugSetUnitValue::set_has_unit_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugSetUnitValue::clear_has_unit_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugSetUnitValue::clear_unit_value() {
  unit_value_ = 1;
  clear_has_unit_value();
}
inline ::SCRAPIProtocol::DebugSetUnitValue_UnitValue DebugSetUnitValue::unit_value() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugSetUnitValue.unit_value)
  return static_cast< ::SCRAPIProtocol::DebugSetUnitValue_UnitValue >(unit_value_);
}
inline void DebugSetUnitValue::set_unit_value(::SCRAPIProtocol::DebugSetUnitValue_UnitValue value) {
  assert(::SCRAPIProtocol::DebugSetUnitValue_UnitValue_IsValid(value));
  set_has_unit_value();
  unit_value_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugSetUnitValue.unit_value)
}

// optional float value = 2;
inline bool DebugSetUnitValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugSetUnitValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugSetUnitValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugSetUnitValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float DebugSetUnitValue::value() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugSetUnitValue.value)
  return value_;
}
inline void DebugSetUnitValue::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugSetUnitValue.value)
}

// optional uint64 unit_tag = 3;
inline bool DebugSetUnitValue::has_unit_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugSetUnitValue::set_has_unit_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugSetUnitValue::clear_has_unit_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugSetUnitValue::clear_unit_tag() {
  unit_tag_ = GOOGLE_ULONGLONG(0);
  clear_has_unit_tag();
}
inline ::google::protobuf::uint64 DebugSetUnitValue::unit_tag() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.DebugSetUnitValue.unit_tag)
  return unit_tag_;
}
inline void DebugSetUnitValue::set_unit_tag(::google::protobuf::uint64 value) {
  set_has_unit_tag();
  unit_tag_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.DebugSetUnitValue.unit_tag)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SCRAPIProtocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SCRAPIProtocol::DebugTestProcess_Test> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::DebugTestProcess_Test>() {
  return ::SCRAPIProtocol::DebugTestProcess_Test_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::DebugEndGame_EndResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::DebugEndGame_EndResult>() {
  return ::SCRAPIProtocol::DebugEndGame_EndResult_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::DebugSetUnitValue_UnitValue> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::DebugSetUnitValue_UnitValue>() {
  return ::SCRAPIProtocol::DebugSetUnitValue_UnitValue_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::DebugGameState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::DebugGameState>() {
  return ::SCRAPIProtocol::DebugGameState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_debug_2eproto
