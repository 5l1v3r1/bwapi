// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raw.proto

#ifndef PROTOBUF_INCLUDED_raw_2eproto
#define PROTOBUF_INCLUDED_raw_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_raw_2eproto 

namespace protobuf_raw_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_raw_2eproto
namespace SCRAPIProtocol {
class ActionRaw;
class ActionRawDefaultTypeInternal;
extern ActionRawDefaultTypeInternal _ActionRaw_default_instance_;
class ActionRawCameraMove;
class ActionRawCameraMoveDefaultTypeInternal;
extern ActionRawCameraMoveDefaultTypeInternal _ActionRawCameraMove_default_instance_;
class ActionRawToggleAutocast;
class ActionRawToggleAutocastDefaultTypeInternal;
extern ActionRawToggleAutocastDefaultTypeInternal _ActionRawToggleAutocast_default_instance_;
class ActionRawUnitCommand;
class ActionRawUnitCommandDefaultTypeInternal;
extern ActionRawUnitCommandDefaultTypeInternal _ActionRawUnitCommand_default_instance_;
class Effect;
class EffectDefaultTypeInternal;
extern EffectDefaultTypeInternal _Effect_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class MapState;
class MapStateDefaultTypeInternal;
extern MapStateDefaultTypeInternal _MapState_default_instance_;
class ObservationRaw;
class ObservationRawDefaultTypeInternal;
extern ObservationRawDefaultTypeInternal _ObservationRaw_default_instance_;
class PassengerUnit;
class PassengerUnitDefaultTypeInternal;
extern PassengerUnitDefaultTypeInternal _PassengerUnit_default_instance_;
class PlayerRaw;
class PlayerRawDefaultTypeInternal;
extern PlayerRawDefaultTypeInternal _PlayerRaw_default_instance_;
class PowerSource;
class PowerSourceDefaultTypeInternal;
extern PowerSourceDefaultTypeInternal _PowerSource_default_instance_;
class StartRaw;
class StartRawDefaultTypeInternal;
extern StartRawDefaultTypeInternal _StartRaw_default_instance_;
class Unit;
class UnitDefaultTypeInternal;
extern UnitDefaultTypeInternal _Unit_default_instance_;
class UnitOrder;
class UnitOrderDefaultTypeInternal;
extern UnitOrderDefaultTypeInternal _UnitOrder_default_instance_;
}  // namespace SCRAPIProtocol
namespace google {
namespace protobuf {
template<> ::SCRAPIProtocol::ActionRaw* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionRaw>(Arena*);
template<> ::SCRAPIProtocol::ActionRawCameraMove* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionRawCameraMove>(Arena*);
template<> ::SCRAPIProtocol::ActionRawToggleAutocast* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionRawToggleAutocast>(Arena*);
template<> ::SCRAPIProtocol::ActionRawUnitCommand* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionRawUnitCommand>(Arena*);
template<> ::SCRAPIProtocol::Effect* Arena::CreateMaybeMessage<::SCRAPIProtocol::Effect>(Arena*);
template<> ::SCRAPIProtocol::Event* Arena::CreateMaybeMessage<::SCRAPIProtocol::Event>(Arena*);
template<> ::SCRAPIProtocol::MapState* Arena::CreateMaybeMessage<::SCRAPIProtocol::MapState>(Arena*);
template<> ::SCRAPIProtocol::ObservationRaw* Arena::CreateMaybeMessage<::SCRAPIProtocol::ObservationRaw>(Arena*);
template<> ::SCRAPIProtocol::PassengerUnit* Arena::CreateMaybeMessage<::SCRAPIProtocol::PassengerUnit>(Arena*);
template<> ::SCRAPIProtocol::PlayerRaw* Arena::CreateMaybeMessage<::SCRAPIProtocol::PlayerRaw>(Arena*);
template<> ::SCRAPIProtocol::PowerSource* Arena::CreateMaybeMessage<::SCRAPIProtocol::PowerSource>(Arena*);
template<> ::SCRAPIProtocol::StartRaw* Arena::CreateMaybeMessage<::SCRAPIProtocol::StartRaw>(Arena*);
template<> ::SCRAPIProtocol::Unit* Arena::CreateMaybeMessage<::SCRAPIProtocol::Unit>(Arena*);
template<> ::SCRAPIProtocol::UnitOrder* Arena::CreateMaybeMessage<::SCRAPIProtocol::UnitOrder>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace SCRAPIProtocol {

enum DisplayType {
  Visible = 1,
  Snapshot = 2,
  Hidden = 3
};
bool DisplayType_IsValid(int value);
const DisplayType DisplayType_MIN = Visible;
const DisplayType DisplayType_MAX = Hidden;
const int DisplayType_ARRAYSIZE = DisplayType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DisplayType_descriptor();
inline const ::std::string& DisplayType_Name(DisplayType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DisplayType_descriptor(), value);
}
inline bool DisplayType_Parse(
    const ::std::string& name, DisplayType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplayType>(
    DisplayType_descriptor(), name, value);
}
enum Alliance {
  Self = 1,
  Ally = 2,
  Neutral = 3,
  Enemy = 4
};
bool Alliance_IsValid(int value);
const Alliance Alliance_MIN = Self;
const Alliance Alliance_MAX = Enemy;
const int Alliance_ARRAYSIZE = Alliance_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alliance_descriptor();
inline const ::std::string& Alliance_Name(Alliance value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alliance_descriptor(), value);
}
inline bool Alliance_Parse(
    const ::std::string& name, Alliance* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alliance>(
    Alliance_descriptor(), name, value);
}
enum CloakState {
  Cloaked = 1,
  CloakedDetected = 2,
  NotCloaked = 3
};
bool CloakState_IsValid(int value);
const CloakState CloakState_MIN = Cloaked;
const CloakState CloakState_MAX = NotCloaked;
const int CloakState_ARRAYSIZE = CloakState_MAX + 1;

const ::google::protobuf::EnumDescriptor* CloakState_descriptor();
inline const ::std::string& CloakState_Name(CloakState value) {
  return ::google::protobuf::internal::NameOfEnum(
    CloakState_descriptor(), value);
}
inline bool CloakState_Parse(
    const ::std::string& name, CloakState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CloakState>(
    CloakState_descriptor(), name, value);
}
// ===================================================================

class StartRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.StartRaw) */ {
 public:
  StartRaw();
  virtual ~StartRaw();

  StartRaw(const StartRaw& from);

  inline StartRaw& operator=(const StartRaw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartRaw(StartRaw&& from) noexcept
    : StartRaw() {
    *this = ::std::move(from);
  }

  inline StartRaw& operator=(StartRaw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartRaw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartRaw* internal_default_instance() {
    return reinterpret_cast<const StartRaw*>(
               &_StartRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(StartRaw* other);
  friend void swap(StartRaw& a, StartRaw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartRaw* New() const final {
    return CreateMaybeMessage<StartRaw>(NULL);
  }

  StartRaw* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartRaw>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartRaw& from);
  void MergeFrom(const StartRaw& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.Point2D start_locations = 6;
  int start_locations_size() const;
  void clear_start_locations();
  static const int kStartLocationsFieldNumber = 6;
  ::SCRAPIProtocol::Point2D* mutable_start_locations(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Point2D >*
      mutable_start_locations();
  const ::SCRAPIProtocol::Point2D& start_locations(int index) const;
  ::SCRAPIProtocol::Point2D* add_start_locations();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Point2D >&
      start_locations() const;

  // optional .SCRAPIProtocol.Size2DI map_size = 1;
  bool has_map_size() const;
  void clear_map_size();
  static const int kMapSizeFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::Size2DI& _internal_map_size() const;
  public:
  const ::SCRAPIProtocol::Size2DI& map_size() const;
  ::SCRAPIProtocol::Size2DI* release_map_size();
  ::SCRAPIProtocol::Size2DI* mutable_map_size();
  void set_allocated_map_size(::SCRAPIProtocol::Size2DI* map_size);

  // optional .SCRAPIProtocol.ImageData pathing_grid = 2;
  bool has_pathing_grid() const;
  void clear_pathing_grid();
  static const int kPathingGridFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_pathing_grid() const;
  public:
  const ::SCRAPIProtocol::ImageData& pathing_grid() const;
  ::SCRAPIProtocol::ImageData* release_pathing_grid();
  ::SCRAPIProtocol::ImageData* mutable_pathing_grid();
  void set_allocated_pathing_grid(::SCRAPIProtocol::ImageData* pathing_grid);

  // optional .SCRAPIProtocol.ImageData terrain_height = 3;
  bool has_terrain_height() const;
  void clear_terrain_height();
  static const int kTerrainHeightFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_terrain_height() const;
  public:
  const ::SCRAPIProtocol::ImageData& terrain_height() const;
  ::SCRAPIProtocol::ImageData* release_terrain_height();
  ::SCRAPIProtocol::ImageData* mutable_terrain_height();
  void set_allocated_terrain_height(::SCRAPIProtocol::ImageData* terrain_height);

  // optional .SCRAPIProtocol.ImageData placement_grid = 4;
  bool has_placement_grid() const;
  void clear_placement_grid();
  static const int kPlacementGridFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_placement_grid() const;
  public:
  const ::SCRAPIProtocol::ImageData& placement_grid() const;
  ::SCRAPIProtocol::ImageData* release_placement_grid();
  ::SCRAPIProtocol::ImageData* mutable_placement_grid();
  void set_allocated_placement_grid(::SCRAPIProtocol::ImageData* placement_grid);

  // optional .SCRAPIProtocol.RectangleI playable_area = 5;
  bool has_playable_area() const;
  void clear_playable_area();
  static const int kPlayableAreaFieldNumber = 5;
  private:
  const ::SCRAPIProtocol::RectangleI& _internal_playable_area() const;
  public:
  const ::SCRAPIProtocol::RectangleI& playable_area() const;
  ::SCRAPIProtocol::RectangleI* release_playable_area();
  ::SCRAPIProtocol::RectangleI* mutable_playable_area();
  void set_allocated_playable_area(::SCRAPIProtocol::RectangleI* playable_area);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.StartRaw)
 private:
  void set_has_map_size();
  void clear_has_map_size();
  void set_has_pathing_grid();
  void clear_has_pathing_grid();
  void set_has_terrain_height();
  void clear_has_terrain_height();
  void set_has_placement_grid();
  void clear_has_placement_grid();
  void set_has_playable_area();
  void clear_has_playable_area();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Point2D > start_locations_;
  ::SCRAPIProtocol::Size2DI* map_size_;
  ::SCRAPIProtocol::ImageData* pathing_grid_;
  ::SCRAPIProtocol::ImageData* terrain_height_;
  ::SCRAPIProtocol::ImageData* placement_grid_;
  ::SCRAPIProtocol::RectangleI* playable_area_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObservationRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ObservationRaw) */ {
 public:
  ObservationRaw();
  virtual ~ObservationRaw();

  ObservationRaw(const ObservationRaw& from);

  inline ObservationRaw& operator=(const ObservationRaw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObservationRaw(ObservationRaw&& from) noexcept
    : ObservationRaw() {
    *this = ::std::move(from);
  }

  inline ObservationRaw& operator=(ObservationRaw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObservationRaw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObservationRaw* internal_default_instance() {
    return reinterpret_cast<const ObservationRaw*>(
               &_ObservationRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ObservationRaw* other);
  friend void swap(ObservationRaw& a, ObservationRaw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObservationRaw* New() const final {
    return CreateMaybeMessage<ObservationRaw>(NULL);
  }

  ObservationRaw* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObservationRaw>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObservationRaw& from);
  void MergeFrom(const ObservationRaw& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObservationRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.Unit units = 2;
  int units_size() const;
  void clear_units();
  static const int kUnitsFieldNumber = 2;
  ::SCRAPIProtocol::Unit* mutable_units(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Unit >*
      mutable_units();
  const ::SCRAPIProtocol::Unit& units(int index) const;
  ::SCRAPIProtocol::Unit* add_units();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Unit >&
      units() const;

  // repeated .SCRAPIProtocol.Effect effects = 5;
  int effects_size() const;
  void clear_effects();
  static const int kEffectsFieldNumber = 5;
  ::SCRAPIProtocol::Effect* mutable_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Effect >*
      mutable_effects();
  const ::SCRAPIProtocol::Effect& effects(int index) const;
  ::SCRAPIProtocol::Effect* add_effects();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Effect >&
      effects() const;

  // optional .SCRAPIProtocol.PlayerRaw player = 1;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::PlayerRaw& _internal_player() const;
  public:
  const ::SCRAPIProtocol::PlayerRaw& player() const;
  ::SCRAPIProtocol::PlayerRaw* release_player();
  ::SCRAPIProtocol::PlayerRaw* mutable_player();
  void set_allocated_player(::SCRAPIProtocol::PlayerRaw* player);

  // optional .SCRAPIProtocol.MapState map_state = 3;
  bool has_map_state() const;
  void clear_map_state();
  static const int kMapStateFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::MapState& _internal_map_state() const;
  public:
  const ::SCRAPIProtocol::MapState& map_state() const;
  ::SCRAPIProtocol::MapState* release_map_state();
  ::SCRAPIProtocol::MapState* mutable_map_state();
  void set_allocated_map_state(::SCRAPIProtocol::MapState* map_state);

  // optional .SCRAPIProtocol.Event event = 4;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::Event& _internal_event() const;
  public:
  const ::SCRAPIProtocol::Event& event() const;
  ::SCRAPIProtocol::Event* release_event();
  ::SCRAPIProtocol::Event* mutable_event();
  void set_allocated_event(::SCRAPIProtocol::Event* event);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ObservationRaw)
 private:
  void set_has_player();
  void clear_has_player();
  void set_has_map_state();
  void clear_has_map_state();
  void set_has_event();
  void clear_has_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Unit > units_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Effect > effects_;
  ::SCRAPIProtocol::PlayerRaw* player_;
  ::SCRAPIProtocol::MapState* map_state_;
  ::SCRAPIProtocol::Event* event_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PowerSource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.PowerSource) */ {
 public:
  PowerSource();
  virtual ~PowerSource();

  PowerSource(const PowerSource& from);

  inline PowerSource& operator=(const PowerSource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PowerSource(PowerSource&& from) noexcept
    : PowerSource() {
    *this = ::std::move(from);
  }

  inline PowerSource& operator=(PowerSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PowerSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowerSource* internal_default_instance() {
    return reinterpret_cast<const PowerSource*>(
               &_PowerSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PowerSource* other);
  friend void swap(PowerSource& a, PowerSource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PowerSource* New() const final {
    return CreateMaybeMessage<PowerSource>(NULL);
  }

  PowerSource* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PowerSource>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PowerSource& from);
  void MergeFrom(const PowerSource& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.Point pos = 1;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::Point& _internal_pos() const;
  public:
  const ::SCRAPIProtocol::Point& pos() const;
  ::SCRAPIProtocol::Point* release_pos();
  ::SCRAPIProtocol::Point* mutable_pos();
  void set_allocated_pos(::SCRAPIProtocol::Point* pos);

  // optional uint64 tag = 3;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 3;
  ::google::protobuf::uint64 tag() const;
  void set_tag(::google::protobuf::uint64 value);

  // optional float radius = 2;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 2;
  float radius() const;
  void set_radius(float value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.PowerSource)
 private:
  void set_has_pos();
  void clear_has_pos();
  void set_has_radius();
  void clear_has_radius();
  void set_has_tag();
  void clear_has_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::Point* pos_;
  ::google::protobuf::uint64 tag_;
  float radius_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.PlayerRaw) */ {
 public:
  PlayerRaw();
  virtual ~PlayerRaw();

  PlayerRaw(const PlayerRaw& from);

  inline PlayerRaw& operator=(const PlayerRaw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerRaw(PlayerRaw&& from) noexcept
    : PlayerRaw() {
    *this = ::std::move(from);
  }

  inline PlayerRaw& operator=(PlayerRaw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerRaw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerRaw* internal_default_instance() {
    return reinterpret_cast<const PlayerRaw*>(
               &_PlayerRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PlayerRaw* other);
  friend void swap(PlayerRaw& a, PlayerRaw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerRaw* New() const final {
    return CreateMaybeMessage<PlayerRaw>(NULL);
  }

  PlayerRaw* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerRaw>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerRaw& from);
  void MergeFrom(const PlayerRaw& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.PowerSource power_sources = 1;
  int power_sources_size() const;
  void clear_power_sources();
  static const int kPowerSourcesFieldNumber = 1;
  ::SCRAPIProtocol::PowerSource* mutable_power_sources(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PowerSource >*
      mutable_power_sources();
  const ::SCRAPIProtocol::PowerSource& power_sources(int index) const;
  ::SCRAPIProtocol::PowerSource* add_power_sources();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PowerSource >&
      power_sources() const;

  // repeated uint32 upgrade_ids = 3;
  int upgrade_ids_size() const;
  void clear_upgrade_ids();
  static const int kUpgradeIdsFieldNumber = 3;
  ::google::protobuf::uint32 upgrade_ids(int index) const;
  void set_upgrade_ids(int index, ::google::protobuf::uint32 value);
  void add_upgrade_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      upgrade_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_upgrade_ids();

  // optional .SCRAPIProtocol.Point camera = 2;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::Point& _internal_camera() const;
  public:
  const ::SCRAPIProtocol::Point& camera() const;
  ::SCRAPIProtocol::Point* release_camera();
  ::SCRAPIProtocol::Point* mutable_camera();
  void set_allocated_camera(::SCRAPIProtocol::Point* camera);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.PlayerRaw)
 private:
  void set_has_camera();
  void clear_has_camera();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PowerSource > power_sources_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > upgrade_ids_;
  ::SCRAPIProtocol::Point* camera_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.UnitOrder) */ {
 public:
  UnitOrder();
  virtual ~UnitOrder();

  UnitOrder(const UnitOrder& from);

  inline UnitOrder& operator=(const UnitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitOrder(UnitOrder&& from) noexcept
    : UnitOrder() {
    *this = ::std::move(from);
  }

  inline UnitOrder& operator=(UnitOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitOrder& default_instance();

  enum TargetCase {
    kTargetWorldSpacePos = 2,
    kTargetUnitTag = 3,
    TARGET_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOrder* internal_default_instance() {
    return reinterpret_cast<const UnitOrder*>(
               &_UnitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UnitOrder* other);
  friend void swap(UnitOrder& a, UnitOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitOrder* New() const final {
    return CreateMaybeMessage<UnitOrder>(NULL);
  }

  UnitOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitOrder& from);
  void MergeFrom(const UnitOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  ::google::protobuf::uint32 ability_id() const;
  void set_ability_id(::google::protobuf::uint32 value);

  // optional float progress = 4;
  bool has_progress() const;
  void clear_progress();
  static const int kProgressFieldNumber = 4;
  float progress() const;
  void set_progress(float value);

  // optional .SCRAPIProtocol.Point target_world_space_pos = 2;
  bool has_target_world_space_pos() const;
  void clear_target_world_space_pos();
  static const int kTargetWorldSpacePosFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::Point& _internal_target_world_space_pos() const;
  public:
  const ::SCRAPIProtocol::Point& target_world_space_pos() const;
  ::SCRAPIProtocol::Point* release_target_world_space_pos();
  ::SCRAPIProtocol::Point* mutable_target_world_space_pos();
  void set_allocated_target_world_space_pos(::SCRAPIProtocol::Point* target_world_space_pos);

  // optional uint64 target_unit_tag = 3;
  bool has_target_unit_tag() const;
  void clear_target_unit_tag();
  static const int kTargetUnitTagFieldNumber = 3;
  ::google::protobuf::uint64 target_unit_tag() const;
  void set_target_unit_tag(::google::protobuf::uint64 value);

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.UnitOrder)
 private:
  void set_has_ability_id();
  void clear_has_ability_id();
  void set_has_target_world_space_pos();
  void set_has_target_unit_tag();
  void set_has_progress();
  void clear_has_progress();

  inline bool has_target() const;
  inline void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 ability_id_;
  float progress_;
  union TargetUnion {
    TargetUnion() {}
    ::SCRAPIProtocol::Point* target_world_space_pos_;
    ::google::protobuf::uint64 target_unit_tag_;
  } target_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PassengerUnit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.PassengerUnit) */ {
 public:
  PassengerUnit();
  virtual ~PassengerUnit();

  PassengerUnit(const PassengerUnit& from);

  inline PassengerUnit& operator=(const PassengerUnit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PassengerUnit(PassengerUnit&& from) noexcept
    : PassengerUnit() {
    *this = ::std::move(from);
  }

  inline PassengerUnit& operator=(PassengerUnit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PassengerUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PassengerUnit* internal_default_instance() {
    return reinterpret_cast<const PassengerUnit*>(
               &_PassengerUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(PassengerUnit* other);
  friend void swap(PassengerUnit& a, PassengerUnit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PassengerUnit* New() const final {
    return CreateMaybeMessage<PassengerUnit>(NULL);
  }

  PassengerUnit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PassengerUnit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PassengerUnit& from);
  void MergeFrom(const PassengerUnit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PassengerUnit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::google::protobuf::uint64 tag() const;
  void set_tag(::google::protobuf::uint64 value);

  // optional float health = 2;
  bool has_health() const;
  void clear_health();
  static const int kHealthFieldNumber = 2;
  float health() const;
  void set_health(float value);

  // optional float health_max = 3;
  bool has_health_max() const;
  void clear_health_max();
  static const int kHealthMaxFieldNumber = 3;
  float health_max() const;
  void set_health_max(float value);

  // optional float shield = 4;
  bool has_shield() const;
  void clear_shield();
  static const int kShieldFieldNumber = 4;
  float shield() const;
  void set_shield(float value);

  // optional float energy = 5;
  bool has_energy() const;
  void clear_energy();
  static const int kEnergyFieldNumber = 5;
  float energy() const;
  void set_energy(float value);

  // optional uint32 unit_type = 6;
  bool has_unit_type() const;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 6;
  ::google::protobuf::uint32 unit_type() const;
  void set_unit_type(::google::protobuf::uint32 value);

  // optional float shield_max = 7;
  bool has_shield_max() const;
  void clear_shield_max();
  static const int kShieldMaxFieldNumber = 7;
  float shield_max() const;
  void set_shield_max(float value);

  // optional float energy_max = 8;
  bool has_energy_max() const;
  void clear_energy_max();
  static const int kEnergyMaxFieldNumber = 8;
  float energy_max() const;
  void set_energy_max(float value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.PassengerUnit)
 private:
  void set_has_tag();
  void clear_has_tag();
  void set_has_health();
  void clear_has_health();
  void set_has_health_max();
  void clear_has_health_max();
  void set_has_shield();
  void clear_has_shield();
  void set_has_shield_max();
  void clear_has_shield_max();
  void set_has_energy();
  void clear_has_energy();
  void set_has_energy_max();
  void clear_has_energy_max();
  void set_has_unit_type();
  void clear_has_unit_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 tag_;
  float health_;
  float health_max_;
  float shield_;
  float energy_;
  ::google::protobuf::uint32 unit_type_;
  float shield_max_;
  float energy_max_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Unit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.Unit) */ {
 public:
  Unit();
  virtual ~Unit();

  Unit(const Unit& from);

  inline Unit& operator=(const Unit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Unit(Unit&& from) noexcept
    : Unit() {
    *this = ::std::move(from);
  }

  inline Unit& operator=(Unit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Unit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Unit* internal_default_instance() {
    return reinterpret_cast<const Unit*>(
               &_Unit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Unit* other);
  friend void swap(Unit& a, Unit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Unit* New() const final {
    return CreateMaybeMessage<Unit>(NULL);
  }

  Unit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Unit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Unit& from);
  void MergeFrom(const Unit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.UnitOrder orders = 22;
  int orders_size() const;
  void clear_orders();
  static const int kOrdersFieldNumber = 22;
  ::SCRAPIProtocol::UnitOrder* mutable_orders(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitOrder >*
      mutable_orders();
  const ::SCRAPIProtocol::UnitOrder& orders(int index) const;
  ::SCRAPIProtocol::UnitOrder* add_orders();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitOrder >&
      orders() const;

  // repeated .SCRAPIProtocol.PassengerUnit passengers = 24;
  int passengers_size() const;
  void clear_passengers();
  static const int kPassengersFieldNumber = 24;
  ::SCRAPIProtocol::PassengerUnit* mutable_passengers(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PassengerUnit >*
      mutable_passengers();
  const ::SCRAPIProtocol::PassengerUnit& passengers(int index) const;
  ::SCRAPIProtocol::PassengerUnit* add_passengers();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PassengerUnit >&
      passengers() const;

  // repeated uint32 buff_ids = 27;
  int buff_ids_size() const;
  void clear_buff_ids();
  static const int kBuffIdsFieldNumber = 27;
  ::google::protobuf::uint32 buff_ids(int index) const;
  void set_buff_ids(int index, ::google::protobuf::uint32 value);
  void add_buff_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      buff_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_buff_ids();

  // optional .SCRAPIProtocol.Point pos = 6;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 6;
  private:
  const ::SCRAPIProtocol::Point& _internal_pos() const;
  public:
  const ::SCRAPIProtocol::Point& pos() const;
  ::SCRAPIProtocol::Point* release_pos();
  ::SCRAPIProtocol::Point* mutable_pos();
  void set_allocated_pos(::SCRAPIProtocol::Point* pos);

  // optional uint64 tag = 3;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 3;
  ::google::protobuf::uint64 tag() const;
  void set_tag(::google::protobuf::uint64 value);

  // optional uint32 unit_type = 4;
  bool has_unit_type() const;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 4;
  ::google::protobuf::uint32 unit_type() const;
  void set_unit_type(::google::protobuf::uint32 value);

  // optional int32 owner = 5;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 5;
  ::google::protobuf::int32 owner() const;
  void set_owner(::google::protobuf::int32 value);

  // optional float facing = 7;
  bool has_facing() const;
  void clear_facing();
  static const int kFacingFieldNumber = 7;
  float facing() const;
  void set_facing(float value);

  // optional float radius = 8;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 8;
  float radius() const;
  void set_radius(float value);

  // optional float build_progress = 9;
  bool has_build_progress() const;
  void clear_build_progress();
  static const int kBuildProgressFieldNumber = 9;
  float build_progress() const;
  void set_build_progress(float value);

  // optional float health = 14;
  bool has_health() const;
  void clear_health();
  static const int kHealthFieldNumber = 14;
  float health() const;
  void set_health(float value);

  // optional float health_max = 15;
  bool has_health_max() const;
  void clear_health_max();
  static const int kHealthMaxFieldNumber = 15;
  float health_max() const;
  void set_health_max(float value);

  // optional float shield = 16;
  bool has_shield() const;
  void clear_shield();
  static const int kShieldFieldNumber = 16;
  float shield() const;
  void set_shield(float value);

  // optional float energy = 17;
  bool has_energy() const;
  void clear_energy();
  static const int kEnergyFieldNumber = 17;
  float energy() const;
  void set_energy(float value);

  // optional bool is_selected = 11;
  bool has_is_selected() const;
  void clear_is_selected();
  static const int kIsSelectedFieldNumber = 11;
  bool is_selected() const;
  void set_is_selected(bool value);

  // optional bool is_on_screen = 12;
  bool has_is_on_screen() const;
  void clear_is_on_screen();
  static const int kIsOnScreenFieldNumber = 12;
  bool is_on_screen() const;
  void set_is_on_screen(bool value);

  // optional bool is_blip = 13;
  bool has_is_blip() const;
  void clear_is_blip();
  static const int kIsBlipFieldNumber = 13;
  bool is_blip() const;
  void set_is_blip(bool value);

  // optional bool is_powered = 35;
  bool has_is_powered() const;
  void clear_is_powered();
  static const int kIsPoweredFieldNumber = 35;
  bool is_powered() const;
  void set_is_powered(bool value);

  // optional int32 mineral_contents = 18;
  bool has_mineral_contents() const;
  void clear_mineral_contents();
  static const int kMineralContentsFieldNumber = 18;
  ::google::protobuf::int32 mineral_contents() const;
  void set_mineral_contents(::google::protobuf::int32 value);

  // optional int32 vespene_contents = 19;
  bool has_vespene_contents() const;
  void clear_vespene_contents();
  static const int kVespeneContentsFieldNumber = 19;
  ::google::protobuf::int32 vespene_contents() const;
  void set_vespene_contents(::google::protobuf::int32 value);

  // optional bool is_flying = 20;
  bool has_is_flying() const;
  void clear_is_flying();
  static const int kIsFlyingFieldNumber = 20;
  bool is_flying() const;
  void set_is_flying(bool value);

  // optional bool is_burrowed = 21;
  bool has_is_burrowed() const;
  void clear_is_burrowed();
  static const int kIsBurrowedFieldNumber = 21;
  bool is_burrowed() const;
  void set_is_burrowed(bool value);

  // optional int32 cargo_space_taken = 25;
  bool has_cargo_space_taken() const;
  void clear_cargo_space_taken();
  static const int kCargoSpaceTakenFieldNumber = 25;
  ::google::protobuf::int32 cargo_space_taken() const;
  void set_cargo_space_taken(::google::protobuf::int32 value);

  // optional uint64 add_on_tag = 23;
  bool has_add_on_tag() const;
  void clear_add_on_tag();
  static const int kAddOnTagFieldNumber = 23;
  ::google::protobuf::uint64 add_on_tag() const;
  void set_add_on_tag(::google::protobuf::uint64 value);

  // optional int32 cargo_space_max = 26;
  bool has_cargo_space_max() const;
  void clear_cargo_space_max();
  static const int kCargoSpaceMaxFieldNumber = 26;
  ::google::protobuf::int32 cargo_space_max() const;
  void set_cargo_space_max(::google::protobuf::int32 value);

  // optional int32 assigned_harvesters = 28;
  bool has_assigned_harvesters() const;
  void clear_assigned_harvesters();
  static const int kAssignedHarvestersFieldNumber = 28;
  ::google::protobuf::int32 assigned_harvesters() const;
  void set_assigned_harvesters(::google::protobuf::int32 value);

  // optional int32 ideal_harvesters = 29;
  bool has_ideal_harvesters() const;
  void clear_ideal_harvesters();
  static const int kIdealHarvestersFieldNumber = 29;
  ::google::protobuf::int32 ideal_harvesters() const;
  void set_ideal_harvesters(::google::protobuf::int32 value);

  // optional float weapon_cooldown = 30;
  bool has_weapon_cooldown() const;
  void clear_weapon_cooldown();
  static const int kWeaponCooldownFieldNumber = 30;
  float weapon_cooldown() const;
  void set_weapon_cooldown(float value);

  // optional float detect_range = 31;
  bool has_detect_range() const;
  void clear_detect_range();
  static const int kDetectRangeFieldNumber = 31;
  float detect_range() const;
  void set_detect_range(float value);

  // optional float radar_range = 32;
  bool has_radar_range() const;
  void clear_radar_range();
  static const int kRadarRangeFieldNumber = 32;
  float radar_range() const;
  void set_radar_range(float value);

  // optional uint64 engaged_target_tag = 34;
  bool has_engaged_target_tag() const;
  void clear_engaged_target_tag();
  static const int kEngagedTargetTagFieldNumber = 34;
  ::google::protobuf::uint64 engaged_target_tag() const;
  void set_engaged_target_tag(::google::protobuf::uint64 value);

  // optional float shield_max = 36;
  bool has_shield_max() const;
  void clear_shield_max();
  static const int kShieldMaxFieldNumber = 36;
  float shield_max() const;
  void set_shield_max(float value);

  // optional float energy_max = 37;
  bool has_energy_max() const;
  void clear_energy_max();
  static const int kEnergyMaxFieldNumber = 37;
  float energy_max() const;
  void set_energy_max(float value);

  // optional .SCRAPIProtocol.CloakState cloak = 10;
  bool has_cloak() const;
  void clear_cloak();
  static const int kCloakFieldNumber = 10;
  ::SCRAPIProtocol::CloakState cloak() const;
  void set_cloak(::SCRAPIProtocol::CloakState value);

  // optional .SCRAPIProtocol.DisplayType display_type = 1;
  bool has_display_type() const;
  void clear_display_type();
  static const int kDisplayTypeFieldNumber = 1;
  ::SCRAPIProtocol::DisplayType display_type() const;
  void set_display_type(::SCRAPIProtocol::DisplayType value);

  // optional .SCRAPIProtocol.Alliance alliance = 2;
  bool has_alliance() const;
  void clear_alliance();
  static const int kAllianceFieldNumber = 2;
  ::SCRAPIProtocol::Alliance alliance() const;
  void set_alliance(::SCRAPIProtocol::Alliance value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.Unit)
 private:
  void set_has_display_type();
  void clear_has_display_type();
  void set_has_alliance();
  void clear_has_alliance();
  void set_has_tag();
  void clear_has_tag();
  void set_has_unit_type();
  void clear_has_unit_type();
  void set_has_owner();
  void clear_has_owner();
  void set_has_pos();
  void clear_has_pos();
  void set_has_facing();
  void clear_has_facing();
  void set_has_radius();
  void clear_has_radius();
  void set_has_build_progress();
  void clear_has_build_progress();
  void set_has_cloak();
  void clear_has_cloak();
  void set_has_detect_range();
  void clear_has_detect_range();
  void set_has_radar_range();
  void clear_has_radar_range();
  void set_has_is_selected();
  void clear_has_is_selected();
  void set_has_is_on_screen();
  void clear_has_is_on_screen();
  void set_has_is_blip();
  void clear_has_is_blip();
  void set_has_is_powered();
  void clear_has_is_powered();
  void set_has_health();
  void clear_has_health();
  void set_has_health_max();
  void clear_has_health_max();
  void set_has_shield();
  void clear_has_shield();
  void set_has_shield_max();
  void clear_has_shield_max();
  void set_has_energy();
  void clear_has_energy();
  void set_has_energy_max();
  void clear_has_energy_max();
  void set_has_mineral_contents();
  void clear_has_mineral_contents();
  void set_has_vespene_contents();
  void clear_has_vespene_contents();
  void set_has_is_flying();
  void clear_has_is_flying();
  void set_has_is_burrowed();
  void clear_has_is_burrowed();
  void set_has_add_on_tag();
  void clear_has_add_on_tag();
  void set_has_cargo_space_taken();
  void clear_has_cargo_space_taken();
  void set_has_cargo_space_max();
  void clear_has_cargo_space_max();
  void set_has_assigned_harvesters();
  void clear_has_assigned_harvesters();
  void set_has_ideal_harvesters();
  void clear_has_ideal_harvesters();
  void set_has_weapon_cooldown();
  void clear_has_weapon_cooldown();
  void set_has_engaged_target_tag();
  void clear_has_engaged_target_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitOrder > orders_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PassengerUnit > passengers_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > buff_ids_;
  ::SCRAPIProtocol::Point* pos_;
  ::google::protobuf::uint64 tag_;
  ::google::protobuf::uint32 unit_type_;
  ::google::protobuf::int32 owner_;
  float facing_;
  float radius_;
  float build_progress_;
  float health_;
  float health_max_;
  float shield_;
  float energy_;
  bool is_selected_;
  bool is_on_screen_;
  bool is_blip_;
  bool is_powered_;
  ::google::protobuf::int32 mineral_contents_;
  ::google::protobuf::int32 vespene_contents_;
  bool is_flying_;
  bool is_burrowed_;
  ::google::protobuf::int32 cargo_space_taken_;
  ::google::protobuf::uint64 add_on_tag_;
  ::google::protobuf::int32 cargo_space_max_;
  ::google::protobuf::int32 assigned_harvesters_;
  ::google::protobuf::int32 ideal_harvesters_;
  float weapon_cooldown_;
  float detect_range_;
  float radar_range_;
  ::google::protobuf::uint64 engaged_target_tag_;
  float shield_max_;
  float energy_max_;
  int cloak_;
  int display_type_;
  int alliance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.MapState) */ {
 public:
  MapState();
  virtual ~MapState();

  MapState(const MapState& from);

  inline MapState& operator=(const MapState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapState(MapState&& from) noexcept
    : MapState() {
    *this = ::std::move(from);
  }

  inline MapState& operator=(MapState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapState* internal_default_instance() {
    return reinterpret_cast<const MapState*>(
               &_MapState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MapState* other);
  friend void swap(MapState& a, MapState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapState* New() const final {
    return CreateMaybeMessage<MapState>(NULL);
  }

  MapState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapState& from);
  void MergeFrom(const MapState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ImageData visibility = 1;
  bool has_visibility() const;
  void clear_visibility();
  static const int kVisibilityFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_visibility() const;
  public:
  const ::SCRAPIProtocol::ImageData& visibility() const;
  ::SCRAPIProtocol::ImageData* release_visibility();
  ::SCRAPIProtocol::ImageData* mutable_visibility();
  void set_allocated_visibility(::SCRAPIProtocol::ImageData* visibility);

  // optional .SCRAPIProtocol.ImageData creep = 2;
  bool has_creep() const;
  void clear_creep();
  static const int kCreepFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_creep() const;
  public:
  const ::SCRAPIProtocol::ImageData& creep() const;
  ::SCRAPIProtocol::ImageData* release_creep();
  ::SCRAPIProtocol::ImageData* mutable_creep();
  void set_allocated_creep(::SCRAPIProtocol::ImageData* creep);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.MapState)
 private:
  void set_has_visibility();
  void clear_has_visibility();
  void set_has_creep();
  void clear_has_creep();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::ImageData* visibility_;
  ::SCRAPIProtocol::ImageData* creep_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 dead_units = 1;
  int dead_units_size() const;
  void clear_dead_units();
  static const int kDeadUnitsFieldNumber = 1;
  ::google::protobuf::uint64 dead_units(int index) const;
  void set_dead_units(int index, ::google::protobuf::uint64 value);
  void add_dead_units(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      dead_units() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_dead_units();

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > dead_units_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Effect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.Effect) */ {
 public:
  Effect();
  virtual ~Effect();

  Effect(const Effect& from);

  inline Effect& operator=(const Effect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Effect(Effect&& from) noexcept
    : Effect() {
    *this = ::std::move(from);
  }

  inline Effect& operator=(Effect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Effect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Effect* internal_default_instance() {
    return reinterpret_cast<const Effect*>(
               &_Effect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Effect* other);
  friend void swap(Effect& a, Effect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Effect* New() const final {
    return CreateMaybeMessage<Effect>(NULL);
  }

  Effect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Effect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Effect& from);
  void MergeFrom(const Effect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Effect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.Point2D pos = 2;
  int pos_size() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  ::SCRAPIProtocol::Point2D* mutable_pos(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Point2D >*
      mutable_pos();
  const ::SCRAPIProtocol::Point2D& pos(int index) const;
  ::SCRAPIProtocol::Point2D* add_pos();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Point2D >&
      pos() const;

  // optional uint32 effect_id = 1;
  bool has_effect_id() const;
  void clear_effect_id();
  static const int kEffectIdFieldNumber = 1;
  ::google::protobuf::uint32 effect_id() const;
  void set_effect_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.Effect)
 private:
  void set_has_effect_id();
  void clear_has_effect_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Point2D > pos_;
  ::google::protobuf::uint32 effect_id_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionRaw) */ {
 public:
  ActionRaw();
  virtual ~ActionRaw();

  ActionRaw(const ActionRaw& from);

  inline ActionRaw& operator=(const ActionRaw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionRaw(ActionRaw&& from) noexcept
    : ActionRaw() {
    *this = ::std::move(from);
  }

  inline ActionRaw& operator=(ActionRaw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRaw& default_instance();

  enum ActionCase {
    kUnitCommand = 1,
    kCameraMove = 2,
    kToggleAutocast = 3,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionRaw* internal_default_instance() {
    return reinterpret_cast<const ActionRaw*>(
               &_ActionRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ActionRaw* other);
  friend void swap(ActionRaw& a, ActionRaw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionRaw* New() const final {
    return CreateMaybeMessage<ActionRaw>(NULL);
  }

  ActionRaw* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionRaw>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionRaw& from);
  void MergeFrom(const ActionRaw& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ActionRawUnitCommand unit_command = 1;
  bool has_unit_command() const;
  void clear_unit_command();
  static const int kUnitCommandFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::ActionRawUnitCommand& _internal_unit_command() const;
  public:
  const ::SCRAPIProtocol::ActionRawUnitCommand& unit_command() const;
  ::SCRAPIProtocol::ActionRawUnitCommand* release_unit_command();
  ::SCRAPIProtocol::ActionRawUnitCommand* mutable_unit_command();
  void set_allocated_unit_command(::SCRAPIProtocol::ActionRawUnitCommand* unit_command);

  // optional .SCRAPIProtocol.ActionRawCameraMove camera_move = 2;
  bool has_camera_move() const;
  void clear_camera_move();
  static const int kCameraMoveFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ActionRawCameraMove& _internal_camera_move() const;
  public:
  const ::SCRAPIProtocol::ActionRawCameraMove& camera_move() const;
  ::SCRAPIProtocol::ActionRawCameraMove* release_camera_move();
  ::SCRAPIProtocol::ActionRawCameraMove* mutable_camera_move();
  void set_allocated_camera_move(::SCRAPIProtocol::ActionRawCameraMove* camera_move);

  // optional .SCRAPIProtocol.ActionRawToggleAutocast toggle_autocast = 3;
  bool has_toggle_autocast() const;
  void clear_toggle_autocast();
  static const int kToggleAutocastFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::ActionRawToggleAutocast& _internal_toggle_autocast() const;
  public:
  const ::SCRAPIProtocol::ActionRawToggleAutocast& toggle_autocast() const;
  ::SCRAPIProtocol::ActionRawToggleAutocast* release_toggle_autocast();
  ::SCRAPIProtocol::ActionRawToggleAutocast* mutable_toggle_autocast();
  void set_allocated_toggle_autocast(::SCRAPIProtocol::ActionRawToggleAutocast* toggle_autocast);

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionRaw)
 private:
  void set_has_unit_command();
  void set_has_camera_move();
  void set_has_toggle_autocast();

  inline bool has_action() const;
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ActionUnion {
    ActionUnion() {}
    ::SCRAPIProtocol::ActionRawUnitCommand* unit_command_;
    ::SCRAPIProtocol::ActionRawCameraMove* camera_move_;
    ::SCRAPIProtocol::ActionRawToggleAutocast* toggle_autocast_;
  } action_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionRawUnitCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionRawUnitCommand) */ {
 public:
  ActionRawUnitCommand();
  virtual ~ActionRawUnitCommand();

  ActionRawUnitCommand(const ActionRawUnitCommand& from);

  inline ActionRawUnitCommand& operator=(const ActionRawUnitCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionRawUnitCommand(ActionRawUnitCommand&& from) noexcept
    : ActionRawUnitCommand() {
    *this = ::std::move(from);
  }

  inline ActionRawUnitCommand& operator=(ActionRawUnitCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRawUnitCommand& default_instance();

  enum TargetCase {
    kTargetWorldSpacePos = 2,
    kTargetUnitTag = 3,
    TARGET_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionRawUnitCommand* internal_default_instance() {
    return reinterpret_cast<const ActionRawUnitCommand*>(
               &_ActionRawUnitCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ActionRawUnitCommand* other);
  friend void swap(ActionRawUnitCommand& a, ActionRawUnitCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionRawUnitCommand* New() const final {
    return CreateMaybeMessage<ActionRawUnitCommand>(NULL);
  }

  ActionRawUnitCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionRawUnitCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionRawUnitCommand& from);
  void MergeFrom(const ActionRawUnitCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRawUnitCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 unit_tags = 4;
  int unit_tags_size() const;
  void clear_unit_tags();
  static const int kUnitTagsFieldNumber = 4;
  ::google::protobuf::uint64 unit_tags(int index) const;
  void set_unit_tags(int index, ::google::protobuf::uint64 value);
  void add_unit_tags(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      unit_tags() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_unit_tags();

  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  ::google::protobuf::int32 ability_id() const;
  void set_ability_id(::google::protobuf::int32 value);

  // optional bool queue_command = 5;
  bool has_queue_command() const;
  void clear_queue_command();
  static const int kQueueCommandFieldNumber = 5;
  bool queue_command() const;
  void set_queue_command(bool value);

  // optional .SCRAPIProtocol.Point2D target_world_space_pos = 2;
  bool has_target_world_space_pos() const;
  void clear_target_world_space_pos();
  static const int kTargetWorldSpacePosFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::Point2D& _internal_target_world_space_pos() const;
  public:
  const ::SCRAPIProtocol::Point2D& target_world_space_pos() const;
  ::SCRAPIProtocol::Point2D* release_target_world_space_pos();
  ::SCRAPIProtocol::Point2D* mutable_target_world_space_pos();
  void set_allocated_target_world_space_pos(::SCRAPIProtocol::Point2D* target_world_space_pos);

  // optional uint64 target_unit_tag = 3;
  bool has_target_unit_tag() const;
  void clear_target_unit_tag();
  static const int kTargetUnitTagFieldNumber = 3;
  ::google::protobuf::uint64 target_unit_tag() const;
  void set_target_unit_tag(::google::protobuf::uint64 value);

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionRawUnitCommand)
 private:
  void set_has_ability_id();
  void clear_has_ability_id();
  void set_has_target_world_space_pos();
  void set_has_target_unit_tag();
  void set_has_queue_command();
  void clear_has_queue_command();

  inline bool has_target() const;
  inline void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > unit_tags_;
  ::google::protobuf::int32 ability_id_;
  bool queue_command_;
  union TargetUnion {
    TargetUnion() {}
    ::SCRAPIProtocol::Point2D* target_world_space_pos_;
    ::google::protobuf::uint64 target_unit_tag_;
  } target_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionRawCameraMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionRawCameraMove) */ {
 public:
  ActionRawCameraMove();
  virtual ~ActionRawCameraMove();

  ActionRawCameraMove(const ActionRawCameraMove& from);

  inline ActionRawCameraMove& operator=(const ActionRawCameraMove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionRawCameraMove(ActionRawCameraMove&& from) noexcept
    : ActionRawCameraMove() {
    *this = ::std::move(from);
  }

  inline ActionRawCameraMove& operator=(ActionRawCameraMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRawCameraMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionRawCameraMove* internal_default_instance() {
    return reinterpret_cast<const ActionRawCameraMove*>(
               &_ActionRawCameraMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ActionRawCameraMove* other);
  friend void swap(ActionRawCameraMove& a, ActionRawCameraMove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionRawCameraMove* New() const final {
    return CreateMaybeMessage<ActionRawCameraMove>(NULL);
  }

  ActionRawCameraMove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionRawCameraMove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionRawCameraMove& from);
  void MergeFrom(const ActionRawCameraMove& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRawCameraMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.Point center_world_space = 1;
  bool has_center_world_space() const;
  void clear_center_world_space();
  static const int kCenterWorldSpaceFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::Point& _internal_center_world_space() const;
  public:
  const ::SCRAPIProtocol::Point& center_world_space() const;
  ::SCRAPIProtocol::Point* release_center_world_space();
  ::SCRAPIProtocol::Point* mutable_center_world_space();
  void set_allocated_center_world_space(::SCRAPIProtocol::Point* center_world_space);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionRawCameraMove)
 private:
  void set_has_center_world_space();
  void clear_has_center_world_space();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::Point* center_world_space_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionRawToggleAutocast : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionRawToggleAutocast) */ {
 public:
  ActionRawToggleAutocast();
  virtual ~ActionRawToggleAutocast();

  ActionRawToggleAutocast(const ActionRawToggleAutocast& from);

  inline ActionRawToggleAutocast& operator=(const ActionRawToggleAutocast& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionRawToggleAutocast(ActionRawToggleAutocast&& from) noexcept
    : ActionRawToggleAutocast() {
    *this = ::std::move(from);
  }

  inline ActionRawToggleAutocast& operator=(ActionRawToggleAutocast&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRawToggleAutocast& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionRawToggleAutocast* internal_default_instance() {
    return reinterpret_cast<const ActionRawToggleAutocast*>(
               &_ActionRawToggleAutocast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ActionRawToggleAutocast* other);
  friend void swap(ActionRawToggleAutocast& a, ActionRawToggleAutocast& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionRawToggleAutocast* New() const final {
    return CreateMaybeMessage<ActionRawToggleAutocast>(NULL);
  }

  ActionRawToggleAutocast* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionRawToggleAutocast>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionRawToggleAutocast& from);
  void MergeFrom(const ActionRawToggleAutocast& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRawToggleAutocast* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 unit_tags = 2;
  int unit_tags_size() const;
  void clear_unit_tags();
  static const int kUnitTagsFieldNumber = 2;
  ::google::protobuf::uint64 unit_tags(int index) const;
  void set_unit_tags(int index, ::google::protobuf::uint64 value);
  void add_unit_tags(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      unit_tags() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_unit_tags();

  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  ::google::protobuf::int32 ability_id() const;
  void set_ability_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionRawToggleAutocast)
 private:
  void set_has_ability_id();
  void clear_has_ability_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > unit_tags_;
  ::google::protobuf::int32 ability_id_;
  friend struct ::protobuf_raw_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StartRaw

// optional .SCRAPIProtocol.Size2DI map_size = 1;
inline bool StartRaw::has_map_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartRaw::set_has_map_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartRaw::clear_has_map_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::Size2DI& StartRaw::_internal_map_size() const {
  return *map_size_;
}
inline const ::SCRAPIProtocol::Size2DI& StartRaw::map_size() const {
  const ::SCRAPIProtocol::Size2DI* p = map_size_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.StartRaw.map_size)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Size2DI*>(
      &::SCRAPIProtocol::_Size2DI_default_instance_);
}
inline ::SCRAPIProtocol::Size2DI* StartRaw::release_map_size() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.StartRaw.map_size)
  clear_has_map_size();
  ::SCRAPIProtocol::Size2DI* temp = map_size_;
  map_size_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Size2DI* StartRaw::mutable_map_size() {
  set_has_map_size();
  if (map_size_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Size2DI>(GetArenaNoVirtual());
    map_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.StartRaw.map_size)
  return map_size_;
}
inline void StartRaw::set_allocated_map_size(::SCRAPIProtocol::Size2DI* map_size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(map_size_);
  }
  if (map_size) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_size, submessage_arena);
    }
    set_has_map_size();
  } else {
    clear_has_map_size();
  }
  map_size_ = map_size;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.StartRaw.map_size)
}

// optional .SCRAPIProtocol.ImageData pathing_grid = 2;
inline bool StartRaw::has_pathing_grid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartRaw::set_has_pathing_grid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartRaw::clear_has_pathing_grid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::ImageData& StartRaw::_internal_pathing_grid() const {
  return *pathing_grid_;
}
inline const ::SCRAPIProtocol::ImageData& StartRaw::pathing_grid() const {
  const ::SCRAPIProtocol::ImageData* p = pathing_grid_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.StartRaw.pathing_grid)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* StartRaw::release_pathing_grid() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.StartRaw.pathing_grid)
  clear_has_pathing_grid();
  ::SCRAPIProtocol::ImageData* temp = pathing_grid_;
  pathing_grid_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* StartRaw::mutable_pathing_grid() {
  set_has_pathing_grid();
  if (pathing_grid_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    pathing_grid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.StartRaw.pathing_grid)
  return pathing_grid_;
}
inline void StartRaw::set_allocated_pathing_grid(::SCRAPIProtocol::ImageData* pathing_grid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pathing_grid_);
  }
  if (pathing_grid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pathing_grid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pathing_grid, submessage_arena);
    }
    set_has_pathing_grid();
  } else {
    clear_has_pathing_grid();
  }
  pathing_grid_ = pathing_grid;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.StartRaw.pathing_grid)
}

// optional .SCRAPIProtocol.ImageData terrain_height = 3;
inline bool StartRaw::has_terrain_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartRaw::set_has_terrain_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartRaw::clear_has_terrain_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SCRAPIProtocol::ImageData& StartRaw::_internal_terrain_height() const {
  return *terrain_height_;
}
inline const ::SCRAPIProtocol::ImageData& StartRaw::terrain_height() const {
  const ::SCRAPIProtocol::ImageData* p = terrain_height_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.StartRaw.terrain_height)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* StartRaw::release_terrain_height() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.StartRaw.terrain_height)
  clear_has_terrain_height();
  ::SCRAPIProtocol::ImageData* temp = terrain_height_;
  terrain_height_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* StartRaw::mutable_terrain_height() {
  set_has_terrain_height();
  if (terrain_height_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    terrain_height_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.StartRaw.terrain_height)
  return terrain_height_;
}
inline void StartRaw::set_allocated_terrain_height(::SCRAPIProtocol::ImageData* terrain_height) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(terrain_height_);
  }
  if (terrain_height) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      terrain_height = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, terrain_height, submessage_arena);
    }
    set_has_terrain_height();
  } else {
    clear_has_terrain_height();
  }
  terrain_height_ = terrain_height;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.StartRaw.terrain_height)
}

// optional .SCRAPIProtocol.ImageData placement_grid = 4;
inline bool StartRaw::has_placement_grid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartRaw::set_has_placement_grid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartRaw::clear_has_placement_grid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::SCRAPIProtocol::ImageData& StartRaw::_internal_placement_grid() const {
  return *placement_grid_;
}
inline const ::SCRAPIProtocol::ImageData& StartRaw::placement_grid() const {
  const ::SCRAPIProtocol::ImageData* p = placement_grid_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.StartRaw.placement_grid)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* StartRaw::release_placement_grid() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.StartRaw.placement_grid)
  clear_has_placement_grid();
  ::SCRAPIProtocol::ImageData* temp = placement_grid_;
  placement_grid_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* StartRaw::mutable_placement_grid() {
  set_has_placement_grid();
  if (placement_grid_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    placement_grid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.StartRaw.placement_grid)
  return placement_grid_;
}
inline void StartRaw::set_allocated_placement_grid(::SCRAPIProtocol::ImageData* placement_grid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(placement_grid_);
  }
  if (placement_grid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      placement_grid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, placement_grid, submessage_arena);
    }
    set_has_placement_grid();
  } else {
    clear_has_placement_grid();
  }
  placement_grid_ = placement_grid;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.StartRaw.placement_grid)
}

// optional .SCRAPIProtocol.RectangleI playable_area = 5;
inline bool StartRaw::has_playable_area() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartRaw::set_has_playable_area() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartRaw::clear_has_playable_area() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::SCRAPIProtocol::RectangleI& StartRaw::_internal_playable_area() const {
  return *playable_area_;
}
inline const ::SCRAPIProtocol::RectangleI& StartRaw::playable_area() const {
  const ::SCRAPIProtocol::RectangleI* p = playable_area_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.StartRaw.playable_area)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::RectangleI*>(
      &::SCRAPIProtocol::_RectangleI_default_instance_);
}
inline ::SCRAPIProtocol::RectangleI* StartRaw::release_playable_area() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.StartRaw.playable_area)
  clear_has_playable_area();
  ::SCRAPIProtocol::RectangleI* temp = playable_area_;
  playable_area_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::RectangleI* StartRaw::mutable_playable_area() {
  set_has_playable_area();
  if (playable_area_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::RectangleI>(GetArenaNoVirtual());
    playable_area_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.StartRaw.playable_area)
  return playable_area_;
}
inline void StartRaw::set_allocated_playable_area(::SCRAPIProtocol::RectangleI* playable_area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(playable_area_);
  }
  if (playable_area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      playable_area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playable_area, submessage_arena);
    }
    set_has_playable_area();
  } else {
    clear_has_playable_area();
  }
  playable_area_ = playable_area;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.StartRaw.playable_area)
}

// repeated .SCRAPIProtocol.Point2D start_locations = 6;
inline int StartRaw::start_locations_size() const {
  return start_locations_.size();
}
inline ::SCRAPIProtocol::Point2D* StartRaw::mutable_start_locations(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.StartRaw.start_locations)
  return start_locations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Point2D >*
StartRaw::mutable_start_locations() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.StartRaw.start_locations)
  return &start_locations_;
}
inline const ::SCRAPIProtocol::Point2D& StartRaw::start_locations(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.StartRaw.start_locations)
  return start_locations_.Get(index);
}
inline ::SCRAPIProtocol::Point2D* StartRaw::add_start_locations() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.StartRaw.start_locations)
  return start_locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Point2D >&
StartRaw::start_locations() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.StartRaw.start_locations)
  return start_locations_;
}

// -------------------------------------------------------------------

// ObservationRaw

// optional .SCRAPIProtocol.PlayerRaw player = 1;
inline bool ObservationRaw::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObservationRaw::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObservationRaw::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObservationRaw::clear_player() {
  if (player_ != NULL) player_->Clear();
  clear_has_player();
}
inline const ::SCRAPIProtocol::PlayerRaw& ObservationRaw::_internal_player() const {
  return *player_;
}
inline const ::SCRAPIProtocol::PlayerRaw& ObservationRaw::player() const {
  const ::SCRAPIProtocol::PlayerRaw* p = player_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationRaw.player)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::PlayerRaw*>(
      &::SCRAPIProtocol::_PlayerRaw_default_instance_);
}
inline ::SCRAPIProtocol::PlayerRaw* ObservationRaw::release_player() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationRaw.player)
  clear_has_player();
  ::SCRAPIProtocol::PlayerRaw* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::PlayerRaw* ObservationRaw::mutable_player() {
  set_has_player();
  if (player_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::PlayerRaw>(GetArenaNoVirtual());
    player_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationRaw.player)
  return player_;
}
inline void ObservationRaw::set_allocated_player(::SCRAPIProtocol::PlayerRaw* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    set_has_player();
  } else {
    clear_has_player();
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ObservationRaw.player)
}

// repeated .SCRAPIProtocol.Unit units = 2;
inline int ObservationRaw::units_size() const {
  return units_.size();
}
inline void ObservationRaw::clear_units() {
  units_.Clear();
}
inline ::SCRAPIProtocol::Unit* ObservationRaw::mutable_units(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationRaw.units)
  return units_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Unit >*
ObservationRaw::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ObservationRaw.units)
  return &units_;
}
inline const ::SCRAPIProtocol::Unit& ObservationRaw::units(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationRaw.units)
  return units_.Get(index);
}
inline ::SCRAPIProtocol::Unit* ObservationRaw::add_units() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ObservationRaw.units)
  return units_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Unit >&
ObservationRaw::units() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ObservationRaw.units)
  return units_;
}

// optional .SCRAPIProtocol.MapState map_state = 3;
inline bool ObservationRaw::has_map_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObservationRaw::set_has_map_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObservationRaw::clear_has_map_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObservationRaw::clear_map_state() {
  if (map_state_ != NULL) map_state_->Clear();
  clear_has_map_state();
}
inline const ::SCRAPIProtocol::MapState& ObservationRaw::_internal_map_state() const {
  return *map_state_;
}
inline const ::SCRAPIProtocol::MapState& ObservationRaw::map_state() const {
  const ::SCRAPIProtocol::MapState* p = map_state_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationRaw.map_state)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::MapState*>(
      &::SCRAPIProtocol::_MapState_default_instance_);
}
inline ::SCRAPIProtocol::MapState* ObservationRaw::release_map_state() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationRaw.map_state)
  clear_has_map_state();
  ::SCRAPIProtocol::MapState* temp = map_state_;
  map_state_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::MapState* ObservationRaw::mutable_map_state() {
  set_has_map_state();
  if (map_state_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::MapState>(GetArenaNoVirtual());
    map_state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationRaw.map_state)
  return map_state_;
}
inline void ObservationRaw::set_allocated_map_state(::SCRAPIProtocol::MapState* map_state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_state_;
  }
  if (map_state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_state, submessage_arena);
    }
    set_has_map_state();
  } else {
    clear_has_map_state();
  }
  map_state_ = map_state;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ObservationRaw.map_state)
}

// optional .SCRAPIProtocol.Event event = 4;
inline bool ObservationRaw::has_event() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObservationRaw::set_has_event() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObservationRaw::clear_has_event() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObservationRaw::clear_event() {
  if (event_ != NULL) event_->Clear();
  clear_has_event();
}
inline const ::SCRAPIProtocol::Event& ObservationRaw::_internal_event() const {
  return *event_;
}
inline const ::SCRAPIProtocol::Event& ObservationRaw::event() const {
  const ::SCRAPIProtocol::Event* p = event_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationRaw.event)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Event*>(
      &::SCRAPIProtocol::_Event_default_instance_);
}
inline ::SCRAPIProtocol::Event* ObservationRaw::release_event() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationRaw.event)
  clear_has_event();
  ::SCRAPIProtocol::Event* temp = event_;
  event_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Event* ObservationRaw::mutable_event() {
  set_has_event();
  if (event_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Event>(GetArenaNoVirtual());
    event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationRaw.event)
  return event_;
}
inline void ObservationRaw::set_allocated_event(::SCRAPIProtocol::Event* event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_;
  }
  if (event) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    set_has_event();
  } else {
    clear_has_event();
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ObservationRaw.event)
}

// repeated .SCRAPIProtocol.Effect effects = 5;
inline int ObservationRaw::effects_size() const {
  return effects_.size();
}
inline void ObservationRaw::clear_effects() {
  effects_.Clear();
}
inline ::SCRAPIProtocol::Effect* ObservationRaw::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationRaw.effects)
  return effects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Effect >*
ObservationRaw::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ObservationRaw.effects)
  return &effects_;
}
inline const ::SCRAPIProtocol::Effect& ObservationRaw::effects(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationRaw.effects)
  return effects_.Get(index);
}
inline ::SCRAPIProtocol::Effect* ObservationRaw::add_effects() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ObservationRaw.effects)
  return effects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Effect >&
ObservationRaw::effects() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ObservationRaw.effects)
  return effects_;
}

// -------------------------------------------------------------------

// PowerSource

// optional .SCRAPIProtocol.Point pos = 1;
inline bool PowerSource::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PowerSource::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PowerSource::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::Point& PowerSource::_internal_pos() const {
  return *pos_;
}
inline const ::SCRAPIProtocol::Point& PowerSource::pos() const {
  const ::SCRAPIProtocol::Point* p = pos_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PowerSource.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* PowerSource::release_pos() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.PowerSource.pos)
  clear_has_pos();
  ::SCRAPIProtocol::Point* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* PowerSource::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.PowerSource.pos)
  return pos_;
}
inline void PowerSource::set_allocated_pos(::SCRAPIProtocol::Point* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.PowerSource.pos)
}

// optional float radius = 2;
inline bool PowerSource::has_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PowerSource::set_has_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PowerSource::clear_has_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PowerSource::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float PowerSource::radius() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PowerSource.radius)
  return radius_;
}
inline void PowerSource::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PowerSource.radius)
}

// optional uint64 tag = 3;
inline bool PowerSource::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PowerSource::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PowerSource::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PowerSource::clear_tag() {
  tag_ = GOOGLE_ULONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::uint64 PowerSource::tag() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PowerSource.tag)
  return tag_;
}
inline void PowerSource::set_tag(::google::protobuf::uint64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PowerSource.tag)
}

// -------------------------------------------------------------------

// PlayerRaw

// repeated .SCRAPIProtocol.PowerSource power_sources = 1;
inline int PlayerRaw::power_sources_size() const {
  return power_sources_.size();
}
inline void PlayerRaw::clear_power_sources() {
  power_sources_.Clear();
}
inline ::SCRAPIProtocol::PowerSource* PlayerRaw::mutable_power_sources(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.PlayerRaw.power_sources)
  return power_sources_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PowerSource >*
PlayerRaw::mutable_power_sources() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.PlayerRaw.power_sources)
  return &power_sources_;
}
inline const ::SCRAPIProtocol::PowerSource& PlayerRaw::power_sources(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerRaw.power_sources)
  return power_sources_.Get(index);
}
inline ::SCRAPIProtocol::PowerSource* PlayerRaw::add_power_sources() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.PlayerRaw.power_sources)
  return power_sources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PowerSource >&
PlayerRaw::power_sources() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.PlayerRaw.power_sources)
  return power_sources_;
}

// optional .SCRAPIProtocol.Point camera = 2;
inline bool PlayerRaw::has_camera() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerRaw::set_has_camera() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerRaw::clear_has_camera() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::Point& PlayerRaw::_internal_camera() const {
  return *camera_;
}
inline const ::SCRAPIProtocol::Point& PlayerRaw::camera() const {
  const ::SCRAPIProtocol::Point* p = camera_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerRaw.camera)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* PlayerRaw::release_camera() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.PlayerRaw.camera)
  clear_has_camera();
  ::SCRAPIProtocol::Point* temp = camera_;
  camera_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* PlayerRaw::mutable_camera() {
  set_has_camera();
  if (camera_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    camera_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.PlayerRaw.camera)
  return camera_;
}
inline void PlayerRaw::set_allocated_camera(::SCRAPIProtocol::Point* camera) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(camera_);
  }
  if (camera) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      camera = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    set_has_camera();
  } else {
    clear_has_camera();
  }
  camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.PlayerRaw.camera)
}

// repeated uint32 upgrade_ids = 3;
inline int PlayerRaw::upgrade_ids_size() const {
  return upgrade_ids_.size();
}
inline void PlayerRaw::clear_upgrade_ids() {
  upgrade_ids_.Clear();
}
inline ::google::protobuf::uint32 PlayerRaw::upgrade_ids(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerRaw.upgrade_ids)
  return upgrade_ids_.Get(index);
}
inline void PlayerRaw::set_upgrade_ids(int index, ::google::protobuf::uint32 value) {
  upgrade_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerRaw.upgrade_ids)
}
inline void PlayerRaw::add_upgrade_ids(::google::protobuf::uint32 value) {
  upgrade_ids_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.PlayerRaw.upgrade_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PlayerRaw::upgrade_ids() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.PlayerRaw.upgrade_ids)
  return upgrade_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PlayerRaw::mutable_upgrade_ids() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.PlayerRaw.upgrade_ids)
  return &upgrade_ids_;
}

// -------------------------------------------------------------------

// UnitOrder

// optional uint32 ability_id = 1;
inline bool UnitOrder::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitOrder::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitOrder::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitOrder::clear_ability_id() {
  ability_id_ = 0u;
  clear_has_ability_id();
}
inline ::google::protobuf::uint32 UnitOrder::ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitOrder.ability_id)
  return ability_id_;
}
inline void UnitOrder::set_ability_id(::google::protobuf::uint32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitOrder.ability_id)
}

// optional .SCRAPIProtocol.Point target_world_space_pos = 2;
inline bool UnitOrder::has_target_world_space_pos() const {
  return target_case() == kTargetWorldSpacePos;
}
inline void UnitOrder::set_has_target_world_space_pos() {
  _oneof_case_[0] = kTargetWorldSpacePos;
}
inline const ::SCRAPIProtocol::Point& UnitOrder::_internal_target_world_space_pos() const {
  return *target_.target_world_space_pos_;
}
inline ::SCRAPIProtocol::Point* UnitOrder::release_target_world_space_pos() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.UnitOrder.target_world_space_pos)
  if (has_target_world_space_pos()) {
    clear_has_target();
      ::SCRAPIProtocol::Point* temp = target_.target_world_space_pos_;
    target_.target_world_space_pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::Point& UnitOrder::target_world_space_pos() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitOrder.target_world_space_pos)
  return has_target_world_space_pos()
      ? *target_.target_world_space_pos_
      : *reinterpret_cast< ::SCRAPIProtocol::Point*>(&::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* UnitOrder::mutable_target_world_space_pos() {
  if (!has_target_world_space_pos()) {
    clear_target();
    set_has_target_world_space_pos();
    target_.target_world_space_pos_ = CreateMaybeMessage< ::SCRAPIProtocol::Point >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.UnitOrder.target_world_space_pos)
  return target_.target_world_space_pos_;
}

// optional uint64 target_unit_tag = 3;
inline bool UnitOrder::has_target_unit_tag() const {
  return target_case() == kTargetUnitTag;
}
inline void UnitOrder::set_has_target_unit_tag() {
  _oneof_case_[0] = kTargetUnitTag;
}
inline void UnitOrder::clear_target_unit_tag() {
  if (has_target_unit_tag()) {
    target_.target_unit_tag_ = GOOGLE_ULONGLONG(0);
    clear_has_target();
  }
}
inline ::google::protobuf::uint64 UnitOrder::target_unit_tag() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitOrder.target_unit_tag)
  if (has_target_unit_tag()) {
    return target_.target_unit_tag_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void UnitOrder::set_target_unit_tag(::google::protobuf::uint64 value) {
  if (!has_target_unit_tag()) {
    clear_target();
    set_has_target_unit_tag();
  }
  target_.target_unit_tag_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitOrder.target_unit_tag)
}

// optional float progress = 4;
inline bool UnitOrder::has_progress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnitOrder::set_has_progress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnitOrder::clear_has_progress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnitOrder::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline float UnitOrder::progress() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitOrder.progress)
  return progress_;
}
inline void UnitOrder::set_progress(float value) {
  set_has_progress();
  progress_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitOrder.progress)
}

inline bool UnitOrder::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void UnitOrder::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline UnitOrder::TargetCase UnitOrder::target_case() const {
  return UnitOrder::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PassengerUnit

// optional uint64 tag = 1;
inline bool PassengerUnit::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PassengerUnit::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PassengerUnit::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PassengerUnit::clear_tag() {
  tag_ = GOOGLE_ULONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::uint64 PassengerUnit::tag() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PassengerUnit.tag)
  return tag_;
}
inline void PassengerUnit::set_tag(::google::protobuf::uint64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PassengerUnit.tag)
}

// optional float health = 2;
inline bool PassengerUnit::has_health() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PassengerUnit::set_has_health() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PassengerUnit::clear_has_health() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PassengerUnit::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline float PassengerUnit::health() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PassengerUnit.health)
  return health_;
}
inline void PassengerUnit::set_health(float value) {
  set_has_health();
  health_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PassengerUnit.health)
}

// optional float health_max = 3;
inline bool PassengerUnit::has_health_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PassengerUnit::set_has_health_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PassengerUnit::clear_has_health_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PassengerUnit::clear_health_max() {
  health_max_ = 0;
  clear_has_health_max();
}
inline float PassengerUnit::health_max() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PassengerUnit.health_max)
  return health_max_;
}
inline void PassengerUnit::set_health_max(float value) {
  set_has_health_max();
  health_max_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PassengerUnit.health_max)
}

// optional float shield = 4;
inline bool PassengerUnit::has_shield() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PassengerUnit::set_has_shield() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PassengerUnit::clear_has_shield() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PassengerUnit::clear_shield() {
  shield_ = 0;
  clear_has_shield();
}
inline float PassengerUnit::shield() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PassengerUnit.shield)
  return shield_;
}
inline void PassengerUnit::set_shield(float value) {
  set_has_shield();
  shield_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PassengerUnit.shield)
}

// optional float shield_max = 7;
inline bool PassengerUnit::has_shield_max() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PassengerUnit::set_has_shield_max() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PassengerUnit::clear_has_shield_max() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PassengerUnit::clear_shield_max() {
  shield_max_ = 0;
  clear_has_shield_max();
}
inline float PassengerUnit::shield_max() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PassengerUnit.shield_max)
  return shield_max_;
}
inline void PassengerUnit::set_shield_max(float value) {
  set_has_shield_max();
  shield_max_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PassengerUnit.shield_max)
}

// optional float energy = 5;
inline bool PassengerUnit::has_energy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PassengerUnit::set_has_energy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PassengerUnit::clear_has_energy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PassengerUnit::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline float PassengerUnit::energy() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PassengerUnit.energy)
  return energy_;
}
inline void PassengerUnit::set_energy(float value) {
  set_has_energy();
  energy_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PassengerUnit.energy)
}

// optional float energy_max = 8;
inline bool PassengerUnit::has_energy_max() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PassengerUnit::set_has_energy_max() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PassengerUnit::clear_has_energy_max() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PassengerUnit::clear_energy_max() {
  energy_max_ = 0;
  clear_has_energy_max();
}
inline float PassengerUnit::energy_max() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PassengerUnit.energy_max)
  return energy_max_;
}
inline void PassengerUnit::set_energy_max(float value) {
  set_has_energy_max();
  energy_max_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PassengerUnit.energy_max)
}

// optional uint32 unit_type = 6;
inline bool PassengerUnit::has_unit_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PassengerUnit::set_has_unit_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PassengerUnit::clear_has_unit_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PassengerUnit::clear_unit_type() {
  unit_type_ = 0u;
  clear_has_unit_type();
}
inline ::google::protobuf::uint32 PassengerUnit::unit_type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PassengerUnit.unit_type)
  return unit_type_;
}
inline void PassengerUnit::set_unit_type(::google::protobuf::uint32 value) {
  set_has_unit_type();
  unit_type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PassengerUnit.unit_type)
}

// -------------------------------------------------------------------

// Unit

// optional .SCRAPIProtocol.DisplayType display_type = 1;
inline bool Unit::has_display_type() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Unit::set_has_display_type() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Unit::clear_has_display_type() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Unit::clear_display_type() {
  display_type_ = 1;
  clear_has_display_type();
}
inline ::SCRAPIProtocol::DisplayType Unit::display_type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.display_type)
  return static_cast< ::SCRAPIProtocol::DisplayType >(display_type_);
}
inline void Unit::set_display_type(::SCRAPIProtocol::DisplayType value) {
  assert(::SCRAPIProtocol::DisplayType_IsValid(value));
  set_has_display_type();
  display_type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.display_type)
}

// optional .SCRAPIProtocol.Alliance alliance = 2;
inline bool Unit::has_alliance() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Unit::set_has_alliance() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Unit::clear_has_alliance() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Unit::clear_alliance() {
  alliance_ = 1;
  clear_has_alliance();
}
inline ::SCRAPIProtocol::Alliance Unit::alliance() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.alliance)
  return static_cast< ::SCRAPIProtocol::Alliance >(alliance_);
}
inline void Unit::set_alliance(::SCRAPIProtocol::Alliance value) {
  assert(::SCRAPIProtocol::Alliance_IsValid(value));
  set_has_alliance();
  alliance_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.alliance)
}

// optional uint64 tag = 3;
inline bool Unit::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Unit::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Unit::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Unit::clear_tag() {
  tag_ = GOOGLE_ULONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::uint64 Unit::tag() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.tag)
  return tag_;
}
inline void Unit::set_tag(::google::protobuf::uint64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.tag)
}

// optional uint32 unit_type = 4;
inline bool Unit::has_unit_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Unit::set_has_unit_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Unit::clear_has_unit_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Unit::clear_unit_type() {
  unit_type_ = 0u;
  clear_has_unit_type();
}
inline ::google::protobuf::uint32 Unit::unit_type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.unit_type)
  return unit_type_;
}
inline void Unit::set_unit_type(::google::protobuf::uint32 value) {
  set_has_unit_type();
  unit_type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.unit_type)
}

// optional int32 owner = 5;
inline bool Unit::has_owner() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Unit::set_has_owner() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Unit::clear_has_owner() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Unit::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Unit::owner() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.owner)
  return owner_;
}
inline void Unit::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.owner)
}

// optional .SCRAPIProtocol.Point pos = 6;
inline bool Unit::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Unit::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Unit::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::Point& Unit::_internal_pos() const {
  return *pos_;
}
inline const ::SCRAPIProtocol::Point& Unit::pos() const {
  const ::SCRAPIProtocol::Point* p = pos_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* Unit::release_pos() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Unit.pos)
  clear_has_pos();
  ::SCRAPIProtocol::Point* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* Unit::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Unit.pos)
  return pos_;
}
inline void Unit::set_allocated_pos(::SCRAPIProtocol::Point* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Unit.pos)
}

// optional float facing = 7;
inline bool Unit::has_facing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Unit::set_has_facing() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Unit::clear_has_facing() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Unit::clear_facing() {
  facing_ = 0;
  clear_has_facing();
}
inline float Unit::facing() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.facing)
  return facing_;
}
inline void Unit::set_facing(float value) {
  set_has_facing();
  facing_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.facing)
}

// optional float radius = 8;
inline bool Unit::has_radius() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Unit::set_has_radius() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Unit::clear_has_radius() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Unit::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float Unit::radius() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.radius)
  return radius_;
}
inline void Unit::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.radius)
}

// optional float build_progress = 9;
inline bool Unit::has_build_progress() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Unit::set_has_build_progress() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Unit::clear_has_build_progress() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Unit::clear_build_progress() {
  build_progress_ = 0;
  clear_has_build_progress();
}
inline float Unit::build_progress() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.build_progress)
  return build_progress_;
}
inline void Unit::set_build_progress(float value) {
  set_has_build_progress();
  build_progress_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.build_progress)
}

// optional .SCRAPIProtocol.CloakState cloak = 10;
inline bool Unit::has_cloak() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Unit::set_has_cloak() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Unit::clear_has_cloak() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Unit::clear_cloak() {
  cloak_ = 1;
  clear_has_cloak();
}
inline ::SCRAPIProtocol::CloakState Unit::cloak() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.cloak)
  return static_cast< ::SCRAPIProtocol::CloakState >(cloak_);
}
inline void Unit::set_cloak(::SCRAPIProtocol::CloakState value) {
  assert(::SCRAPIProtocol::CloakState_IsValid(value));
  set_has_cloak();
  cloak_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.cloak)
}

// optional float detect_range = 31;
inline bool Unit::has_detect_range() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Unit::set_has_detect_range() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Unit::clear_has_detect_range() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Unit::clear_detect_range() {
  detect_range_ = 0;
  clear_has_detect_range();
}
inline float Unit::detect_range() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.detect_range)
  return detect_range_;
}
inline void Unit::set_detect_range(float value) {
  set_has_detect_range();
  detect_range_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.detect_range)
}

// optional float radar_range = 32;
inline bool Unit::has_radar_range() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Unit::set_has_radar_range() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Unit::clear_has_radar_range() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Unit::clear_radar_range() {
  radar_range_ = 0;
  clear_has_radar_range();
}
inline float Unit::radar_range() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.radar_range)
  return radar_range_;
}
inline void Unit::set_radar_range(float value) {
  set_has_radar_range();
  radar_range_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.radar_range)
}

// optional bool is_selected = 11;
inline bool Unit::has_is_selected() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Unit::set_has_is_selected() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Unit::clear_has_is_selected() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Unit::clear_is_selected() {
  is_selected_ = false;
  clear_has_is_selected();
}
inline bool Unit::is_selected() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.is_selected)
  return is_selected_;
}
inline void Unit::set_is_selected(bool value) {
  set_has_is_selected();
  is_selected_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.is_selected)
}

// optional bool is_on_screen = 12;
inline bool Unit::has_is_on_screen() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Unit::set_has_is_on_screen() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Unit::clear_has_is_on_screen() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Unit::clear_is_on_screen() {
  is_on_screen_ = false;
  clear_has_is_on_screen();
}
inline bool Unit::is_on_screen() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.is_on_screen)
  return is_on_screen_;
}
inline void Unit::set_is_on_screen(bool value) {
  set_has_is_on_screen();
  is_on_screen_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.is_on_screen)
}

// optional bool is_blip = 13;
inline bool Unit::has_is_blip() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Unit::set_has_is_blip() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Unit::clear_has_is_blip() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Unit::clear_is_blip() {
  is_blip_ = false;
  clear_has_is_blip();
}
inline bool Unit::is_blip() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.is_blip)
  return is_blip_;
}
inline void Unit::set_is_blip(bool value) {
  set_has_is_blip();
  is_blip_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.is_blip)
}

// optional bool is_powered = 35;
inline bool Unit::has_is_powered() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Unit::set_has_is_powered() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Unit::clear_has_is_powered() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Unit::clear_is_powered() {
  is_powered_ = false;
  clear_has_is_powered();
}
inline bool Unit::is_powered() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.is_powered)
  return is_powered_;
}
inline void Unit::set_is_powered(bool value) {
  set_has_is_powered();
  is_powered_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.is_powered)
}

// optional float health = 14;
inline bool Unit::has_health() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Unit::set_has_health() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Unit::clear_has_health() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Unit::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline float Unit::health() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.health)
  return health_;
}
inline void Unit::set_health(float value) {
  set_has_health();
  health_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.health)
}

// optional float health_max = 15;
inline bool Unit::has_health_max() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Unit::set_has_health_max() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Unit::clear_has_health_max() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Unit::clear_health_max() {
  health_max_ = 0;
  clear_has_health_max();
}
inline float Unit::health_max() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.health_max)
  return health_max_;
}
inline void Unit::set_health_max(float value) {
  set_has_health_max();
  health_max_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.health_max)
}

// optional float shield = 16;
inline bool Unit::has_shield() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Unit::set_has_shield() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Unit::clear_has_shield() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Unit::clear_shield() {
  shield_ = 0;
  clear_has_shield();
}
inline float Unit::shield() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.shield)
  return shield_;
}
inline void Unit::set_shield(float value) {
  set_has_shield();
  shield_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.shield)
}

// optional float shield_max = 36;
inline bool Unit::has_shield_max() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Unit::set_has_shield_max() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Unit::clear_has_shield_max() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Unit::clear_shield_max() {
  shield_max_ = 0;
  clear_has_shield_max();
}
inline float Unit::shield_max() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.shield_max)
  return shield_max_;
}
inline void Unit::set_shield_max(float value) {
  set_has_shield_max();
  shield_max_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.shield_max)
}

// optional float energy = 17;
inline bool Unit::has_energy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Unit::set_has_energy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Unit::clear_has_energy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Unit::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline float Unit::energy() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.energy)
  return energy_;
}
inline void Unit::set_energy(float value) {
  set_has_energy();
  energy_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.energy)
}

// optional float energy_max = 37;
inline bool Unit::has_energy_max() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Unit::set_has_energy_max() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Unit::clear_has_energy_max() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Unit::clear_energy_max() {
  energy_max_ = 0;
  clear_has_energy_max();
}
inline float Unit::energy_max() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.energy_max)
  return energy_max_;
}
inline void Unit::set_energy_max(float value) {
  set_has_energy_max();
  energy_max_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.energy_max)
}

// optional int32 mineral_contents = 18;
inline bool Unit::has_mineral_contents() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Unit::set_has_mineral_contents() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Unit::clear_has_mineral_contents() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Unit::clear_mineral_contents() {
  mineral_contents_ = 0;
  clear_has_mineral_contents();
}
inline ::google::protobuf::int32 Unit::mineral_contents() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.mineral_contents)
  return mineral_contents_;
}
inline void Unit::set_mineral_contents(::google::protobuf::int32 value) {
  set_has_mineral_contents();
  mineral_contents_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.mineral_contents)
}

// optional int32 vespene_contents = 19;
inline bool Unit::has_vespene_contents() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Unit::set_has_vespene_contents() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Unit::clear_has_vespene_contents() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Unit::clear_vespene_contents() {
  vespene_contents_ = 0;
  clear_has_vespene_contents();
}
inline ::google::protobuf::int32 Unit::vespene_contents() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.vespene_contents)
  return vespene_contents_;
}
inline void Unit::set_vespene_contents(::google::protobuf::int32 value) {
  set_has_vespene_contents();
  vespene_contents_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.vespene_contents)
}

// optional bool is_flying = 20;
inline bool Unit::has_is_flying() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Unit::set_has_is_flying() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Unit::clear_has_is_flying() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Unit::clear_is_flying() {
  is_flying_ = false;
  clear_has_is_flying();
}
inline bool Unit::is_flying() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.is_flying)
  return is_flying_;
}
inline void Unit::set_is_flying(bool value) {
  set_has_is_flying();
  is_flying_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.is_flying)
}

// optional bool is_burrowed = 21;
inline bool Unit::has_is_burrowed() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Unit::set_has_is_burrowed() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Unit::clear_has_is_burrowed() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Unit::clear_is_burrowed() {
  is_burrowed_ = false;
  clear_has_is_burrowed();
}
inline bool Unit::is_burrowed() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.is_burrowed)
  return is_burrowed_;
}
inline void Unit::set_is_burrowed(bool value) {
  set_has_is_burrowed();
  is_burrowed_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.is_burrowed)
}

// repeated .SCRAPIProtocol.UnitOrder orders = 22;
inline int Unit::orders_size() const {
  return orders_.size();
}
inline void Unit::clear_orders() {
  orders_.Clear();
}
inline ::SCRAPIProtocol::UnitOrder* Unit::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Unit.orders)
  return orders_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitOrder >*
Unit::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.Unit.orders)
  return &orders_;
}
inline const ::SCRAPIProtocol::UnitOrder& Unit::orders(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.orders)
  return orders_.Get(index);
}
inline ::SCRAPIProtocol::UnitOrder* Unit::add_orders() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.Unit.orders)
  return orders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitOrder >&
Unit::orders() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.Unit.orders)
  return orders_;
}

// optional uint64 add_on_tag = 23;
inline bool Unit::has_add_on_tag() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Unit::set_has_add_on_tag() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Unit::clear_has_add_on_tag() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Unit::clear_add_on_tag() {
  add_on_tag_ = GOOGLE_ULONGLONG(0);
  clear_has_add_on_tag();
}
inline ::google::protobuf::uint64 Unit::add_on_tag() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.add_on_tag)
  return add_on_tag_;
}
inline void Unit::set_add_on_tag(::google::protobuf::uint64 value) {
  set_has_add_on_tag();
  add_on_tag_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.add_on_tag)
}

// repeated .SCRAPIProtocol.PassengerUnit passengers = 24;
inline int Unit::passengers_size() const {
  return passengers_.size();
}
inline void Unit::clear_passengers() {
  passengers_.Clear();
}
inline ::SCRAPIProtocol::PassengerUnit* Unit::mutable_passengers(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Unit.passengers)
  return passengers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PassengerUnit >*
Unit::mutable_passengers() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.Unit.passengers)
  return &passengers_;
}
inline const ::SCRAPIProtocol::PassengerUnit& Unit::passengers(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.passengers)
  return passengers_.Get(index);
}
inline ::SCRAPIProtocol::PassengerUnit* Unit::add_passengers() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.Unit.passengers)
  return passengers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PassengerUnit >&
Unit::passengers() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.Unit.passengers)
  return passengers_;
}

// optional int32 cargo_space_taken = 25;
inline bool Unit::has_cargo_space_taken() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Unit::set_has_cargo_space_taken() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Unit::clear_has_cargo_space_taken() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Unit::clear_cargo_space_taken() {
  cargo_space_taken_ = 0;
  clear_has_cargo_space_taken();
}
inline ::google::protobuf::int32 Unit::cargo_space_taken() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.cargo_space_taken)
  return cargo_space_taken_;
}
inline void Unit::set_cargo_space_taken(::google::protobuf::int32 value) {
  set_has_cargo_space_taken();
  cargo_space_taken_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.cargo_space_taken)
}

// optional int32 cargo_space_max = 26;
inline bool Unit::has_cargo_space_max() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Unit::set_has_cargo_space_max() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Unit::clear_has_cargo_space_max() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Unit::clear_cargo_space_max() {
  cargo_space_max_ = 0;
  clear_has_cargo_space_max();
}
inline ::google::protobuf::int32 Unit::cargo_space_max() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.cargo_space_max)
  return cargo_space_max_;
}
inline void Unit::set_cargo_space_max(::google::protobuf::int32 value) {
  set_has_cargo_space_max();
  cargo_space_max_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.cargo_space_max)
}

// repeated uint32 buff_ids = 27;
inline int Unit::buff_ids_size() const {
  return buff_ids_.size();
}
inline void Unit::clear_buff_ids() {
  buff_ids_.Clear();
}
inline ::google::protobuf::uint32 Unit::buff_ids(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.buff_ids)
  return buff_ids_.Get(index);
}
inline void Unit::set_buff_ids(int index, ::google::protobuf::uint32 value) {
  buff_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.buff_ids)
}
inline void Unit::add_buff_ids(::google::protobuf::uint32 value) {
  buff_ids_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.Unit.buff_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Unit::buff_ids() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.Unit.buff_ids)
  return buff_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Unit::mutable_buff_ids() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.Unit.buff_ids)
  return &buff_ids_;
}

// optional int32 assigned_harvesters = 28;
inline bool Unit::has_assigned_harvesters() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Unit::set_has_assigned_harvesters() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Unit::clear_has_assigned_harvesters() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Unit::clear_assigned_harvesters() {
  assigned_harvesters_ = 0;
  clear_has_assigned_harvesters();
}
inline ::google::protobuf::int32 Unit::assigned_harvesters() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.assigned_harvesters)
  return assigned_harvesters_;
}
inline void Unit::set_assigned_harvesters(::google::protobuf::int32 value) {
  set_has_assigned_harvesters();
  assigned_harvesters_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.assigned_harvesters)
}

// optional int32 ideal_harvesters = 29;
inline bool Unit::has_ideal_harvesters() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Unit::set_has_ideal_harvesters() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Unit::clear_has_ideal_harvesters() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Unit::clear_ideal_harvesters() {
  ideal_harvesters_ = 0;
  clear_has_ideal_harvesters();
}
inline ::google::protobuf::int32 Unit::ideal_harvesters() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.ideal_harvesters)
  return ideal_harvesters_;
}
inline void Unit::set_ideal_harvesters(::google::protobuf::int32 value) {
  set_has_ideal_harvesters();
  ideal_harvesters_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.ideal_harvesters)
}

// optional float weapon_cooldown = 30;
inline bool Unit::has_weapon_cooldown() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Unit::set_has_weapon_cooldown() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Unit::clear_has_weapon_cooldown() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Unit::clear_weapon_cooldown() {
  weapon_cooldown_ = 0;
  clear_has_weapon_cooldown();
}
inline float Unit::weapon_cooldown() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.weapon_cooldown)
  return weapon_cooldown_;
}
inline void Unit::set_weapon_cooldown(float value) {
  set_has_weapon_cooldown();
  weapon_cooldown_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.weapon_cooldown)
}

// optional uint64 engaged_target_tag = 34;
inline bool Unit::has_engaged_target_tag() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Unit::set_has_engaged_target_tag() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Unit::clear_has_engaged_target_tag() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Unit::clear_engaged_target_tag() {
  engaged_target_tag_ = GOOGLE_ULONGLONG(0);
  clear_has_engaged_target_tag();
}
inline ::google::protobuf::uint64 Unit::engaged_target_tag() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Unit.engaged_target_tag)
  return engaged_target_tag_;
}
inline void Unit::set_engaged_target_tag(::google::protobuf::uint64 value) {
  set_has_engaged_target_tag();
  engaged_target_tag_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Unit.engaged_target_tag)
}

// -------------------------------------------------------------------

// MapState

// optional .SCRAPIProtocol.ImageData visibility = 1;
inline bool MapState::has_visibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapState::set_has_visibility() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapState::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::ImageData& MapState::_internal_visibility() const {
  return *visibility_;
}
inline const ::SCRAPIProtocol::ImageData& MapState::visibility() const {
  const ::SCRAPIProtocol::ImageData* p = visibility_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.MapState.visibility)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* MapState::release_visibility() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.MapState.visibility)
  clear_has_visibility();
  ::SCRAPIProtocol::ImageData* temp = visibility_;
  visibility_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* MapState::mutable_visibility() {
  set_has_visibility();
  if (visibility_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    visibility_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.MapState.visibility)
  return visibility_;
}
inline void MapState::set_allocated_visibility(::SCRAPIProtocol::ImageData* visibility) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(visibility_);
  }
  if (visibility) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      visibility = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    set_has_visibility();
  } else {
    clear_has_visibility();
  }
  visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.MapState.visibility)
}

// optional .SCRAPIProtocol.ImageData creep = 2;
inline bool MapState::has_creep() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapState::set_has_creep() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapState::clear_has_creep() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::ImageData& MapState::_internal_creep() const {
  return *creep_;
}
inline const ::SCRAPIProtocol::ImageData& MapState::creep() const {
  const ::SCRAPIProtocol::ImageData* p = creep_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.MapState.creep)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* MapState::release_creep() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.MapState.creep)
  clear_has_creep();
  ::SCRAPIProtocol::ImageData* temp = creep_;
  creep_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* MapState::mutable_creep() {
  set_has_creep();
  if (creep_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    creep_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.MapState.creep)
  return creep_;
}
inline void MapState::set_allocated_creep(::SCRAPIProtocol::ImageData* creep) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(creep_);
  }
  if (creep) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      creep = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, creep, submessage_arena);
    }
    set_has_creep();
  } else {
    clear_has_creep();
  }
  creep_ = creep;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.MapState.creep)
}

// -------------------------------------------------------------------

// Event

// repeated uint64 dead_units = 1;
inline int Event::dead_units_size() const {
  return dead_units_.size();
}
inline void Event::clear_dead_units() {
  dead_units_.Clear();
}
inline ::google::protobuf::uint64 Event::dead_units(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Event.dead_units)
  return dead_units_.Get(index);
}
inline void Event::set_dead_units(int index, ::google::protobuf::uint64 value) {
  dead_units_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Event.dead_units)
}
inline void Event::add_dead_units(::google::protobuf::uint64 value) {
  dead_units_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.Event.dead_units)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Event::dead_units() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.Event.dead_units)
  return dead_units_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Event::mutable_dead_units() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.Event.dead_units)
  return &dead_units_;
}

// -------------------------------------------------------------------

// Effect

// optional uint32 effect_id = 1;
inline bool Effect::has_effect_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Effect::set_has_effect_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Effect::clear_has_effect_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Effect::clear_effect_id() {
  effect_id_ = 0u;
  clear_has_effect_id();
}
inline ::google::protobuf::uint32 Effect::effect_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Effect.effect_id)
  return effect_id_;
}
inline void Effect::set_effect_id(::google::protobuf::uint32 value) {
  set_has_effect_id();
  effect_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Effect.effect_id)
}

// repeated .SCRAPIProtocol.Point2D pos = 2;
inline int Effect::pos_size() const {
  return pos_.size();
}
inline ::SCRAPIProtocol::Point2D* Effect::mutable_pos(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Effect.pos)
  return pos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Point2D >*
Effect::mutable_pos() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.Effect.pos)
  return &pos_;
}
inline const ::SCRAPIProtocol::Point2D& Effect::pos(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Effect.pos)
  return pos_.Get(index);
}
inline ::SCRAPIProtocol::Point2D* Effect::add_pos() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.Effect.pos)
  return pos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Point2D >&
Effect::pos() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.Effect.pos)
  return pos_;
}

// -------------------------------------------------------------------

// ActionRaw

// optional .SCRAPIProtocol.ActionRawUnitCommand unit_command = 1;
inline bool ActionRaw::has_unit_command() const {
  return action_case() == kUnitCommand;
}
inline void ActionRaw::set_has_unit_command() {
  _oneof_case_[0] = kUnitCommand;
}
inline void ActionRaw::clear_unit_command() {
  if (has_unit_command()) {
    delete action_.unit_command_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionRawUnitCommand& ActionRaw::_internal_unit_command() const {
  return *action_.unit_command_;
}
inline ::SCRAPIProtocol::ActionRawUnitCommand* ActionRaw::release_unit_command() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionRaw.unit_command)
  if (has_unit_command()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionRawUnitCommand* temp = action_.unit_command_;
    action_.unit_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionRawUnitCommand& ActionRaw::unit_command() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRaw.unit_command)
  return has_unit_command()
      ? *action_.unit_command_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionRawUnitCommand*>(&::SCRAPIProtocol::_ActionRawUnitCommand_default_instance_);
}
inline ::SCRAPIProtocol::ActionRawUnitCommand* ActionRaw::mutable_unit_command() {
  if (!has_unit_command()) {
    clear_action();
    set_has_unit_command();
    action_.unit_command_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionRawUnitCommand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionRaw.unit_command)
  return action_.unit_command_;
}

// optional .SCRAPIProtocol.ActionRawCameraMove camera_move = 2;
inline bool ActionRaw::has_camera_move() const {
  return action_case() == kCameraMove;
}
inline void ActionRaw::set_has_camera_move() {
  _oneof_case_[0] = kCameraMove;
}
inline void ActionRaw::clear_camera_move() {
  if (has_camera_move()) {
    delete action_.camera_move_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionRawCameraMove& ActionRaw::_internal_camera_move() const {
  return *action_.camera_move_;
}
inline ::SCRAPIProtocol::ActionRawCameraMove* ActionRaw::release_camera_move() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionRaw.camera_move)
  if (has_camera_move()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionRawCameraMove* temp = action_.camera_move_;
    action_.camera_move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionRawCameraMove& ActionRaw::camera_move() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRaw.camera_move)
  return has_camera_move()
      ? *action_.camera_move_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionRawCameraMove*>(&::SCRAPIProtocol::_ActionRawCameraMove_default_instance_);
}
inline ::SCRAPIProtocol::ActionRawCameraMove* ActionRaw::mutable_camera_move() {
  if (!has_camera_move()) {
    clear_action();
    set_has_camera_move();
    action_.camera_move_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionRawCameraMove >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionRaw.camera_move)
  return action_.camera_move_;
}

// optional .SCRAPIProtocol.ActionRawToggleAutocast toggle_autocast = 3;
inline bool ActionRaw::has_toggle_autocast() const {
  return action_case() == kToggleAutocast;
}
inline void ActionRaw::set_has_toggle_autocast() {
  _oneof_case_[0] = kToggleAutocast;
}
inline void ActionRaw::clear_toggle_autocast() {
  if (has_toggle_autocast()) {
    delete action_.toggle_autocast_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionRawToggleAutocast& ActionRaw::_internal_toggle_autocast() const {
  return *action_.toggle_autocast_;
}
inline ::SCRAPIProtocol::ActionRawToggleAutocast* ActionRaw::release_toggle_autocast() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionRaw.toggle_autocast)
  if (has_toggle_autocast()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionRawToggleAutocast* temp = action_.toggle_autocast_;
    action_.toggle_autocast_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionRawToggleAutocast& ActionRaw::toggle_autocast() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRaw.toggle_autocast)
  return has_toggle_autocast()
      ? *action_.toggle_autocast_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionRawToggleAutocast*>(&::SCRAPIProtocol::_ActionRawToggleAutocast_default_instance_);
}
inline ::SCRAPIProtocol::ActionRawToggleAutocast* ActionRaw::mutable_toggle_autocast() {
  if (!has_toggle_autocast()) {
    clear_action();
    set_has_toggle_autocast();
    action_.toggle_autocast_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionRawToggleAutocast >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionRaw.toggle_autocast)
  return action_.toggle_autocast_;
}

inline bool ActionRaw::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionRaw::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionRaw::ActionCase ActionRaw::action_case() const {
  return ActionRaw::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionRawUnitCommand

// optional int32 ability_id = 1;
inline bool ActionRawUnitCommand::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionRawUnitCommand::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionRawUnitCommand::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionRawUnitCommand::clear_ability_id() {
  ability_id_ = 0;
  clear_has_ability_id();
}
inline ::google::protobuf::int32 ActionRawUnitCommand::ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRawUnitCommand.ability_id)
  return ability_id_;
}
inline void ActionRawUnitCommand::set_ability_id(::google::protobuf::int32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionRawUnitCommand.ability_id)
}

// optional .SCRAPIProtocol.Point2D target_world_space_pos = 2;
inline bool ActionRawUnitCommand::has_target_world_space_pos() const {
  return target_case() == kTargetWorldSpacePos;
}
inline void ActionRawUnitCommand::set_has_target_world_space_pos() {
  _oneof_case_[0] = kTargetWorldSpacePos;
}
inline const ::SCRAPIProtocol::Point2D& ActionRawUnitCommand::_internal_target_world_space_pos() const {
  return *target_.target_world_space_pos_;
}
inline ::SCRAPIProtocol::Point2D* ActionRawUnitCommand::release_target_world_space_pos() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionRawUnitCommand.target_world_space_pos)
  if (has_target_world_space_pos()) {
    clear_has_target();
      ::SCRAPIProtocol::Point2D* temp = target_.target_world_space_pos_;
    target_.target_world_space_pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::Point2D& ActionRawUnitCommand::target_world_space_pos() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRawUnitCommand.target_world_space_pos)
  return has_target_world_space_pos()
      ? *target_.target_world_space_pos_
      : *reinterpret_cast< ::SCRAPIProtocol::Point2D*>(&::SCRAPIProtocol::_Point2D_default_instance_);
}
inline ::SCRAPIProtocol::Point2D* ActionRawUnitCommand::mutable_target_world_space_pos() {
  if (!has_target_world_space_pos()) {
    clear_target();
    set_has_target_world_space_pos();
    target_.target_world_space_pos_ = CreateMaybeMessage< ::SCRAPIProtocol::Point2D >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionRawUnitCommand.target_world_space_pos)
  return target_.target_world_space_pos_;
}

// optional uint64 target_unit_tag = 3;
inline bool ActionRawUnitCommand::has_target_unit_tag() const {
  return target_case() == kTargetUnitTag;
}
inline void ActionRawUnitCommand::set_has_target_unit_tag() {
  _oneof_case_[0] = kTargetUnitTag;
}
inline void ActionRawUnitCommand::clear_target_unit_tag() {
  if (has_target_unit_tag()) {
    target_.target_unit_tag_ = GOOGLE_ULONGLONG(0);
    clear_has_target();
  }
}
inline ::google::protobuf::uint64 ActionRawUnitCommand::target_unit_tag() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRawUnitCommand.target_unit_tag)
  if (has_target_unit_tag()) {
    return target_.target_unit_tag_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void ActionRawUnitCommand::set_target_unit_tag(::google::protobuf::uint64 value) {
  if (!has_target_unit_tag()) {
    clear_target();
    set_has_target_unit_tag();
  }
  target_.target_unit_tag_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionRawUnitCommand.target_unit_tag)
}

// repeated uint64 unit_tags = 4;
inline int ActionRawUnitCommand::unit_tags_size() const {
  return unit_tags_.size();
}
inline void ActionRawUnitCommand::clear_unit_tags() {
  unit_tags_.Clear();
}
inline ::google::protobuf::uint64 ActionRawUnitCommand::unit_tags(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRawUnitCommand.unit_tags)
  return unit_tags_.Get(index);
}
inline void ActionRawUnitCommand::set_unit_tags(int index, ::google::protobuf::uint64 value) {
  unit_tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionRawUnitCommand.unit_tags)
}
inline void ActionRawUnitCommand::add_unit_tags(::google::protobuf::uint64 value) {
  unit_tags_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ActionRawUnitCommand.unit_tags)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ActionRawUnitCommand::unit_tags() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ActionRawUnitCommand.unit_tags)
  return unit_tags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ActionRawUnitCommand::mutable_unit_tags() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ActionRawUnitCommand.unit_tags)
  return &unit_tags_;
}

// optional bool queue_command = 5;
inline bool ActionRawUnitCommand::has_queue_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionRawUnitCommand::set_has_queue_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionRawUnitCommand::clear_has_queue_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionRawUnitCommand::clear_queue_command() {
  queue_command_ = false;
  clear_has_queue_command();
}
inline bool ActionRawUnitCommand::queue_command() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRawUnitCommand.queue_command)
  return queue_command_;
}
inline void ActionRawUnitCommand::set_queue_command(bool value) {
  set_has_queue_command();
  queue_command_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionRawUnitCommand.queue_command)
}

inline bool ActionRawUnitCommand::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void ActionRawUnitCommand::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline ActionRawUnitCommand::TargetCase ActionRawUnitCommand::target_case() const {
  return ActionRawUnitCommand::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionRawCameraMove

// optional .SCRAPIProtocol.Point center_world_space = 1;
inline bool ActionRawCameraMove::has_center_world_space() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionRawCameraMove::set_has_center_world_space() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionRawCameraMove::clear_has_center_world_space() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::Point& ActionRawCameraMove::_internal_center_world_space() const {
  return *center_world_space_;
}
inline const ::SCRAPIProtocol::Point& ActionRawCameraMove::center_world_space() const {
  const ::SCRAPIProtocol::Point* p = center_world_space_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRawCameraMove.center_world_space)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point*>(
      &::SCRAPIProtocol::_Point_default_instance_);
}
inline ::SCRAPIProtocol::Point* ActionRawCameraMove::release_center_world_space() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionRawCameraMove.center_world_space)
  clear_has_center_world_space();
  ::SCRAPIProtocol::Point* temp = center_world_space_;
  center_world_space_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point* ActionRawCameraMove::mutable_center_world_space() {
  set_has_center_world_space();
  if (center_world_space_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point>(GetArenaNoVirtual());
    center_world_space_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionRawCameraMove.center_world_space)
  return center_world_space_;
}
inline void ActionRawCameraMove::set_allocated_center_world_space(::SCRAPIProtocol::Point* center_world_space) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(center_world_space_);
  }
  if (center_world_space) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center_world_space = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center_world_space, submessage_arena);
    }
    set_has_center_world_space();
  } else {
    clear_has_center_world_space();
  }
  center_world_space_ = center_world_space;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ActionRawCameraMove.center_world_space)
}

// -------------------------------------------------------------------

// ActionRawToggleAutocast

// optional int32 ability_id = 1;
inline bool ActionRawToggleAutocast::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionRawToggleAutocast::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionRawToggleAutocast::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionRawToggleAutocast::clear_ability_id() {
  ability_id_ = 0;
  clear_has_ability_id();
}
inline ::google::protobuf::int32 ActionRawToggleAutocast::ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRawToggleAutocast.ability_id)
  return ability_id_;
}
inline void ActionRawToggleAutocast::set_ability_id(::google::protobuf::int32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionRawToggleAutocast.ability_id)
}

// repeated uint64 unit_tags = 2;
inline int ActionRawToggleAutocast::unit_tags_size() const {
  return unit_tags_.size();
}
inline void ActionRawToggleAutocast::clear_unit_tags() {
  unit_tags_.Clear();
}
inline ::google::protobuf::uint64 ActionRawToggleAutocast::unit_tags(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionRawToggleAutocast.unit_tags)
  return unit_tags_.Get(index);
}
inline void ActionRawToggleAutocast::set_unit_tags(int index, ::google::protobuf::uint64 value) {
  unit_tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionRawToggleAutocast.unit_tags)
}
inline void ActionRawToggleAutocast::add_unit_tags(::google::protobuf::uint64 value) {
  unit_tags_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ActionRawToggleAutocast.unit_tags)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ActionRawToggleAutocast::unit_tags() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ActionRawToggleAutocast.unit_tags)
  return unit_tags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ActionRawToggleAutocast::mutable_unit_tags() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ActionRawToggleAutocast.unit_tags)
  return &unit_tags_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SCRAPIProtocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SCRAPIProtocol::DisplayType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::DisplayType>() {
  return ::SCRAPIProtocol::DisplayType_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::Alliance> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::Alliance>() {
  return ::SCRAPIProtocol::Alliance_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::CloakState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::CloakState>() {
  return ::SCRAPIProtocol::CloakState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_raw_2eproto
