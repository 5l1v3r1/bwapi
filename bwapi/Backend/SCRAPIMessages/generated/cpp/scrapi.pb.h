// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scrapi.proto

#ifndef PROTOBUF_INCLUDED_scrapi_2eproto
#define PROTOBUF_INCLUDED_scrapi_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "data.pb.h"
#include "debug.pb.h"
#include "error.pb.h"
#include "query.pb.h"
#include "raw.pb.h"
#include "score.pb.h"
#include "spatial.pb.h"
#include "ui.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_scrapi_2eproto 

namespace protobuf_scrapi_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[65];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_scrapi_2eproto
namespace SCRAPIProtocol {
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class ActionChat;
class ActionChatDefaultTypeInternal;
extern ActionChatDefaultTypeInternal _ActionChat_default_instance_;
class ActionError;
class ActionErrorDefaultTypeInternal;
extern ActionErrorDefaultTypeInternal _ActionError_default_instance_;
class ActionObserverCameraFollowPlayer;
class ActionObserverCameraFollowPlayerDefaultTypeInternal;
extern ActionObserverCameraFollowPlayerDefaultTypeInternal _ActionObserverCameraFollowPlayer_default_instance_;
class ActionObserverCameraFollowUnits;
class ActionObserverCameraFollowUnitsDefaultTypeInternal;
extern ActionObserverCameraFollowUnitsDefaultTypeInternal _ActionObserverCameraFollowUnits_default_instance_;
class ActionObserverCameraMove;
class ActionObserverCameraMoveDefaultTypeInternal;
extern ActionObserverCameraMoveDefaultTypeInternal _ActionObserverCameraMove_default_instance_;
class ActionObserverPlayerPerspective;
class ActionObserverPlayerPerspectiveDefaultTypeInternal;
extern ActionObserverPlayerPerspectiveDefaultTypeInternal _ActionObserverPlayerPerspective_default_instance_;
class ChatReceived;
class ChatReceivedDefaultTypeInternal;
extern ChatReceivedDefaultTypeInternal _ChatReceived_default_instance_;
class InterfaceOptions;
class InterfaceOptionsDefaultTypeInternal;
extern InterfaceOptionsDefaultTypeInternal _InterfaceOptions_default_instance_;
class LocalMap;
class LocalMapDefaultTypeInternal;
extern LocalMapDefaultTypeInternal _LocalMap_default_instance_;
class Observation;
class ObservationDefaultTypeInternal;
extern ObservationDefaultTypeInternal _Observation_default_instance_;
class ObserverAction;
class ObserverActionDefaultTypeInternal;
extern ObserverActionDefaultTypeInternal _ObserverAction_default_instance_;
class PlayerCommon;
class PlayerCommonDefaultTypeInternal;
extern PlayerCommonDefaultTypeInternal _PlayerCommon_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerInfoExtra;
class PlayerInfoExtraDefaultTypeInternal;
extern PlayerInfoExtraDefaultTypeInternal _PlayerInfoExtra_default_instance_;
class PlayerResult;
class PlayerResultDefaultTypeInternal;
extern PlayerResultDefaultTypeInternal _PlayerResult_default_instance_;
class PlayerSetup;
class PlayerSetupDefaultTypeInternal;
extern PlayerSetupDefaultTypeInternal _PlayerSetup_default_instance_;
class PortSet;
class PortSetDefaultTypeInternal;
extern PortSetDefaultTypeInternal _PortSet_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestAction;
class RequestActionDefaultTypeInternal;
extern RequestActionDefaultTypeInternal _RequestAction_default_instance_;
class RequestAvailableMaps;
class RequestAvailableMapsDefaultTypeInternal;
extern RequestAvailableMapsDefaultTypeInternal _RequestAvailableMaps_default_instance_;
class RequestConnect;
class RequestConnectDefaultTypeInternal;
extern RequestConnectDefaultTypeInternal _RequestConnect_default_instance_;
class RequestCreateGame;
class RequestCreateGameDefaultTypeInternal;
extern RequestCreateGameDefaultTypeInternal _RequestCreateGame_default_instance_;
class RequestData;
class RequestDataDefaultTypeInternal;
extern RequestDataDefaultTypeInternal _RequestData_default_instance_;
class RequestDebug;
class RequestDebugDefaultTypeInternal;
extern RequestDebugDefaultTypeInternal _RequestDebug_default_instance_;
class RequestEndOfQueue;
class RequestEndOfQueueDefaultTypeInternal;
extern RequestEndOfQueueDefaultTypeInternal _RequestEndOfQueue_default_instance_;
class RequestGameInfo;
class RequestGameInfoDefaultTypeInternal;
extern RequestGameInfoDefaultTypeInternal _RequestGameInfo_default_instance_;
class RequestJoinGame;
class RequestJoinGameDefaultTypeInternal;
extern RequestJoinGameDefaultTypeInternal _RequestJoinGame_default_instance_;
class RequestLeaveGame;
class RequestLeaveGameDefaultTypeInternal;
extern RequestLeaveGameDefaultTypeInternal _RequestLeaveGame_default_instance_;
class RequestObservation;
class RequestObservationDefaultTypeInternal;
extern RequestObservationDefaultTypeInternal _RequestObservation_default_instance_;
class RequestObserverAction;
class RequestObserverActionDefaultTypeInternal;
extern RequestObserverActionDefaultTypeInternal _RequestObserverAction_default_instance_;
class RequestPing;
class RequestPingDefaultTypeInternal;
extern RequestPingDefaultTypeInternal _RequestPing_default_instance_;
class RequestQuickLoad;
class RequestQuickLoadDefaultTypeInternal;
extern RequestQuickLoadDefaultTypeInternal _RequestQuickLoad_default_instance_;
class RequestQuickSave;
class RequestQuickSaveDefaultTypeInternal;
extern RequestQuickSaveDefaultTypeInternal _RequestQuickSave_default_instance_;
class RequestQuit;
class RequestQuitDefaultTypeInternal;
extern RequestQuitDefaultTypeInternal _RequestQuit_default_instance_;
class RequestReplayInfo;
class RequestReplayInfoDefaultTypeInternal;
extern RequestReplayInfoDefaultTypeInternal _RequestReplayInfo_default_instance_;
class RequestRestartGame;
class RequestRestartGameDefaultTypeInternal;
extern RequestRestartGameDefaultTypeInternal _RequestRestartGame_default_instance_;
class RequestSaveMap;
class RequestSaveMapDefaultTypeInternal;
extern RequestSaveMapDefaultTypeInternal _RequestSaveMap_default_instance_;
class RequestSaveReplay;
class RequestSaveReplayDefaultTypeInternal;
extern RequestSaveReplayDefaultTypeInternal _RequestSaveReplay_default_instance_;
class RequestStartReplay;
class RequestStartReplayDefaultTypeInternal;
extern RequestStartReplayDefaultTypeInternal _RequestStartReplay_default_instance_;
class RequestStep;
class RequestStepDefaultTypeInternal;
extern RequestStepDefaultTypeInternal _RequestStep_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseAction;
class ResponseActionDefaultTypeInternal;
extern ResponseActionDefaultTypeInternal _ResponseAction_default_instance_;
class ResponseAvailableMaps;
class ResponseAvailableMapsDefaultTypeInternal;
extern ResponseAvailableMapsDefaultTypeInternal _ResponseAvailableMaps_default_instance_;
class ResponseConnect;
class ResponseConnectDefaultTypeInternal;
extern ResponseConnectDefaultTypeInternal _ResponseConnect_default_instance_;
class ResponseCreateGame;
class ResponseCreateGameDefaultTypeInternal;
extern ResponseCreateGameDefaultTypeInternal _ResponseCreateGame_default_instance_;
class ResponseData;
class ResponseDataDefaultTypeInternal;
extern ResponseDataDefaultTypeInternal _ResponseData_default_instance_;
class ResponseDebug;
class ResponseDebugDefaultTypeInternal;
extern ResponseDebugDefaultTypeInternal _ResponseDebug_default_instance_;
class ResponseEndOfQueue;
class ResponseEndOfQueueDefaultTypeInternal;
extern ResponseEndOfQueueDefaultTypeInternal _ResponseEndOfQueue_default_instance_;
class ResponseGameInfo;
class ResponseGameInfoDefaultTypeInternal;
extern ResponseGameInfoDefaultTypeInternal _ResponseGameInfo_default_instance_;
class ResponseJoinGame;
class ResponseJoinGameDefaultTypeInternal;
extern ResponseJoinGameDefaultTypeInternal _ResponseJoinGame_default_instance_;
class ResponseLeaveGame;
class ResponseLeaveGameDefaultTypeInternal;
extern ResponseLeaveGameDefaultTypeInternal _ResponseLeaveGame_default_instance_;
class ResponseObservation;
class ResponseObservationDefaultTypeInternal;
extern ResponseObservationDefaultTypeInternal _ResponseObservation_default_instance_;
class ResponseObserverAction;
class ResponseObserverActionDefaultTypeInternal;
extern ResponseObserverActionDefaultTypeInternal _ResponseObserverAction_default_instance_;
class ResponsePing;
class ResponsePingDefaultTypeInternal;
extern ResponsePingDefaultTypeInternal _ResponsePing_default_instance_;
class ResponseQuickLoad;
class ResponseQuickLoadDefaultTypeInternal;
extern ResponseQuickLoadDefaultTypeInternal _ResponseQuickLoad_default_instance_;
class ResponseQuickSave;
class ResponseQuickSaveDefaultTypeInternal;
extern ResponseQuickSaveDefaultTypeInternal _ResponseQuickSave_default_instance_;
class ResponseQuit;
class ResponseQuitDefaultTypeInternal;
extern ResponseQuitDefaultTypeInternal _ResponseQuit_default_instance_;
class ResponseReplayInfo;
class ResponseReplayInfoDefaultTypeInternal;
extern ResponseReplayInfoDefaultTypeInternal _ResponseReplayInfo_default_instance_;
class ResponseRestartGame;
class ResponseRestartGameDefaultTypeInternal;
extern ResponseRestartGameDefaultTypeInternal _ResponseRestartGame_default_instance_;
class ResponseSaveMap;
class ResponseSaveMapDefaultTypeInternal;
extern ResponseSaveMapDefaultTypeInternal _ResponseSaveMap_default_instance_;
class ResponseSaveReplay;
class ResponseSaveReplayDefaultTypeInternal;
extern ResponseSaveReplayDefaultTypeInternal _ResponseSaveReplay_default_instance_;
class ResponseStartReplay;
class ResponseStartReplayDefaultTypeInternal;
extern ResponseStartReplayDefaultTypeInternal _ResponseStartReplay_default_instance_;
class ResponseStep;
class ResponseStepDefaultTypeInternal;
extern ResponseStepDefaultTypeInternal _ResponseStep_default_instance_;
class SpatialCameraSetup;
class SpatialCameraSetupDefaultTypeInternal;
extern SpatialCameraSetupDefaultTypeInternal _SpatialCameraSetup_default_instance_;
}  // namespace SCRAPIProtocol
namespace google {
namespace protobuf {
template<> ::SCRAPIProtocol::Action* Arena::CreateMaybeMessage<::SCRAPIProtocol::Action>(Arena*);
template<> ::SCRAPIProtocol::ActionChat* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionChat>(Arena*);
template<> ::SCRAPIProtocol::ActionError* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionError>(Arena*);
template<> ::SCRAPIProtocol::ActionObserverCameraFollowPlayer* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionObserverCameraFollowPlayer>(Arena*);
template<> ::SCRAPIProtocol::ActionObserverCameraFollowUnits* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionObserverCameraFollowUnits>(Arena*);
template<> ::SCRAPIProtocol::ActionObserverCameraMove* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionObserverCameraMove>(Arena*);
template<> ::SCRAPIProtocol::ActionObserverPlayerPerspective* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionObserverPlayerPerspective>(Arena*);
template<> ::SCRAPIProtocol::ChatReceived* Arena::CreateMaybeMessage<::SCRAPIProtocol::ChatReceived>(Arena*);
template<> ::SCRAPIProtocol::InterfaceOptions* Arena::CreateMaybeMessage<::SCRAPIProtocol::InterfaceOptions>(Arena*);
template<> ::SCRAPIProtocol::LocalMap* Arena::CreateMaybeMessage<::SCRAPIProtocol::LocalMap>(Arena*);
template<> ::SCRAPIProtocol::Observation* Arena::CreateMaybeMessage<::SCRAPIProtocol::Observation>(Arena*);
template<> ::SCRAPIProtocol::ObserverAction* Arena::CreateMaybeMessage<::SCRAPIProtocol::ObserverAction>(Arena*);
template<> ::SCRAPIProtocol::PlayerCommon* Arena::CreateMaybeMessage<::SCRAPIProtocol::PlayerCommon>(Arena*);
template<> ::SCRAPIProtocol::PlayerInfo* Arena::CreateMaybeMessage<::SCRAPIProtocol::PlayerInfo>(Arena*);
template<> ::SCRAPIProtocol::PlayerInfoExtra* Arena::CreateMaybeMessage<::SCRAPIProtocol::PlayerInfoExtra>(Arena*);
template<> ::SCRAPIProtocol::PlayerResult* Arena::CreateMaybeMessage<::SCRAPIProtocol::PlayerResult>(Arena*);
template<> ::SCRAPIProtocol::PlayerSetup* Arena::CreateMaybeMessage<::SCRAPIProtocol::PlayerSetup>(Arena*);
template<> ::SCRAPIProtocol::PortSet* Arena::CreateMaybeMessage<::SCRAPIProtocol::PortSet>(Arena*);
template<> ::SCRAPIProtocol::Request* Arena::CreateMaybeMessage<::SCRAPIProtocol::Request>(Arena*);
template<> ::SCRAPIProtocol::RequestAction* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestAction>(Arena*);
template<> ::SCRAPIProtocol::RequestAvailableMaps* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestAvailableMaps>(Arena*);
template<> ::SCRAPIProtocol::RequestConnect* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestConnect>(Arena*);
template<> ::SCRAPIProtocol::RequestCreateGame* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestCreateGame>(Arena*);
template<> ::SCRAPIProtocol::RequestData* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestData>(Arena*);
template<> ::SCRAPIProtocol::RequestDebug* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestDebug>(Arena*);
template<> ::SCRAPIProtocol::RequestEndOfQueue* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestEndOfQueue>(Arena*);
template<> ::SCRAPIProtocol::RequestGameInfo* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestGameInfo>(Arena*);
template<> ::SCRAPIProtocol::RequestJoinGame* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestJoinGame>(Arena*);
template<> ::SCRAPIProtocol::RequestLeaveGame* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestLeaveGame>(Arena*);
template<> ::SCRAPIProtocol::RequestObservation* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestObservation>(Arena*);
template<> ::SCRAPIProtocol::RequestObserverAction* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestObserverAction>(Arena*);
template<> ::SCRAPIProtocol::RequestPing* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestPing>(Arena*);
template<> ::SCRAPIProtocol::RequestQuickLoad* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestQuickLoad>(Arena*);
template<> ::SCRAPIProtocol::RequestQuickSave* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestQuickSave>(Arena*);
template<> ::SCRAPIProtocol::RequestQuit* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestQuit>(Arena*);
template<> ::SCRAPIProtocol::RequestReplayInfo* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestReplayInfo>(Arena*);
template<> ::SCRAPIProtocol::RequestRestartGame* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestRestartGame>(Arena*);
template<> ::SCRAPIProtocol::RequestSaveMap* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestSaveMap>(Arena*);
template<> ::SCRAPIProtocol::RequestSaveReplay* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestSaveReplay>(Arena*);
template<> ::SCRAPIProtocol::RequestStartReplay* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestStartReplay>(Arena*);
template<> ::SCRAPIProtocol::RequestStep* Arena::CreateMaybeMessage<::SCRAPIProtocol::RequestStep>(Arena*);
template<> ::SCRAPIProtocol::Response* Arena::CreateMaybeMessage<::SCRAPIProtocol::Response>(Arena*);
template<> ::SCRAPIProtocol::ResponseAction* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseAction>(Arena*);
template<> ::SCRAPIProtocol::ResponseAvailableMaps* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseAvailableMaps>(Arena*);
template<> ::SCRAPIProtocol::ResponseConnect* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseConnect>(Arena*);
template<> ::SCRAPIProtocol::ResponseCreateGame* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseCreateGame>(Arena*);
template<> ::SCRAPIProtocol::ResponseData* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseData>(Arena*);
template<> ::SCRAPIProtocol::ResponseDebug* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseDebug>(Arena*);
template<> ::SCRAPIProtocol::ResponseEndOfQueue* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseEndOfQueue>(Arena*);
template<> ::SCRAPIProtocol::ResponseGameInfo* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseGameInfo>(Arena*);
template<> ::SCRAPIProtocol::ResponseJoinGame* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseJoinGame>(Arena*);
template<> ::SCRAPIProtocol::ResponseLeaveGame* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseLeaveGame>(Arena*);
template<> ::SCRAPIProtocol::ResponseObservation* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseObservation>(Arena*);
template<> ::SCRAPIProtocol::ResponseObserverAction* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseObserverAction>(Arena*);
template<> ::SCRAPIProtocol::ResponsePing* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponsePing>(Arena*);
template<> ::SCRAPIProtocol::ResponseQuickLoad* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseQuickLoad>(Arena*);
template<> ::SCRAPIProtocol::ResponseQuickSave* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseQuickSave>(Arena*);
template<> ::SCRAPIProtocol::ResponseQuit* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseQuit>(Arena*);
template<> ::SCRAPIProtocol::ResponseReplayInfo* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseReplayInfo>(Arena*);
template<> ::SCRAPIProtocol::ResponseRestartGame* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseRestartGame>(Arena*);
template<> ::SCRAPIProtocol::ResponseSaveMap* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseSaveMap>(Arena*);
template<> ::SCRAPIProtocol::ResponseSaveReplay* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseSaveReplay>(Arena*);
template<> ::SCRAPIProtocol::ResponseStartReplay* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseStartReplay>(Arena*);
template<> ::SCRAPIProtocol::ResponseStep* Arena::CreateMaybeMessage<::SCRAPIProtocol::ResponseStep>(Arena*);
template<> ::SCRAPIProtocol::SpatialCameraSetup* Arena::CreateMaybeMessage<::SCRAPIProtocol::SpatialCameraSetup>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace SCRAPIProtocol {

enum ResponseCreateGame_Error {
  ResponseCreateGame_Error_HigherVersion = 1,
  ResponseCreateGame_Error_MapDefaultsOnly = 2,
  ResponseCreateGame_Error_AuthRequired = 3,
  ResponseCreateGame_Error_GameExists = 4,
  ResponseCreateGame_Error_TooManyGames = 5,
  ResponseCreateGame_Error_Unknown = 6,
  ResponseCreateGame_Error_InvalidMap = 7,
  ResponseCreateGame_Error_BadGameType = 8,
  ResponseCreateGame_Error_NeedsPassword = 9,
  ResponseCreateGame_Error_NoSlot = 10,
  ResponseCreateGame_Error_NoOpponent = 11,
  ResponseCreateGame_Error_TournAuthRequired = 12,
  ResponseCreateGame_Error_GameTypeDisabled = 13,
  ResponseCreateGame_Error_RequireBroodWar = 14,
  ResponseCreateGame_Error_UserCanceled = 15,
  ResponseCreateGame_Error_ServerError = 16
};
bool ResponseCreateGame_Error_IsValid(int value);
const ResponseCreateGame_Error ResponseCreateGame_Error_Error_MIN = ResponseCreateGame_Error_HigherVersion;
const ResponseCreateGame_Error ResponseCreateGame_Error_Error_MAX = ResponseCreateGame_Error_ServerError;
const int ResponseCreateGame_Error_Error_ARRAYSIZE = ResponseCreateGame_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseCreateGame_Error_descriptor();
inline const ::std::string& ResponseCreateGame_Error_Name(ResponseCreateGame_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseCreateGame_Error_descriptor(), value);
}
inline bool ResponseCreateGame_Error_Parse(
    const ::std::string& name, ResponseCreateGame_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseCreateGame_Error>(
    ResponseCreateGame_Error_descriptor(), name, value);
}
enum ResponseJoinGame_Error {
  ResponseJoinGame_Error_MissingParticipation = 1,
  ResponseJoinGame_Error_InvalidObservedPlayerId = 2,
  ResponseJoinGame_Error_MissingOptions = 3,
  ResponseJoinGame_Error_MissingPorts = 4,
  ResponseJoinGame_Error_GameFull = 5,
  ResponseJoinGame_Error_LaunchError = 6,
  ResponseJoinGame_Error_FeatureUnsupported = 7,
  ResponseJoinGame_Error_NoSpaceForUser = 8,
  ResponseJoinGame_Error_MapDoesNotExist = 9,
  ResponseJoinGame_Error_CannotOpenMap = 10,
  ResponseJoinGame_Error_ChecksumError = 11,
  ResponseJoinGame_Error_NetworkError = 12,
  ResponseJoinGame_Error_OtherError = 13
};
bool ResponseJoinGame_Error_IsValid(int value);
const ResponseJoinGame_Error ResponseJoinGame_Error_Error_MIN = ResponseJoinGame_Error_MissingParticipation;
const ResponseJoinGame_Error ResponseJoinGame_Error_Error_MAX = ResponseJoinGame_Error_OtherError;
const int ResponseJoinGame_Error_Error_ARRAYSIZE = ResponseJoinGame_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseJoinGame_Error_descriptor();
inline const ::std::string& ResponseJoinGame_Error_Name(ResponseJoinGame_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseJoinGame_Error_descriptor(), value);
}
inline bool ResponseJoinGame_Error_Parse(
    const ::std::string& name, ResponseJoinGame_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseJoinGame_Error>(
    ResponseJoinGame_Error_descriptor(), name, value);
}
enum ResponseRestartGame_Error {
  ResponseRestartGame_Error_LaunchError = 1
};
bool ResponseRestartGame_Error_IsValid(int value);
const ResponseRestartGame_Error ResponseRestartGame_Error_Error_MIN = ResponseRestartGame_Error_LaunchError;
const ResponseRestartGame_Error ResponseRestartGame_Error_Error_MAX = ResponseRestartGame_Error_LaunchError;
const int ResponseRestartGame_Error_Error_ARRAYSIZE = ResponseRestartGame_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseRestartGame_Error_descriptor();
inline const ::std::string& ResponseRestartGame_Error_Name(ResponseRestartGame_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseRestartGame_Error_descriptor(), value);
}
inline bool ResponseRestartGame_Error_Parse(
    const ::std::string& name, ResponseRestartGame_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseRestartGame_Error>(
    ResponseRestartGame_Error_descriptor(), name, value);
}
enum ResponseStartReplay_Error {
  ResponseStartReplay_Error_MissingReplay = 1,
  ResponseStartReplay_Error_InvalidReplayPath = 2,
  ResponseStartReplay_Error_InvalidReplayData = 3,
  ResponseStartReplay_Error_InvalidMapData = 4,
  ResponseStartReplay_Error_InvalidObservedPlayerId = 5,
  ResponseStartReplay_Error_MissingOptions = 6,
  ResponseStartReplay_Error_LaunchError = 7
};
bool ResponseStartReplay_Error_IsValid(int value);
const ResponseStartReplay_Error ResponseStartReplay_Error_Error_MIN = ResponseStartReplay_Error_MissingReplay;
const ResponseStartReplay_Error ResponseStartReplay_Error_Error_MAX = ResponseStartReplay_Error_LaunchError;
const int ResponseStartReplay_Error_Error_ARRAYSIZE = ResponseStartReplay_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseStartReplay_Error_descriptor();
inline const ::std::string& ResponseStartReplay_Error_Name(ResponseStartReplay_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseStartReplay_Error_descriptor(), value);
}
inline bool ResponseStartReplay_Error_Parse(
    const ::std::string& name, ResponseStartReplay_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseStartReplay_Error>(
    ResponseStartReplay_Error_descriptor(), name, value);
}
enum ResponseReplayInfo_Error {
  ResponseReplayInfo_Error_MissingReplay = 1,
  ResponseReplayInfo_Error_InvalidReplayPath = 2,
  ResponseReplayInfo_Error_InvalidReplayData = 3,
  ResponseReplayInfo_Error_ParsingError = 4,
  ResponseReplayInfo_Error_DownloadError = 5
};
bool ResponseReplayInfo_Error_IsValid(int value);
const ResponseReplayInfo_Error ResponseReplayInfo_Error_Error_MIN = ResponseReplayInfo_Error_MissingReplay;
const ResponseReplayInfo_Error ResponseReplayInfo_Error_Error_MAX = ResponseReplayInfo_Error_DownloadError;
const int ResponseReplayInfo_Error_Error_ARRAYSIZE = ResponseReplayInfo_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseReplayInfo_Error_descriptor();
inline const ::std::string& ResponseReplayInfo_Error_Name(ResponseReplayInfo_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseReplayInfo_Error_descriptor(), value);
}
inline bool ResponseReplayInfo_Error_Parse(
    const ::std::string& name, ResponseReplayInfo_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseReplayInfo_Error>(
    ResponseReplayInfo_Error_descriptor(), name, value);
}
enum ResponseSaveMap_Error {
  ResponseSaveMap_Error_InvalidMapData = 1
};
bool ResponseSaveMap_Error_IsValid(int value);
const ResponseSaveMap_Error ResponseSaveMap_Error_Error_MIN = ResponseSaveMap_Error_InvalidMapData;
const ResponseSaveMap_Error ResponseSaveMap_Error_Error_MAX = ResponseSaveMap_Error_InvalidMapData;
const int ResponseSaveMap_Error_Error_ARRAYSIZE = ResponseSaveMap_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseSaveMap_Error_descriptor();
inline const ::std::string& ResponseSaveMap_Error_Name(ResponseSaveMap_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseSaveMap_Error_descriptor(), value);
}
inline bool ResponseSaveMap_Error_Parse(
    const ::std::string& name, ResponseSaveMap_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseSaveMap_Error>(
    ResponseSaveMap_Error_descriptor(), name, value);
}
enum ActionChat_Channel {
  ActionChat_Channel_Broadcast = 1,
  ActionChat_Channel_Team = 2
};
bool ActionChat_Channel_IsValid(int value);
const ActionChat_Channel ActionChat_Channel_Channel_MIN = ActionChat_Channel_Broadcast;
const ActionChat_Channel ActionChat_Channel_Channel_MAX = ActionChat_Channel_Team;
const int ActionChat_Channel_Channel_ARRAYSIZE = ActionChat_Channel_Channel_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionChat_Channel_descriptor();
inline const ::std::string& ActionChat_Channel_Name(ActionChat_Channel value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionChat_Channel_descriptor(), value);
}
inline bool ActionChat_Channel_Parse(
    const ::std::string& name, ActionChat_Channel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionChat_Channel>(
    ActionChat_Channel_descriptor(), name, value);
}
enum Status {
  launched = 1,
  init_game = 2,
  in_game = 3,
  in_replay = 4,
  ended = 5,
  quit = 6,
  unknown = 99
};
bool Status_IsValid(int value);
const Status Status_MIN = launched;
const Status Status_MAX = unknown;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum Difficulty {
  VeryEasy = 1,
  Easy = 2,
  Medium = 3,
  MediumHard = 4,
  Hard = 5,
  Harder = 6,
  VeryHard = 7,
  CheatVision = 8,
  CheatMoney = 9,
  CheatInsane = 10
};
bool Difficulty_IsValid(int value);
const Difficulty Difficulty_MIN = VeryEasy;
const Difficulty Difficulty_MAX = CheatInsane;
const int Difficulty_ARRAYSIZE = Difficulty_MAX + 1;

const ::google::protobuf::EnumDescriptor* Difficulty_descriptor();
inline const ::std::string& Difficulty_Name(Difficulty value) {
  return ::google::protobuf::internal::NameOfEnum(
    Difficulty_descriptor(), value);
}
inline bool Difficulty_Parse(
    const ::std::string& name, Difficulty* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Difficulty>(
    Difficulty_descriptor(), name, value);
}
enum PlayerType {
  Participant = 1,
  Computer = 2,
  Observer = 3
};
bool PlayerType_IsValid(int value);
const PlayerType PlayerType_MIN = Participant;
const PlayerType PlayerType_MAX = Observer;
const int PlayerType_ARRAYSIZE = PlayerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlayerType_descriptor();
inline const ::std::string& PlayerType_Name(PlayerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlayerType_descriptor(), value);
}
inline bool PlayerType_Parse(
    const ::std::string& name, PlayerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerType>(
    PlayerType_descriptor(), name, value);
}
enum Alert {
  NuclearLaunchDetected = 1,
  NydusWormDetected = 2
};
bool Alert_IsValid(int value);
const Alert Alert_MIN = NuclearLaunchDetected;
const Alert Alert_MAX = NydusWormDetected;
const int Alert_ARRAYSIZE = Alert_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alert_descriptor();
inline const ::std::string& Alert_Name(Alert value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alert_descriptor(), value);
}
inline bool Alert_Parse(
    const ::std::string& name, Alert* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alert>(
    Alert_descriptor(), name, value);
}
enum Result {
  Victory = 1,
  Defeat = 2,
  Tie = 3,
  Undecided = 4
};
bool Result_IsValid(int value);
const Result Result_MIN = Victory;
const Result Result_MAX = Undecided;
const int Result_ARRAYSIZE = Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* Result_descriptor();
inline const ::std::string& Result_Name(Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    Result_descriptor(), value);
}
inline bool Result_Parse(
    const ::std::string& name, Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum RequestCase {
    kCreateGame = 1,
    kJoinGame = 2,
    kRestartGame = 3,
    kStartReplay = 4,
    kLeaveGame = 5,
    kQuickSave = 6,
    kQuickLoad = 7,
    kQuit = 8,
    kGameInfo = 9,
    kObservation = 10,
    kAction = 11,
    kObsAction = 21,
    kStep = 12,
    kData = 13,
    kQuery = 14,
    kSaveReplay = 15,
    kReplayInfo = 16,
    kAvailableMaps = 17,
    kSaveMap = 18,
    kPing = 19,
    kDebug = 20,
    kConnect = 22,
    kEndOfQueue = 23,
    REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(NULL);
  }

  Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.RequestCreateGame create_game = 1;
  bool has_create_game() const;
  void clear_create_game();
  static const int kCreateGameFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::RequestCreateGame& _internal_create_game() const;
  public:
  const ::SCRAPIProtocol::RequestCreateGame& create_game() const;
  ::SCRAPIProtocol::RequestCreateGame* release_create_game();
  ::SCRAPIProtocol::RequestCreateGame* mutable_create_game();
  void set_allocated_create_game(::SCRAPIProtocol::RequestCreateGame* create_game);

  // optional .SCRAPIProtocol.RequestJoinGame join_game = 2;
  bool has_join_game() const;
  void clear_join_game();
  static const int kJoinGameFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::RequestJoinGame& _internal_join_game() const;
  public:
  const ::SCRAPIProtocol::RequestJoinGame& join_game() const;
  ::SCRAPIProtocol::RequestJoinGame* release_join_game();
  ::SCRAPIProtocol::RequestJoinGame* mutable_join_game();
  void set_allocated_join_game(::SCRAPIProtocol::RequestJoinGame* join_game);

  // optional .SCRAPIProtocol.RequestRestartGame restart_game = 3;
  bool has_restart_game() const;
  void clear_restart_game();
  static const int kRestartGameFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::RequestRestartGame& _internal_restart_game() const;
  public:
  const ::SCRAPIProtocol::RequestRestartGame& restart_game() const;
  ::SCRAPIProtocol::RequestRestartGame* release_restart_game();
  ::SCRAPIProtocol::RequestRestartGame* mutable_restart_game();
  void set_allocated_restart_game(::SCRAPIProtocol::RequestRestartGame* restart_game);

  // optional .SCRAPIProtocol.RequestStartReplay start_replay = 4;
  bool has_start_replay() const;
  void clear_start_replay();
  static const int kStartReplayFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::RequestStartReplay& _internal_start_replay() const;
  public:
  const ::SCRAPIProtocol::RequestStartReplay& start_replay() const;
  ::SCRAPIProtocol::RequestStartReplay* release_start_replay();
  ::SCRAPIProtocol::RequestStartReplay* mutable_start_replay();
  void set_allocated_start_replay(::SCRAPIProtocol::RequestStartReplay* start_replay);

  // optional .SCRAPIProtocol.RequestLeaveGame leave_game = 5;
  bool has_leave_game() const;
  void clear_leave_game();
  static const int kLeaveGameFieldNumber = 5;
  private:
  const ::SCRAPIProtocol::RequestLeaveGame& _internal_leave_game() const;
  public:
  const ::SCRAPIProtocol::RequestLeaveGame& leave_game() const;
  ::SCRAPIProtocol::RequestLeaveGame* release_leave_game();
  ::SCRAPIProtocol::RequestLeaveGame* mutable_leave_game();
  void set_allocated_leave_game(::SCRAPIProtocol::RequestLeaveGame* leave_game);

  // optional .SCRAPIProtocol.RequestQuickSave quick_save = 6;
  bool has_quick_save() const;
  void clear_quick_save();
  static const int kQuickSaveFieldNumber = 6;
  private:
  const ::SCRAPIProtocol::RequestQuickSave& _internal_quick_save() const;
  public:
  const ::SCRAPIProtocol::RequestQuickSave& quick_save() const;
  ::SCRAPIProtocol::RequestQuickSave* release_quick_save();
  ::SCRAPIProtocol::RequestQuickSave* mutable_quick_save();
  void set_allocated_quick_save(::SCRAPIProtocol::RequestQuickSave* quick_save);

  // optional .SCRAPIProtocol.RequestQuickLoad quick_load = 7;
  bool has_quick_load() const;
  void clear_quick_load();
  static const int kQuickLoadFieldNumber = 7;
  private:
  const ::SCRAPIProtocol::RequestQuickLoad& _internal_quick_load() const;
  public:
  const ::SCRAPIProtocol::RequestQuickLoad& quick_load() const;
  ::SCRAPIProtocol::RequestQuickLoad* release_quick_load();
  ::SCRAPIProtocol::RequestQuickLoad* mutable_quick_load();
  void set_allocated_quick_load(::SCRAPIProtocol::RequestQuickLoad* quick_load);

  // optional .SCRAPIProtocol.RequestQuit quit = 8;
  bool has_quit() const;
  void clear_quit();
  static const int kQuitFieldNumber = 8;
  private:
  const ::SCRAPIProtocol::RequestQuit& _internal_quit() const;
  public:
  const ::SCRAPIProtocol::RequestQuit& quit() const;
  ::SCRAPIProtocol::RequestQuit* release_quit();
  ::SCRAPIProtocol::RequestQuit* mutable_quit();
  void set_allocated_quit(::SCRAPIProtocol::RequestQuit* quit);

  // optional .SCRAPIProtocol.RequestGameInfo game_info = 9;
  bool has_game_info() const;
  void clear_game_info();
  static const int kGameInfoFieldNumber = 9;
  private:
  const ::SCRAPIProtocol::RequestGameInfo& _internal_game_info() const;
  public:
  const ::SCRAPIProtocol::RequestGameInfo& game_info() const;
  ::SCRAPIProtocol::RequestGameInfo* release_game_info();
  ::SCRAPIProtocol::RequestGameInfo* mutable_game_info();
  void set_allocated_game_info(::SCRAPIProtocol::RequestGameInfo* game_info);

  // optional .SCRAPIProtocol.RequestObservation observation = 10;
  bool has_observation() const;
  void clear_observation();
  static const int kObservationFieldNumber = 10;
  private:
  const ::SCRAPIProtocol::RequestObservation& _internal_observation() const;
  public:
  const ::SCRAPIProtocol::RequestObservation& observation() const;
  ::SCRAPIProtocol::RequestObservation* release_observation();
  ::SCRAPIProtocol::RequestObservation* mutable_observation();
  void set_allocated_observation(::SCRAPIProtocol::RequestObservation* observation);

  // optional .SCRAPIProtocol.RequestAction action = 11;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 11;
  private:
  const ::SCRAPIProtocol::RequestAction& _internal_action() const;
  public:
  const ::SCRAPIProtocol::RequestAction& action() const;
  ::SCRAPIProtocol::RequestAction* release_action();
  ::SCRAPIProtocol::RequestAction* mutable_action();
  void set_allocated_action(::SCRAPIProtocol::RequestAction* action);

  // optional .SCRAPIProtocol.RequestObserverAction obs_action = 21;
  bool has_obs_action() const;
  void clear_obs_action();
  static const int kObsActionFieldNumber = 21;
  private:
  const ::SCRAPIProtocol::RequestObserverAction& _internal_obs_action() const;
  public:
  const ::SCRAPIProtocol::RequestObserverAction& obs_action() const;
  ::SCRAPIProtocol::RequestObserverAction* release_obs_action();
  ::SCRAPIProtocol::RequestObserverAction* mutable_obs_action();
  void set_allocated_obs_action(::SCRAPIProtocol::RequestObserverAction* obs_action);

  // optional .SCRAPIProtocol.RequestStep step = 12;
  bool has_step() const;
  void clear_step();
  static const int kStepFieldNumber = 12;
  private:
  const ::SCRAPIProtocol::RequestStep& _internal_step() const;
  public:
  const ::SCRAPIProtocol::RequestStep& step() const;
  ::SCRAPIProtocol::RequestStep* release_step();
  ::SCRAPIProtocol::RequestStep* mutable_step();
  void set_allocated_step(::SCRAPIProtocol::RequestStep* step);

  // optional .SCRAPIProtocol.RequestData data = 13;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 13;
  private:
  const ::SCRAPIProtocol::RequestData& _internal_data() const;
  public:
  const ::SCRAPIProtocol::RequestData& data() const;
  ::SCRAPIProtocol::RequestData* release_data();
  ::SCRAPIProtocol::RequestData* mutable_data();
  void set_allocated_data(::SCRAPIProtocol::RequestData* data);

  // optional .SCRAPIProtocol.RequestQuery query = 14;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 14;
  private:
  const ::SCRAPIProtocol::RequestQuery& _internal_query() const;
  public:
  const ::SCRAPIProtocol::RequestQuery& query() const;
  ::SCRAPIProtocol::RequestQuery* release_query();
  ::SCRAPIProtocol::RequestQuery* mutable_query();
  void set_allocated_query(::SCRAPIProtocol::RequestQuery* query);

  // optional .SCRAPIProtocol.RequestSaveReplay save_replay = 15;
  bool has_save_replay() const;
  void clear_save_replay();
  static const int kSaveReplayFieldNumber = 15;
  private:
  const ::SCRAPIProtocol::RequestSaveReplay& _internal_save_replay() const;
  public:
  const ::SCRAPIProtocol::RequestSaveReplay& save_replay() const;
  ::SCRAPIProtocol::RequestSaveReplay* release_save_replay();
  ::SCRAPIProtocol::RequestSaveReplay* mutable_save_replay();
  void set_allocated_save_replay(::SCRAPIProtocol::RequestSaveReplay* save_replay);

  // optional .SCRAPIProtocol.RequestReplayInfo replay_info = 16;
  bool has_replay_info() const;
  void clear_replay_info();
  static const int kReplayInfoFieldNumber = 16;
  private:
  const ::SCRAPIProtocol::RequestReplayInfo& _internal_replay_info() const;
  public:
  const ::SCRAPIProtocol::RequestReplayInfo& replay_info() const;
  ::SCRAPIProtocol::RequestReplayInfo* release_replay_info();
  ::SCRAPIProtocol::RequestReplayInfo* mutable_replay_info();
  void set_allocated_replay_info(::SCRAPIProtocol::RequestReplayInfo* replay_info);

  // optional .SCRAPIProtocol.RequestAvailableMaps available_maps = 17;
  bool has_available_maps() const;
  void clear_available_maps();
  static const int kAvailableMapsFieldNumber = 17;
  private:
  const ::SCRAPIProtocol::RequestAvailableMaps& _internal_available_maps() const;
  public:
  const ::SCRAPIProtocol::RequestAvailableMaps& available_maps() const;
  ::SCRAPIProtocol::RequestAvailableMaps* release_available_maps();
  ::SCRAPIProtocol::RequestAvailableMaps* mutable_available_maps();
  void set_allocated_available_maps(::SCRAPIProtocol::RequestAvailableMaps* available_maps);

  // optional .SCRAPIProtocol.RequestSaveMap save_map = 18;
  bool has_save_map() const;
  void clear_save_map();
  static const int kSaveMapFieldNumber = 18;
  private:
  const ::SCRAPIProtocol::RequestSaveMap& _internal_save_map() const;
  public:
  const ::SCRAPIProtocol::RequestSaveMap& save_map() const;
  ::SCRAPIProtocol::RequestSaveMap* release_save_map();
  ::SCRAPIProtocol::RequestSaveMap* mutable_save_map();
  void set_allocated_save_map(::SCRAPIProtocol::RequestSaveMap* save_map);

  // optional .SCRAPIProtocol.RequestPing ping = 19;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 19;
  private:
  const ::SCRAPIProtocol::RequestPing& _internal_ping() const;
  public:
  const ::SCRAPIProtocol::RequestPing& ping() const;
  ::SCRAPIProtocol::RequestPing* release_ping();
  ::SCRAPIProtocol::RequestPing* mutable_ping();
  void set_allocated_ping(::SCRAPIProtocol::RequestPing* ping);

  // optional .SCRAPIProtocol.RequestDebug debug = 20;
  bool has_debug() const;
  void clear_debug();
  static const int kDebugFieldNumber = 20;
  private:
  const ::SCRAPIProtocol::RequestDebug& _internal_debug() const;
  public:
  const ::SCRAPIProtocol::RequestDebug& debug() const;
  ::SCRAPIProtocol::RequestDebug* release_debug();
  ::SCRAPIProtocol::RequestDebug* mutable_debug();
  void set_allocated_debug(::SCRAPIProtocol::RequestDebug* debug);

  // optional .SCRAPIProtocol.RequestConnect connect = 22;
  bool has_connect() const;
  void clear_connect();
  static const int kConnectFieldNumber = 22;
  private:
  const ::SCRAPIProtocol::RequestConnect& _internal_connect() const;
  public:
  const ::SCRAPIProtocol::RequestConnect& connect() const;
  ::SCRAPIProtocol::RequestConnect* release_connect();
  ::SCRAPIProtocol::RequestConnect* mutable_connect();
  void set_allocated_connect(::SCRAPIProtocol::RequestConnect* connect);

  // optional .SCRAPIProtocol.RequestEndOfQueue end_of_queue = 23;
  bool has_end_of_queue() const;
  void clear_end_of_queue();
  static const int kEndOfQueueFieldNumber = 23;
  private:
  const ::SCRAPIProtocol::RequestEndOfQueue& _internal_end_of_queue() const;
  public:
  const ::SCRAPIProtocol::RequestEndOfQueue& end_of_queue() const;
  ::SCRAPIProtocol::RequestEndOfQueue* release_end_of_queue();
  ::SCRAPIProtocol::RequestEndOfQueue* mutable_end_of_queue();
  void set_allocated_end_of_queue(::SCRAPIProtocol::RequestEndOfQueue* end_of_queue);

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.Request)
 private:
  void set_has_create_game();
  void set_has_join_game();
  void set_has_restart_game();
  void set_has_start_replay();
  void set_has_leave_game();
  void set_has_quick_save();
  void set_has_quick_load();
  void set_has_quit();
  void set_has_game_info();
  void set_has_observation();
  void set_has_action();
  void set_has_obs_action();
  void set_has_step();
  void set_has_data();
  void set_has_query();
  void set_has_save_replay();
  void set_has_replay_info();
  void set_has_available_maps();
  void set_has_save_map();
  void set_has_ping();
  void set_has_debug();
  void set_has_connect();
  void set_has_end_of_queue();

  inline bool has_request() const;
  inline void clear_has_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union RequestUnion {
    RequestUnion() {}
    ::SCRAPIProtocol::RequestCreateGame* create_game_;
    ::SCRAPIProtocol::RequestJoinGame* join_game_;
    ::SCRAPIProtocol::RequestRestartGame* restart_game_;
    ::SCRAPIProtocol::RequestStartReplay* start_replay_;
    ::SCRAPIProtocol::RequestLeaveGame* leave_game_;
    ::SCRAPIProtocol::RequestQuickSave* quick_save_;
    ::SCRAPIProtocol::RequestQuickLoad* quick_load_;
    ::SCRAPIProtocol::RequestQuit* quit_;
    ::SCRAPIProtocol::RequestGameInfo* game_info_;
    ::SCRAPIProtocol::RequestObservation* observation_;
    ::SCRAPIProtocol::RequestAction* action_;
    ::SCRAPIProtocol::RequestObserverAction* obs_action_;
    ::SCRAPIProtocol::RequestStep* step_;
    ::SCRAPIProtocol::RequestData* data_;
    ::SCRAPIProtocol::RequestQuery* query_;
    ::SCRAPIProtocol::RequestSaveReplay* save_replay_;
    ::SCRAPIProtocol::RequestReplayInfo* replay_info_;
    ::SCRAPIProtocol::RequestAvailableMaps* available_maps_;
    ::SCRAPIProtocol::RequestSaveMap* save_map_;
    ::SCRAPIProtocol::RequestPing* ping_;
    ::SCRAPIProtocol::RequestDebug* debug_;
    ::SCRAPIProtocol::RequestConnect* connect_;
    ::SCRAPIProtocol::RequestEndOfQueue* end_of_queue_;
  } request_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum ResponseCase {
    kCreateGame = 1,
    kJoinGame = 2,
    kRestartGame = 3,
    kStartReplay = 4,
    kLeaveGame = 5,
    kQuickSave = 6,
    kQuickLoad = 7,
    kQuit = 8,
    kGameInfo = 9,
    kObservation = 10,
    kAction = 11,
    kObsAction = 21,
    kStep = 12,
    kData = 13,
    kQuery = 14,
    kSaveReplay = 15,
    kReplayInfo = 16,
    kAvailableMaps = 17,
    kSaveMap = 18,
    kPing = 19,
    kDebug = 20,
    kConnect = 22,
    kEndOfQueue = 23,
    RESPONSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(NULL);
  }

  Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string error = 98;
  int error_size() const;
  void clear_error();
  static const int kErrorFieldNumber = 98;
  const ::std::string& error(int index) const;
  ::std::string* mutable_error(int index);
  void set_error(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_error(int index, ::std::string&& value);
  #endif
  void set_error(int index, const char* value);
  void set_error(int index, const char* value, size_t size);
  ::std::string* add_error();
  void add_error(const ::std::string& value);
  #if LANG_CXX11
  void add_error(::std::string&& value);
  #endif
  void add_error(const char* value);
  void add_error(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& error() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_error();

  // optional .SCRAPIProtocol.Status status = 99;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 99;
  ::SCRAPIProtocol::Status status() const;
  void set_status(::SCRAPIProtocol::Status value);

  // optional .SCRAPIProtocol.ResponseCreateGame create_game = 1;
  bool has_create_game() const;
  void clear_create_game();
  static const int kCreateGameFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::ResponseCreateGame& _internal_create_game() const;
  public:
  const ::SCRAPIProtocol::ResponseCreateGame& create_game() const;
  ::SCRAPIProtocol::ResponseCreateGame* release_create_game();
  ::SCRAPIProtocol::ResponseCreateGame* mutable_create_game();
  void set_allocated_create_game(::SCRAPIProtocol::ResponseCreateGame* create_game);

  // optional .SCRAPIProtocol.ResponseJoinGame join_game = 2;
  bool has_join_game() const;
  void clear_join_game();
  static const int kJoinGameFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ResponseJoinGame& _internal_join_game() const;
  public:
  const ::SCRAPIProtocol::ResponseJoinGame& join_game() const;
  ::SCRAPIProtocol::ResponseJoinGame* release_join_game();
  ::SCRAPIProtocol::ResponseJoinGame* mutable_join_game();
  void set_allocated_join_game(::SCRAPIProtocol::ResponseJoinGame* join_game);

  // optional .SCRAPIProtocol.ResponseRestartGame restart_game = 3;
  bool has_restart_game() const;
  void clear_restart_game();
  static const int kRestartGameFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::ResponseRestartGame& _internal_restart_game() const;
  public:
  const ::SCRAPIProtocol::ResponseRestartGame& restart_game() const;
  ::SCRAPIProtocol::ResponseRestartGame* release_restart_game();
  ::SCRAPIProtocol::ResponseRestartGame* mutable_restart_game();
  void set_allocated_restart_game(::SCRAPIProtocol::ResponseRestartGame* restart_game);

  // optional .SCRAPIProtocol.ResponseStartReplay start_replay = 4;
  bool has_start_replay() const;
  void clear_start_replay();
  static const int kStartReplayFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::ResponseStartReplay& _internal_start_replay() const;
  public:
  const ::SCRAPIProtocol::ResponseStartReplay& start_replay() const;
  ::SCRAPIProtocol::ResponseStartReplay* release_start_replay();
  ::SCRAPIProtocol::ResponseStartReplay* mutable_start_replay();
  void set_allocated_start_replay(::SCRAPIProtocol::ResponseStartReplay* start_replay);

  // optional .SCRAPIProtocol.ResponseLeaveGame leave_game = 5;
  bool has_leave_game() const;
  void clear_leave_game();
  static const int kLeaveGameFieldNumber = 5;
  private:
  const ::SCRAPIProtocol::ResponseLeaveGame& _internal_leave_game() const;
  public:
  const ::SCRAPIProtocol::ResponseLeaveGame& leave_game() const;
  ::SCRAPIProtocol::ResponseLeaveGame* release_leave_game();
  ::SCRAPIProtocol::ResponseLeaveGame* mutable_leave_game();
  void set_allocated_leave_game(::SCRAPIProtocol::ResponseLeaveGame* leave_game);

  // optional .SCRAPIProtocol.ResponseQuickSave quick_save = 6;
  bool has_quick_save() const;
  void clear_quick_save();
  static const int kQuickSaveFieldNumber = 6;
  private:
  const ::SCRAPIProtocol::ResponseQuickSave& _internal_quick_save() const;
  public:
  const ::SCRAPIProtocol::ResponseQuickSave& quick_save() const;
  ::SCRAPIProtocol::ResponseQuickSave* release_quick_save();
  ::SCRAPIProtocol::ResponseQuickSave* mutable_quick_save();
  void set_allocated_quick_save(::SCRAPIProtocol::ResponseQuickSave* quick_save);

  // optional .SCRAPIProtocol.ResponseQuickLoad quick_load = 7;
  bool has_quick_load() const;
  void clear_quick_load();
  static const int kQuickLoadFieldNumber = 7;
  private:
  const ::SCRAPIProtocol::ResponseQuickLoad& _internal_quick_load() const;
  public:
  const ::SCRAPIProtocol::ResponseQuickLoad& quick_load() const;
  ::SCRAPIProtocol::ResponseQuickLoad* release_quick_load();
  ::SCRAPIProtocol::ResponseQuickLoad* mutable_quick_load();
  void set_allocated_quick_load(::SCRAPIProtocol::ResponseQuickLoad* quick_load);

  // optional .SCRAPIProtocol.ResponseQuit quit = 8;
  bool has_quit() const;
  void clear_quit();
  static const int kQuitFieldNumber = 8;
  private:
  const ::SCRAPIProtocol::ResponseQuit& _internal_quit() const;
  public:
  const ::SCRAPIProtocol::ResponseQuit& quit() const;
  ::SCRAPIProtocol::ResponseQuit* release_quit();
  ::SCRAPIProtocol::ResponseQuit* mutable_quit();
  void set_allocated_quit(::SCRAPIProtocol::ResponseQuit* quit);

  // optional .SCRAPIProtocol.ResponseGameInfo game_info = 9;
  bool has_game_info() const;
  void clear_game_info();
  static const int kGameInfoFieldNumber = 9;
  private:
  const ::SCRAPIProtocol::ResponseGameInfo& _internal_game_info() const;
  public:
  const ::SCRAPIProtocol::ResponseGameInfo& game_info() const;
  ::SCRAPIProtocol::ResponseGameInfo* release_game_info();
  ::SCRAPIProtocol::ResponseGameInfo* mutable_game_info();
  void set_allocated_game_info(::SCRAPIProtocol::ResponseGameInfo* game_info);

  // optional .SCRAPIProtocol.ResponseObservation observation = 10;
  bool has_observation() const;
  void clear_observation();
  static const int kObservationFieldNumber = 10;
  private:
  const ::SCRAPIProtocol::ResponseObservation& _internal_observation() const;
  public:
  const ::SCRAPIProtocol::ResponseObservation& observation() const;
  ::SCRAPIProtocol::ResponseObservation* release_observation();
  ::SCRAPIProtocol::ResponseObservation* mutable_observation();
  void set_allocated_observation(::SCRAPIProtocol::ResponseObservation* observation);

  // optional .SCRAPIProtocol.ResponseAction action = 11;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 11;
  private:
  const ::SCRAPIProtocol::ResponseAction& _internal_action() const;
  public:
  const ::SCRAPIProtocol::ResponseAction& action() const;
  ::SCRAPIProtocol::ResponseAction* release_action();
  ::SCRAPIProtocol::ResponseAction* mutable_action();
  void set_allocated_action(::SCRAPIProtocol::ResponseAction* action);

  // optional .SCRAPIProtocol.ResponseObserverAction obs_action = 21;
  bool has_obs_action() const;
  void clear_obs_action();
  static const int kObsActionFieldNumber = 21;
  private:
  const ::SCRAPIProtocol::ResponseObserverAction& _internal_obs_action() const;
  public:
  const ::SCRAPIProtocol::ResponseObserverAction& obs_action() const;
  ::SCRAPIProtocol::ResponseObserverAction* release_obs_action();
  ::SCRAPIProtocol::ResponseObserverAction* mutable_obs_action();
  void set_allocated_obs_action(::SCRAPIProtocol::ResponseObserverAction* obs_action);

  // optional .SCRAPIProtocol.ResponseStep step = 12;
  bool has_step() const;
  void clear_step();
  static const int kStepFieldNumber = 12;
  private:
  const ::SCRAPIProtocol::ResponseStep& _internal_step() const;
  public:
  const ::SCRAPIProtocol::ResponseStep& step() const;
  ::SCRAPIProtocol::ResponseStep* release_step();
  ::SCRAPIProtocol::ResponseStep* mutable_step();
  void set_allocated_step(::SCRAPIProtocol::ResponseStep* step);

  // optional .SCRAPIProtocol.ResponseData data = 13;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 13;
  private:
  const ::SCRAPIProtocol::ResponseData& _internal_data() const;
  public:
  const ::SCRAPIProtocol::ResponseData& data() const;
  ::SCRAPIProtocol::ResponseData* release_data();
  ::SCRAPIProtocol::ResponseData* mutable_data();
  void set_allocated_data(::SCRAPIProtocol::ResponseData* data);

  // optional .SCRAPIProtocol.ResponseQuery query = 14;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 14;
  private:
  const ::SCRAPIProtocol::ResponseQuery& _internal_query() const;
  public:
  const ::SCRAPIProtocol::ResponseQuery& query() const;
  ::SCRAPIProtocol::ResponseQuery* release_query();
  ::SCRAPIProtocol::ResponseQuery* mutable_query();
  void set_allocated_query(::SCRAPIProtocol::ResponseQuery* query);

  // optional .SCRAPIProtocol.ResponseSaveReplay save_replay = 15;
  bool has_save_replay() const;
  void clear_save_replay();
  static const int kSaveReplayFieldNumber = 15;
  private:
  const ::SCRAPIProtocol::ResponseSaveReplay& _internal_save_replay() const;
  public:
  const ::SCRAPIProtocol::ResponseSaveReplay& save_replay() const;
  ::SCRAPIProtocol::ResponseSaveReplay* release_save_replay();
  ::SCRAPIProtocol::ResponseSaveReplay* mutable_save_replay();
  void set_allocated_save_replay(::SCRAPIProtocol::ResponseSaveReplay* save_replay);

  // optional .SCRAPIProtocol.ResponseReplayInfo replay_info = 16;
  bool has_replay_info() const;
  void clear_replay_info();
  static const int kReplayInfoFieldNumber = 16;
  private:
  const ::SCRAPIProtocol::ResponseReplayInfo& _internal_replay_info() const;
  public:
  const ::SCRAPIProtocol::ResponseReplayInfo& replay_info() const;
  ::SCRAPIProtocol::ResponseReplayInfo* release_replay_info();
  ::SCRAPIProtocol::ResponseReplayInfo* mutable_replay_info();
  void set_allocated_replay_info(::SCRAPIProtocol::ResponseReplayInfo* replay_info);

  // optional .SCRAPIProtocol.ResponseAvailableMaps available_maps = 17;
  bool has_available_maps() const;
  void clear_available_maps();
  static const int kAvailableMapsFieldNumber = 17;
  private:
  const ::SCRAPIProtocol::ResponseAvailableMaps& _internal_available_maps() const;
  public:
  const ::SCRAPIProtocol::ResponseAvailableMaps& available_maps() const;
  ::SCRAPIProtocol::ResponseAvailableMaps* release_available_maps();
  ::SCRAPIProtocol::ResponseAvailableMaps* mutable_available_maps();
  void set_allocated_available_maps(::SCRAPIProtocol::ResponseAvailableMaps* available_maps);

  // optional .SCRAPIProtocol.ResponseSaveMap save_map = 18;
  bool has_save_map() const;
  void clear_save_map();
  static const int kSaveMapFieldNumber = 18;
  private:
  const ::SCRAPIProtocol::ResponseSaveMap& _internal_save_map() const;
  public:
  const ::SCRAPIProtocol::ResponseSaveMap& save_map() const;
  ::SCRAPIProtocol::ResponseSaveMap* release_save_map();
  ::SCRAPIProtocol::ResponseSaveMap* mutable_save_map();
  void set_allocated_save_map(::SCRAPIProtocol::ResponseSaveMap* save_map);

  // optional .SCRAPIProtocol.ResponsePing ping = 19;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 19;
  private:
  const ::SCRAPIProtocol::ResponsePing& _internal_ping() const;
  public:
  const ::SCRAPIProtocol::ResponsePing& ping() const;
  ::SCRAPIProtocol::ResponsePing* release_ping();
  ::SCRAPIProtocol::ResponsePing* mutable_ping();
  void set_allocated_ping(::SCRAPIProtocol::ResponsePing* ping);

  // optional .SCRAPIProtocol.ResponseDebug debug = 20;
  bool has_debug() const;
  void clear_debug();
  static const int kDebugFieldNumber = 20;
  private:
  const ::SCRAPIProtocol::ResponseDebug& _internal_debug() const;
  public:
  const ::SCRAPIProtocol::ResponseDebug& debug() const;
  ::SCRAPIProtocol::ResponseDebug* release_debug();
  ::SCRAPIProtocol::ResponseDebug* mutable_debug();
  void set_allocated_debug(::SCRAPIProtocol::ResponseDebug* debug);

  // optional .SCRAPIProtocol.ResponseConnect connect = 22;
  bool has_connect() const;
  void clear_connect();
  static const int kConnectFieldNumber = 22;
  private:
  const ::SCRAPIProtocol::ResponseConnect& _internal_connect() const;
  public:
  const ::SCRAPIProtocol::ResponseConnect& connect() const;
  ::SCRAPIProtocol::ResponseConnect* release_connect();
  ::SCRAPIProtocol::ResponseConnect* mutable_connect();
  void set_allocated_connect(::SCRAPIProtocol::ResponseConnect* connect);

  // optional .SCRAPIProtocol.ResponseEndOfQueue end_of_queue = 23;
  bool has_end_of_queue() const;
  void clear_end_of_queue();
  static const int kEndOfQueueFieldNumber = 23;
  private:
  const ::SCRAPIProtocol::ResponseEndOfQueue& _internal_end_of_queue() const;
  public:
  const ::SCRAPIProtocol::ResponseEndOfQueue& end_of_queue() const;
  ::SCRAPIProtocol::ResponseEndOfQueue* release_end_of_queue();
  ::SCRAPIProtocol::ResponseEndOfQueue* mutable_end_of_queue();
  void set_allocated_end_of_queue(::SCRAPIProtocol::ResponseEndOfQueue* end_of_queue);

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.Response)
 private:
  void set_has_create_game();
  void set_has_join_game();
  void set_has_restart_game();
  void set_has_start_replay();
  void set_has_leave_game();
  void set_has_quick_save();
  void set_has_quick_load();
  void set_has_quit();
  void set_has_game_info();
  void set_has_observation();
  void set_has_action();
  void set_has_obs_action();
  void set_has_step();
  void set_has_data();
  void set_has_query();
  void set_has_save_replay();
  void set_has_replay_info();
  void set_has_available_maps();
  void set_has_save_map();
  void set_has_ping();
  void set_has_debug();
  void set_has_connect();
  void set_has_end_of_queue();
  void set_has_status();
  void clear_has_status();

  inline bool has_response() const;
  inline void clear_has_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> error_;
  int status_;
  union ResponseUnion {
    ResponseUnion() {}
    ::SCRAPIProtocol::ResponseCreateGame* create_game_;
    ::SCRAPIProtocol::ResponseJoinGame* join_game_;
    ::SCRAPIProtocol::ResponseRestartGame* restart_game_;
    ::SCRAPIProtocol::ResponseStartReplay* start_replay_;
    ::SCRAPIProtocol::ResponseLeaveGame* leave_game_;
    ::SCRAPIProtocol::ResponseQuickSave* quick_save_;
    ::SCRAPIProtocol::ResponseQuickLoad* quick_load_;
    ::SCRAPIProtocol::ResponseQuit* quit_;
    ::SCRAPIProtocol::ResponseGameInfo* game_info_;
    ::SCRAPIProtocol::ResponseObservation* observation_;
    ::SCRAPIProtocol::ResponseAction* action_;
    ::SCRAPIProtocol::ResponseObserverAction* obs_action_;
    ::SCRAPIProtocol::ResponseStep* step_;
    ::SCRAPIProtocol::ResponseData* data_;
    ::SCRAPIProtocol::ResponseQuery* query_;
    ::SCRAPIProtocol::ResponseSaveReplay* save_replay_;
    ::SCRAPIProtocol::ResponseReplayInfo* replay_info_;
    ::SCRAPIProtocol::ResponseAvailableMaps* available_maps_;
    ::SCRAPIProtocol::ResponseSaveMap* save_map_;
    ::SCRAPIProtocol::ResponsePing* ping_;
    ::SCRAPIProtocol::ResponseDebug* debug_;
    ::SCRAPIProtocol::ResponseConnect* connect_;
    ::SCRAPIProtocol::ResponseEndOfQueue* end_of_queue_;
  } response_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestCreateGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestCreateGame) */ {
 public:
  RequestCreateGame();
  virtual ~RequestCreateGame();

  RequestCreateGame(const RequestCreateGame& from);

  inline RequestCreateGame& operator=(const RequestCreateGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestCreateGame(RequestCreateGame&& from) noexcept
    : RequestCreateGame() {
    *this = ::std::move(from);
  }

  inline RequestCreateGame& operator=(RequestCreateGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCreateGame& default_instance();

  enum MapCase {
    kLocalMap = 1,
    kBattlenetMapName = 2,
    MAP_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCreateGame* internal_default_instance() {
    return reinterpret_cast<const RequestCreateGame*>(
               &_RequestCreateGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RequestCreateGame* other);
  friend void swap(RequestCreateGame& a, RequestCreateGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestCreateGame* New() const final {
    return CreateMaybeMessage<RequestCreateGame>(NULL);
  }

  RequestCreateGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestCreateGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestCreateGame& from);
  void MergeFrom(const RequestCreateGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCreateGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.PlayerSetup player_setup = 3;
  int player_setup_size() const;
  void clear_player_setup();
  static const int kPlayerSetupFieldNumber = 3;
  ::SCRAPIProtocol::PlayerSetup* mutable_player_setup(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerSetup >*
      mutable_player_setup();
  const ::SCRAPIProtocol::PlayerSetup& player_setup(int index) const;
  ::SCRAPIProtocol::PlayerSetup* add_player_setup();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerSetup >&
      player_setup() const;

  // optional uint32 random_seed = 5;
  bool has_random_seed() const;
  void clear_random_seed();
  static const int kRandomSeedFieldNumber = 5;
  ::google::protobuf::uint32 random_seed() const;
  void set_random_seed(::google::protobuf::uint32 value);

  // optional bool disable_fog = 4;
  bool has_disable_fog() const;
  void clear_disable_fog();
  static const int kDisableFogFieldNumber = 4;
  bool disable_fog() const;
  void set_disable_fog(bool value);

  // optional bool realtime = 6;
  bool has_realtime() const;
  void clear_realtime();
  static const int kRealtimeFieldNumber = 6;
  bool realtime() const;
  void set_realtime(bool value);

  // optional .SCRAPIProtocol.LocalMap local_map = 1;
  bool has_local_map() const;
  void clear_local_map();
  static const int kLocalMapFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::LocalMap& _internal_local_map() const;
  public:
  const ::SCRAPIProtocol::LocalMap& local_map() const;
  ::SCRAPIProtocol::LocalMap* release_local_map();
  ::SCRAPIProtocol::LocalMap* mutable_local_map();
  void set_allocated_local_map(::SCRAPIProtocol::LocalMap* local_map);

  // optional string battlenet_map_name = 2;
  bool has_battlenet_map_name() const;
  void clear_battlenet_map_name();
  static const int kBattlenetMapNameFieldNumber = 2;
  const ::std::string& battlenet_map_name() const;
  void set_battlenet_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_battlenet_map_name(::std::string&& value);
  #endif
  void set_battlenet_map_name(const char* value);
  void set_battlenet_map_name(const char* value, size_t size);
  ::std::string* mutable_battlenet_map_name();
  ::std::string* release_battlenet_map_name();
  void set_allocated_battlenet_map_name(::std::string* battlenet_map_name);

  void clear_Map();
  MapCase Map_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestCreateGame)
 private:
  void set_has_local_map();
  void set_has_battlenet_map_name();
  void set_has_disable_fog();
  void clear_has_disable_fog();
  void set_has_random_seed();
  void clear_has_random_seed();
  void set_has_realtime();
  void clear_has_realtime();

  inline bool has_Map() const;
  inline void clear_has_Map();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerSetup > player_setup_;
  ::google::protobuf::uint32 random_seed_;
  bool disable_fog_;
  bool realtime_;
  union MapUnion {
    MapUnion() {}
    ::SCRAPIProtocol::LocalMap* local_map_;
    ::google::protobuf::internal::ArenaStringPtr battlenet_map_name_;
  } Map_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.LocalMap) */ {
 public:
  LocalMap();
  virtual ~LocalMap();

  LocalMap(const LocalMap& from);

  inline LocalMap& operator=(const LocalMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalMap(LocalMap&& from) noexcept
    : LocalMap() {
    *this = ::std::move(from);
  }

  inline LocalMap& operator=(LocalMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalMap* internal_default_instance() {
    return reinterpret_cast<const LocalMap*>(
               &_LocalMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LocalMap* other);
  friend void swap(LocalMap& a, LocalMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalMap* New() const final {
    return CreateMaybeMessage<LocalMap>(NULL);
  }

  LocalMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocalMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocalMap& from);
  void MergeFrom(const LocalMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string map_path = 1;
  bool has_map_path() const;
  void clear_map_path();
  static const int kMapPathFieldNumber = 1;
  const ::std::string& map_path() const;
  void set_map_path(const ::std::string& value);
  #if LANG_CXX11
  void set_map_path(::std::string&& value);
  #endif
  void set_map_path(const char* value);
  void set_map_path(const char* value, size_t size);
  ::std::string* mutable_map_path();
  ::std::string* release_map_path();
  void set_allocated_map_path(::std::string* map_path);

  // optional bytes map_data = 7;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 7;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  #if LANG_CXX11
  void set_map_data(::std::string&& value);
  #endif
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.LocalMap)
 private:
  void set_has_map_path();
  void clear_has_map_path();
  void set_has_map_data();
  void clear_has_map_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_path_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseCreateGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseCreateGame) */ {
 public:
  ResponseCreateGame();
  virtual ~ResponseCreateGame();

  ResponseCreateGame(const ResponseCreateGame& from);

  inline ResponseCreateGame& operator=(const ResponseCreateGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseCreateGame(ResponseCreateGame&& from) noexcept
    : ResponseCreateGame() {
    *this = ::std::move(from);
  }

  inline ResponseCreateGame& operator=(ResponseCreateGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCreateGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseCreateGame* internal_default_instance() {
    return reinterpret_cast<const ResponseCreateGame*>(
               &_ResponseCreateGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ResponseCreateGame* other);
  friend void swap(ResponseCreateGame& a, ResponseCreateGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseCreateGame* New() const final {
    return CreateMaybeMessage<ResponseCreateGame>(NULL);
  }

  ResponseCreateGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseCreateGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseCreateGame& from);
  void MergeFrom(const ResponseCreateGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseCreateGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseCreateGame_Error Error;
  static const Error HigherVersion =
    ResponseCreateGame_Error_HigherVersion;
  static const Error MapDefaultsOnly =
    ResponseCreateGame_Error_MapDefaultsOnly;
  static const Error AuthRequired =
    ResponseCreateGame_Error_AuthRequired;
  static const Error GameExists =
    ResponseCreateGame_Error_GameExists;
  static const Error TooManyGames =
    ResponseCreateGame_Error_TooManyGames;
  static const Error Unknown =
    ResponseCreateGame_Error_Unknown;
  static const Error InvalidMap =
    ResponseCreateGame_Error_InvalidMap;
  static const Error BadGameType =
    ResponseCreateGame_Error_BadGameType;
  static const Error NeedsPassword =
    ResponseCreateGame_Error_NeedsPassword;
  static const Error NoSlot =
    ResponseCreateGame_Error_NoSlot;
  static const Error NoOpponent =
    ResponseCreateGame_Error_NoOpponent;
  static const Error TournAuthRequired =
    ResponseCreateGame_Error_TournAuthRequired;
  static const Error GameTypeDisabled =
    ResponseCreateGame_Error_GameTypeDisabled;
  static const Error RequireBroodWar =
    ResponseCreateGame_Error_RequireBroodWar;
  static const Error UserCanceled =
    ResponseCreateGame_Error_UserCanceled;
  static const Error ServerError =
    ResponseCreateGame_Error_ServerError;
  static inline bool Error_IsValid(int value) {
    return ResponseCreateGame_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseCreateGame_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseCreateGame_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseCreateGame_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseCreateGame_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseCreateGame_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseCreateGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string error_details = 2;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 2;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  #if LANG_CXX11
  void set_error_details(::std::string&& value);
  #endif
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // optional .SCRAPIProtocol.ResponseCreateGame.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SCRAPIProtocol::ResponseCreateGame_Error error() const;
  void set_error(::SCRAPIProtocol::ResponseCreateGame_Error value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseCreateGame)
 private:
  void set_has_error();
  void clear_has_error();
  void set_has_error_details();
  void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  int error_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestJoinGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestJoinGame) */ {
 public:
  RequestJoinGame();
  virtual ~RequestJoinGame();

  RequestJoinGame(const RequestJoinGame& from);

  inline RequestJoinGame& operator=(const RequestJoinGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestJoinGame(RequestJoinGame&& from) noexcept
    : RequestJoinGame() {
    *this = ::std::move(from);
  }

  inline RequestJoinGame& operator=(RequestJoinGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestJoinGame& default_instance();

  enum ParticipationCase {
    kRace = 1,
    kObservedPlayerId = 2,
    PARTICIPATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestJoinGame* internal_default_instance() {
    return reinterpret_cast<const RequestJoinGame*>(
               &_RequestJoinGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RequestJoinGame* other);
  friend void swap(RequestJoinGame& a, RequestJoinGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestJoinGame* New() const final {
    return CreateMaybeMessage<RequestJoinGame>(NULL);
  }

  RequestJoinGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestJoinGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestJoinGame& from);
  void MergeFrom(const RequestJoinGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestJoinGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.PortSet client_ports = 5;
  int client_ports_size() const;
  void clear_client_ports();
  static const int kClientPortsFieldNumber = 5;
  ::SCRAPIProtocol::PortSet* mutable_client_ports(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PortSet >*
      mutable_client_ports();
  const ::SCRAPIProtocol::PortSet& client_ports(int index) const;
  ::SCRAPIProtocol::PortSet* add_client_ports();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PortSet >&
      client_ports() const;

  // optional .SCRAPIProtocol.InterfaceOptions options = 3;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::InterfaceOptions& _internal_options() const;
  public:
  const ::SCRAPIProtocol::InterfaceOptions& options() const;
  ::SCRAPIProtocol::InterfaceOptions* release_options();
  ::SCRAPIProtocol::InterfaceOptions* mutable_options();
  void set_allocated_options(::SCRAPIProtocol::InterfaceOptions* options);

  // optional .SCRAPIProtocol.PortSet server_ports = 4;
  bool has_server_ports() const;
  void clear_server_ports();
  static const int kServerPortsFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::PortSet& _internal_server_ports() const;
  public:
  const ::SCRAPIProtocol::PortSet& server_ports() const;
  ::SCRAPIProtocol::PortSet* release_server_ports();
  ::SCRAPIProtocol::PortSet* mutable_server_ports();
  void set_allocated_server_ports(::SCRAPIProtocol::PortSet* server_ports);

  // optional int32 shared_port = 6;
  bool has_shared_port() const;
  void clear_shared_port();
  static const int kSharedPortFieldNumber = 6;
  ::google::protobuf::int32 shared_port() const;
  void set_shared_port(::google::protobuf::int32 value);

  // optional .SCRAPIProtocol.Race race = 1;
  bool has_race() const;
  void clear_race();
  static const int kRaceFieldNumber = 1;
  ::SCRAPIProtocol::Race race() const;
  void set_race(::SCRAPIProtocol::Race value);

  // optional uint32 observed_player_id = 2;
  bool has_observed_player_id() const;
  void clear_observed_player_id();
  static const int kObservedPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 observed_player_id() const;
  void set_observed_player_id(::google::protobuf::uint32 value);

  void clear_participation();
  ParticipationCase participation_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestJoinGame)
 private:
  void set_has_race();
  void set_has_observed_player_id();
  void set_has_options();
  void clear_has_options();
  void set_has_server_ports();
  void clear_has_server_ports();
  void set_has_shared_port();
  void clear_has_shared_port();

  inline bool has_participation() const;
  inline void clear_has_participation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PortSet > client_ports_;
  ::SCRAPIProtocol::InterfaceOptions* options_;
  ::SCRAPIProtocol::PortSet* server_ports_;
  ::google::protobuf::int32 shared_port_;
  union ParticipationUnion {
    ParticipationUnion() {}
    int race_;
    ::google::protobuf::uint32 observed_player_id_;
  } participation_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PortSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.PortSet) */ {
 public:
  PortSet();
  virtual ~PortSet();

  PortSet(const PortSet& from);

  inline PortSet& operator=(const PortSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PortSet(PortSet&& from) noexcept
    : PortSet() {
    *this = ::std::move(from);
  }

  inline PortSet& operator=(PortSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PortSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortSet* internal_default_instance() {
    return reinterpret_cast<const PortSet*>(
               &_PortSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PortSet* other);
  friend void swap(PortSet& a, PortSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PortSet* New() const final {
    return CreateMaybeMessage<PortSet>(NULL);
  }

  PortSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PortSet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PortSet& from);
  void MergeFrom(const PortSet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 game_port = 1;
  bool has_game_port() const;
  void clear_game_port();
  static const int kGamePortFieldNumber = 1;
  ::google::protobuf::int32 game_port() const;
  void set_game_port(::google::protobuf::int32 value);

  // optional int32 base_port = 2;
  bool has_base_port() const;
  void clear_base_port();
  static const int kBasePortFieldNumber = 2;
  ::google::protobuf::int32 base_port() const;
  void set_base_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.PortSet)
 private:
  void set_has_game_port();
  void clear_has_game_port();
  void set_has_base_port();
  void clear_has_base_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 game_port_;
  ::google::protobuf::int32 base_port_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseJoinGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseJoinGame) */ {
 public:
  ResponseJoinGame();
  virtual ~ResponseJoinGame();

  ResponseJoinGame(const ResponseJoinGame& from);

  inline ResponseJoinGame& operator=(const ResponseJoinGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseJoinGame(ResponseJoinGame&& from) noexcept
    : ResponseJoinGame() {
    *this = ::std::move(from);
  }

  inline ResponseJoinGame& operator=(ResponseJoinGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseJoinGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseJoinGame* internal_default_instance() {
    return reinterpret_cast<const ResponseJoinGame*>(
               &_ResponseJoinGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ResponseJoinGame* other);
  friend void swap(ResponseJoinGame& a, ResponseJoinGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseJoinGame* New() const final {
    return CreateMaybeMessage<ResponseJoinGame>(NULL);
  }

  ResponseJoinGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseJoinGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseJoinGame& from);
  void MergeFrom(const ResponseJoinGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseJoinGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseJoinGame_Error Error;
  static const Error MissingParticipation =
    ResponseJoinGame_Error_MissingParticipation;
  static const Error InvalidObservedPlayerId =
    ResponseJoinGame_Error_InvalidObservedPlayerId;
  static const Error MissingOptions =
    ResponseJoinGame_Error_MissingOptions;
  static const Error MissingPorts =
    ResponseJoinGame_Error_MissingPorts;
  static const Error GameFull =
    ResponseJoinGame_Error_GameFull;
  static const Error LaunchError =
    ResponseJoinGame_Error_LaunchError;
  static const Error FeatureUnsupported =
    ResponseJoinGame_Error_FeatureUnsupported;
  static const Error NoSpaceForUser =
    ResponseJoinGame_Error_NoSpaceForUser;
  static const Error MapDoesNotExist =
    ResponseJoinGame_Error_MapDoesNotExist;
  static const Error CannotOpenMap =
    ResponseJoinGame_Error_CannotOpenMap;
  static const Error ChecksumError =
    ResponseJoinGame_Error_ChecksumError;
  static const Error NetworkError =
    ResponseJoinGame_Error_NetworkError;
  static const Error OtherError =
    ResponseJoinGame_Error_OtherError;
  static inline bool Error_IsValid(int value) {
    return ResponseJoinGame_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseJoinGame_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseJoinGame_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseJoinGame_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseJoinGame_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseJoinGame_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseJoinGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string error_details = 3;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 3;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  #if LANG_CXX11
  void set_error_details(::std::string&& value);
  #endif
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional .SCRAPIProtocol.ResponseJoinGame.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  ::SCRAPIProtocol::ResponseJoinGame_Error error() const;
  void set_error(::SCRAPIProtocol::ResponseJoinGame_Error value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseJoinGame)
 private:
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_error();
  void clear_has_error();
  void set_has_error_details();
  void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  ::google::protobuf::uint32 player_id_;
  int error_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestRestartGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestRestartGame) */ {
 public:
  RequestRestartGame();
  virtual ~RequestRestartGame();

  RequestRestartGame(const RequestRestartGame& from);

  inline RequestRestartGame& operator=(const RequestRestartGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestRestartGame(RequestRestartGame&& from) noexcept
    : RequestRestartGame() {
    *this = ::std::move(from);
  }

  inline RequestRestartGame& operator=(RequestRestartGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRestartGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestRestartGame* internal_default_instance() {
    return reinterpret_cast<const RequestRestartGame*>(
               &_RequestRestartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RequestRestartGame* other);
  friend void swap(RequestRestartGame& a, RequestRestartGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestRestartGame* New() const final {
    return CreateMaybeMessage<RequestRestartGame>(NULL);
  }

  RequestRestartGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestRestartGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestRestartGame& from);
  void MergeFrom(const RequestRestartGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestRestartGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestRestartGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseRestartGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseRestartGame) */ {
 public:
  ResponseRestartGame();
  virtual ~ResponseRestartGame();

  ResponseRestartGame(const ResponseRestartGame& from);

  inline ResponseRestartGame& operator=(const ResponseRestartGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseRestartGame(ResponseRestartGame&& from) noexcept
    : ResponseRestartGame() {
    *this = ::std::move(from);
  }

  inline ResponseRestartGame& operator=(ResponseRestartGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRestartGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseRestartGame* internal_default_instance() {
    return reinterpret_cast<const ResponseRestartGame*>(
               &_ResponseRestartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ResponseRestartGame* other);
  friend void swap(ResponseRestartGame& a, ResponseRestartGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseRestartGame* New() const final {
    return CreateMaybeMessage<ResponseRestartGame>(NULL);
  }

  ResponseRestartGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseRestartGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseRestartGame& from);
  void MergeFrom(const ResponseRestartGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseRestartGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseRestartGame_Error Error;
  static const Error LaunchError =
    ResponseRestartGame_Error_LaunchError;
  static inline bool Error_IsValid(int value) {
    return ResponseRestartGame_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseRestartGame_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseRestartGame_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseRestartGame_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseRestartGame_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseRestartGame_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseRestartGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string error_details = 2;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 2;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  #if LANG_CXX11
  void set_error_details(::std::string&& value);
  #endif
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // optional .SCRAPIProtocol.ResponseRestartGame.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SCRAPIProtocol::ResponseRestartGame_Error error() const;
  void set_error(::SCRAPIProtocol::ResponseRestartGame_Error value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseRestartGame)
 private:
  void set_has_error();
  void clear_has_error();
  void set_has_error_details();
  void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  int error_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestStartReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestStartReplay) */ {
 public:
  RequestStartReplay();
  virtual ~RequestStartReplay();

  RequestStartReplay(const RequestStartReplay& from);

  inline RequestStartReplay& operator=(const RequestStartReplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestStartReplay(RequestStartReplay&& from) noexcept
    : RequestStartReplay() {
    *this = ::std::move(from);
  }

  inline RequestStartReplay& operator=(RequestStartReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestStartReplay& default_instance();

  enum ReplayCase {
    kReplayPath = 1,
    kReplayData = 5,
    REPLAY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestStartReplay* internal_default_instance() {
    return reinterpret_cast<const RequestStartReplay*>(
               &_RequestStartReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RequestStartReplay* other);
  friend void swap(RequestStartReplay& a, RequestStartReplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestStartReplay* New() const final {
    return CreateMaybeMessage<RequestStartReplay>(NULL);
  }

  RequestStartReplay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestStartReplay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestStartReplay& from);
  void MergeFrom(const RequestStartReplay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestStartReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes map_data = 6;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 6;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  #if LANG_CXX11
  void set_map_data(::std::string&& value);
  #endif
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);

  // optional .SCRAPIProtocol.InterfaceOptions options = 3;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::InterfaceOptions& _internal_options() const;
  public:
  const ::SCRAPIProtocol::InterfaceOptions& options() const;
  ::SCRAPIProtocol::InterfaceOptions* release_options();
  ::SCRAPIProtocol::InterfaceOptions* mutable_options();
  void set_allocated_options(::SCRAPIProtocol::InterfaceOptions* options);

  // optional int32 observed_player_id = 2;
  bool has_observed_player_id() const;
  void clear_observed_player_id();
  static const int kObservedPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 observed_player_id() const;
  void set_observed_player_id(::google::protobuf::int32 value);

  // optional bool disable_fog = 4;
  bool has_disable_fog() const;
  void clear_disable_fog();
  static const int kDisableFogFieldNumber = 4;
  bool disable_fog() const;
  void set_disable_fog(bool value);

  // optional bool realtime = 7;
  bool has_realtime() const;
  void clear_realtime();
  static const int kRealtimeFieldNumber = 7;
  bool realtime() const;
  void set_realtime(bool value);

  // optional string replay_path = 1;
  bool has_replay_path() const;
  void clear_replay_path();
  static const int kReplayPathFieldNumber = 1;
  const ::std::string& replay_path() const;
  void set_replay_path(const ::std::string& value);
  #if LANG_CXX11
  void set_replay_path(::std::string&& value);
  #endif
  void set_replay_path(const char* value);
  void set_replay_path(const char* value, size_t size);
  ::std::string* mutable_replay_path();
  ::std::string* release_replay_path();
  void set_allocated_replay_path(::std::string* replay_path);

  // optional bytes replay_data = 5;
  bool has_replay_data() const;
  void clear_replay_data();
  static const int kReplayDataFieldNumber = 5;
  const ::std::string& replay_data() const;
  void set_replay_data(const ::std::string& value);
  #if LANG_CXX11
  void set_replay_data(::std::string&& value);
  #endif
  void set_replay_data(const char* value);
  void set_replay_data(const void* value, size_t size);
  ::std::string* mutable_replay_data();
  ::std::string* release_replay_data();
  void set_allocated_replay_data(::std::string* replay_data);

  void clear_replay();
  ReplayCase replay_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestStartReplay)
 private:
  void set_has_replay_path();
  void set_has_replay_data();
  void set_has_map_data();
  void clear_has_map_data();
  void set_has_observed_player_id();
  void clear_has_observed_player_id();
  void set_has_options();
  void clear_has_options();
  void set_has_disable_fog();
  void clear_has_disable_fog();
  void set_has_realtime();
  void clear_has_realtime();

  inline bool has_replay() const;
  inline void clear_has_replay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  ::SCRAPIProtocol::InterfaceOptions* options_;
  ::google::protobuf::int32 observed_player_id_;
  bool disable_fog_;
  bool realtime_;
  union ReplayUnion {
    ReplayUnion() {}
    ::google::protobuf::internal::ArenaStringPtr replay_path_;
    ::google::protobuf::internal::ArenaStringPtr replay_data_;
  } replay_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseStartReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseStartReplay) */ {
 public:
  ResponseStartReplay();
  virtual ~ResponseStartReplay();

  ResponseStartReplay(const ResponseStartReplay& from);

  inline ResponseStartReplay& operator=(const ResponseStartReplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseStartReplay(ResponseStartReplay&& from) noexcept
    : ResponseStartReplay() {
    *this = ::std::move(from);
  }

  inline ResponseStartReplay& operator=(ResponseStartReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseStartReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseStartReplay* internal_default_instance() {
    return reinterpret_cast<const ResponseStartReplay*>(
               &_ResponseStartReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ResponseStartReplay* other);
  friend void swap(ResponseStartReplay& a, ResponseStartReplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseStartReplay* New() const final {
    return CreateMaybeMessage<ResponseStartReplay>(NULL);
  }

  ResponseStartReplay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseStartReplay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseStartReplay& from);
  void MergeFrom(const ResponseStartReplay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseStartReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseStartReplay_Error Error;
  static const Error MissingReplay =
    ResponseStartReplay_Error_MissingReplay;
  static const Error InvalidReplayPath =
    ResponseStartReplay_Error_InvalidReplayPath;
  static const Error InvalidReplayData =
    ResponseStartReplay_Error_InvalidReplayData;
  static const Error InvalidMapData =
    ResponseStartReplay_Error_InvalidMapData;
  static const Error InvalidObservedPlayerId =
    ResponseStartReplay_Error_InvalidObservedPlayerId;
  static const Error MissingOptions =
    ResponseStartReplay_Error_MissingOptions;
  static const Error LaunchError =
    ResponseStartReplay_Error_LaunchError;
  static inline bool Error_IsValid(int value) {
    return ResponseStartReplay_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseStartReplay_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseStartReplay_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseStartReplay_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseStartReplay_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseStartReplay_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseStartReplay_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string error_details = 2;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 2;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  #if LANG_CXX11
  void set_error_details(::std::string&& value);
  #endif
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // optional .SCRAPIProtocol.ResponseStartReplay.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SCRAPIProtocol::ResponseStartReplay_Error error() const;
  void set_error(::SCRAPIProtocol::ResponseStartReplay_Error value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseStartReplay)
 private:
  void set_has_error();
  void clear_has_error();
  void set_has_error_details();
  void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  int error_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestLeaveGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestLeaveGame) */ {
 public:
  RequestLeaveGame();
  virtual ~RequestLeaveGame();

  RequestLeaveGame(const RequestLeaveGame& from);

  inline RequestLeaveGame& operator=(const RequestLeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestLeaveGame(RequestLeaveGame&& from) noexcept
    : RequestLeaveGame() {
    *this = ::std::move(from);
  }

  inline RequestLeaveGame& operator=(RequestLeaveGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLeaveGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestLeaveGame* internal_default_instance() {
    return reinterpret_cast<const RequestLeaveGame*>(
               &_RequestLeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RequestLeaveGame* other);
  friend void swap(RequestLeaveGame& a, RequestLeaveGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestLeaveGame* New() const final {
    return CreateMaybeMessage<RequestLeaveGame>(NULL);
  }

  RequestLeaveGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestLeaveGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestLeaveGame& from);
  void MergeFrom(const RequestLeaveGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLeaveGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestLeaveGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseLeaveGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseLeaveGame) */ {
 public:
  ResponseLeaveGame();
  virtual ~ResponseLeaveGame();

  ResponseLeaveGame(const ResponseLeaveGame& from);

  inline ResponseLeaveGame& operator=(const ResponseLeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseLeaveGame(ResponseLeaveGame&& from) noexcept
    : ResponseLeaveGame() {
    *this = ::std::move(from);
  }

  inline ResponseLeaveGame& operator=(ResponseLeaveGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseLeaveGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseLeaveGame* internal_default_instance() {
    return reinterpret_cast<const ResponseLeaveGame*>(
               &_ResponseLeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ResponseLeaveGame* other);
  friend void swap(ResponseLeaveGame& a, ResponseLeaveGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseLeaveGame* New() const final {
    return CreateMaybeMessage<ResponseLeaveGame>(NULL);
  }

  ResponseLeaveGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseLeaveGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseLeaveGame& from);
  void MergeFrom(const ResponseLeaveGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseLeaveGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseLeaveGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestQuickSave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestQuickSave) */ {
 public:
  RequestQuickSave();
  virtual ~RequestQuickSave();

  RequestQuickSave(const RequestQuickSave& from);

  inline RequestQuickSave& operator=(const RequestQuickSave& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestQuickSave(RequestQuickSave&& from) noexcept
    : RequestQuickSave() {
    *this = ::std::move(from);
  }

  inline RequestQuickSave& operator=(RequestQuickSave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuickSave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuickSave* internal_default_instance() {
    return reinterpret_cast<const RequestQuickSave*>(
               &_RequestQuickSave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(RequestQuickSave* other);
  friend void swap(RequestQuickSave& a, RequestQuickSave& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestQuickSave* New() const final {
    return CreateMaybeMessage<RequestQuickSave>(NULL);
  }

  RequestQuickSave* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestQuickSave>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestQuickSave& from);
  void MergeFrom(const RequestQuickSave& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuickSave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestQuickSave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseQuickSave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseQuickSave) */ {
 public:
  ResponseQuickSave();
  virtual ~ResponseQuickSave();

  ResponseQuickSave(const ResponseQuickSave& from);

  inline ResponseQuickSave& operator=(const ResponseQuickSave& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseQuickSave(ResponseQuickSave&& from) noexcept
    : ResponseQuickSave() {
    *this = ::std::move(from);
  }

  inline ResponseQuickSave& operator=(ResponseQuickSave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuickSave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuickSave* internal_default_instance() {
    return reinterpret_cast<const ResponseQuickSave*>(
               &_ResponseQuickSave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ResponseQuickSave* other);
  friend void swap(ResponseQuickSave& a, ResponseQuickSave& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuickSave* New() const final {
    return CreateMaybeMessage<ResponseQuickSave>(NULL);
  }

  ResponseQuickSave* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseQuickSave>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseQuickSave& from);
  void MergeFrom(const ResponseQuickSave& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuickSave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseQuickSave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestQuickLoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestQuickLoad) */ {
 public:
  RequestQuickLoad();
  virtual ~RequestQuickLoad();

  RequestQuickLoad(const RequestQuickLoad& from);

  inline RequestQuickLoad& operator=(const RequestQuickLoad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestQuickLoad(RequestQuickLoad&& from) noexcept
    : RequestQuickLoad() {
    *this = ::std::move(from);
  }

  inline RequestQuickLoad& operator=(RequestQuickLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuickLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuickLoad* internal_default_instance() {
    return reinterpret_cast<const RequestQuickLoad*>(
               &_RequestQuickLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(RequestQuickLoad* other);
  friend void swap(RequestQuickLoad& a, RequestQuickLoad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestQuickLoad* New() const final {
    return CreateMaybeMessage<RequestQuickLoad>(NULL);
  }

  RequestQuickLoad* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestQuickLoad>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestQuickLoad& from);
  void MergeFrom(const RequestQuickLoad& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuickLoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestQuickLoad)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseQuickLoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseQuickLoad) */ {
 public:
  ResponseQuickLoad();
  virtual ~ResponseQuickLoad();

  ResponseQuickLoad(const ResponseQuickLoad& from);

  inline ResponseQuickLoad& operator=(const ResponseQuickLoad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseQuickLoad(ResponseQuickLoad&& from) noexcept
    : ResponseQuickLoad() {
    *this = ::std::move(from);
  }

  inline ResponseQuickLoad& operator=(ResponseQuickLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuickLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuickLoad* internal_default_instance() {
    return reinterpret_cast<const ResponseQuickLoad*>(
               &_ResponseQuickLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ResponseQuickLoad* other);
  friend void swap(ResponseQuickLoad& a, ResponseQuickLoad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuickLoad* New() const final {
    return CreateMaybeMessage<ResponseQuickLoad>(NULL);
  }

  ResponseQuickLoad* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseQuickLoad>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseQuickLoad& from);
  void MergeFrom(const ResponseQuickLoad& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuickLoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseQuickLoad)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestQuit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestQuit) */ {
 public:
  RequestQuit();
  virtual ~RequestQuit();

  RequestQuit(const RequestQuit& from);

  inline RequestQuit& operator=(const RequestQuit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestQuit(RequestQuit&& from) noexcept
    : RequestQuit() {
    *this = ::std::move(from);
  }

  inline RequestQuit& operator=(RequestQuit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuit* internal_default_instance() {
    return reinterpret_cast<const RequestQuit*>(
               &_RequestQuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(RequestQuit* other);
  friend void swap(RequestQuit& a, RequestQuit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestQuit* New() const final {
    return CreateMaybeMessage<RequestQuit>(NULL);
  }

  RequestQuit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestQuit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestQuit& from);
  void MergeFrom(const RequestQuit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestQuit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseQuit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseQuit) */ {
 public:
  ResponseQuit();
  virtual ~ResponseQuit();

  ResponseQuit(const ResponseQuit& from);

  inline ResponseQuit& operator=(const ResponseQuit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseQuit(ResponseQuit&& from) noexcept
    : ResponseQuit() {
    *this = ::std::move(from);
  }

  inline ResponseQuit& operator=(ResponseQuit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuit* internal_default_instance() {
    return reinterpret_cast<const ResponseQuit*>(
               &_ResponseQuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ResponseQuit* other);
  friend void swap(ResponseQuit& a, ResponseQuit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuit* New() const final {
    return CreateMaybeMessage<ResponseQuit>(NULL);
  }

  ResponseQuit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseQuit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseQuit& from);
  void MergeFrom(const ResponseQuit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseQuit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestGameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestGameInfo) */ {
 public:
  RequestGameInfo();
  virtual ~RequestGameInfo();

  RequestGameInfo(const RequestGameInfo& from);

  inline RequestGameInfo& operator=(const RequestGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestGameInfo(RequestGameInfo&& from) noexcept
    : RequestGameInfo() {
    *this = ::std::move(from);
  }

  inline RequestGameInfo& operator=(RequestGameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestGameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestGameInfo* internal_default_instance() {
    return reinterpret_cast<const RequestGameInfo*>(
               &_RequestGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(RequestGameInfo* other);
  friend void swap(RequestGameInfo& a, RequestGameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestGameInfo* New() const final {
    return CreateMaybeMessage<RequestGameInfo>(NULL);
  }

  RequestGameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestGameInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestGameInfo& from);
  void MergeFrom(const RequestGameInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestGameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestGameInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseGameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseGameInfo) */ {
 public:
  ResponseGameInfo();
  virtual ~ResponseGameInfo();

  ResponseGameInfo(const ResponseGameInfo& from);

  inline ResponseGameInfo& operator=(const ResponseGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseGameInfo(ResponseGameInfo&& from) noexcept
    : ResponseGameInfo() {
    *this = ::std::move(from);
  }

  inline ResponseGameInfo& operator=(ResponseGameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseGameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseGameInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseGameInfo*>(
               &_ResponseGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ResponseGameInfo* other);
  friend void swap(ResponseGameInfo& a, ResponseGameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseGameInfo* New() const final {
    return CreateMaybeMessage<ResponseGameInfo>(NULL);
  }

  ResponseGameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseGameInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseGameInfo& from);
  void MergeFrom(const ResponseGameInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseGameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.PlayerInfo player_info = 3;
  int player_info_size() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 3;
  ::SCRAPIProtocol::PlayerInfo* mutable_player_info(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerInfo >*
      mutable_player_info();
  const ::SCRAPIProtocol::PlayerInfo& player_info(int index) const;
  ::SCRAPIProtocol::PlayerInfo* add_player_info();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerInfo >&
      player_info() const;

  // repeated string mod_names = 6;
  int mod_names_size() const;
  void clear_mod_names();
  static const int kModNamesFieldNumber = 6;
  const ::std::string& mod_names(int index) const;
  ::std::string* mutable_mod_names(int index);
  void set_mod_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_mod_names(int index, ::std::string&& value);
  #endif
  void set_mod_names(int index, const char* value);
  void set_mod_names(int index, const char* value, size_t size);
  ::std::string* add_mod_names();
  void add_mod_names(const ::std::string& value);
  #if LANG_CXX11
  void add_mod_names(::std::string&& value);
  #endif
  void add_mod_names(const char* value);
  void add_mod_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& mod_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mod_names();

  // optional string map_name = 1;
  bool has_map_name() const;
  void clear_map_name();
  static const int kMapNameFieldNumber = 1;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_map_name(::std::string&& value);
  #endif
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // optional string local_map_path = 2;
  bool has_local_map_path() const;
  void clear_local_map_path();
  static const int kLocalMapPathFieldNumber = 2;
  const ::std::string& local_map_path() const;
  void set_local_map_path(const ::std::string& value);
  #if LANG_CXX11
  void set_local_map_path(::std::string&& value);
  #endif
  void set_local_map_path(const char* value);
  void set_local_map_path(const char* value, size_t size);
  ::std::string* mutable_local_map_path();
  ::std::string* release_local_map_path();
  void set_allocated_local_map_path(::std::string* local_map_path);

  // optional .SCRAPIProtocol.StartRaw start_raw = 4;
  bool has_start_raw() const;
  void clear_start_raw();
  static const int kStartRawFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::StartRaw& _internal_start_raw() const;
  public:
  const ::SCRAPIProtocol::StartRaw& start_raw() const;
  ::SCRAPIProtocol::StartRaw* release_start_raw();
  ::SCRAPIProtocol::StartRaw* mutable_start_raw();
  void set_allocated_start_raw(::SCRAPIProtocol::StartRaw* start_raw);

  // optional .SCRAPIProtocol.InterfaceOptions options = 5;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 5;
  private:
  const ::SCRAPIProtocol::InterfaceOptions& _internal_options() const;
  public:
  const ::SCRAPIProtocol::InterfaceOptions& options() const;
  ::SCRAPIProtocol::InterfaceOptions* release_options();
  ::SCRAPIProtocol::InterfaceOptions* mutable_options();
  void set_allocated_options(::SCRAPIProtocol::InterfaceOptions* options);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseGameInfo)
 private:
  void set_has_map_name();
  void clear_has_map_name();
  void set_has_local_map_path();
  void clear_has_local_map_path();
  void set_has_start_raw();
  void clear_has_start_raw();
  void set_has_options();
  void clear_has_options();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerInfo > player_info_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mod_names_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  ::google::protobuf::internal::ArenaStringPtr local_map_path_;
  ::SCRAPIProtocol::StartRaw* start_raw_;
  ::SCRAPIProtocol::InterfaceOptions* options_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestObservation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestObservation) */ {
 public:
  RequestObservation();
  virtual ~RequestObservation();

  RequestObservation(const RequestObservation& from);

  inline RequestObservation& operator=(const RequestObservation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestObservation(RequestObservation&& from) noexcept
    : RequestObservation() {
    *this = ::std::move(from);
  }

  inline RequestObservation& operator=(RequestObservation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestObservation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestObservation* internal_default_instance() {
    return reinterpret_cast<const RequestObservation*>(
               &_RequestObservation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(RequestObservation* other);
  friend void swap(RequestObservation& a, RequestObservation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestObservation* New() const final {
    return CreateMaybeMessage<RequestObservation>(NULL);
  }

  RequestObservation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestObservation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestObservation& from);
  void MergeFrom(const RequestObservation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestObservation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disable_fog = 1;
  bool has_disable_fog() const;
  void clear_disable_fog();
  static const int kDisableFogFieldNumber = 1;
  bool disable_fog() const;
  void set_disable_fog(bool value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestObservation)
 private:
  void set_has_disable_fog();
  void clear_has_disable_fog();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool disable_fog_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseObservation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseObservation) */ {
 public:
  ResponseObservation();
  virtual ~ResponseObservation();

  ResponseObservation(const ResponseObservation& from);

  inline ResponseObservation& operator=(const ResponseObservation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseObservation(ResponseObservation&& from) noexcept
    : ResponseObservation() {
    *this = ::std::move(from);
  }

  inline ResponseObservation& operator=(ResponseObservation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseObservation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseObservation* internal_default_instance() {
    return reinterpret_cast<const ResponseObservation*>(
               &_ResponseObservation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ResponseObservation* other);
  friend void swap(ResponseObservation& a, ResponseObservation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseObservation* New() const final {
    return CreateMaybeMessage<ResponseObservation>(NULL);
  }

  ResponseObservation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseObservation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseObservation& from);
  void MergeFrom(const ResponseObservation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseObservation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.Action actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  ::SCRAPIProtocol::Action* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Action >*
      mutable_actions();
  const ::SCRAPIProtocol::Action& actions(int index) const;
  ::SCRAPIProtocol::Action* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Action >&
      actions() const;

  // repeated .SCRAPIProtocol.ActionError action_errors = 2;
  int action_errors_size() const;
  void clear_action_errors();
  static const int kActionErrorsFieldNumber = 2;
  ::SCRAPIProtocol::ActionError* mutable_action_errors(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ActionError >*
      mutable_action_errors();
  const ::SCRAPIProtocol::ActionError& action_errors(int index) const;
  ::SCRAPIProtocol::ActionError* add_action_errors();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ActionError >&
      action_errors() const;

  // repeated .SCRAPIProtocol.PlayerResult player_result = 4;
  int player_result_size() const;
  void clear_player_result();
  static const int kPlayerResultFieldNumber = 4;
  ::SCRAPIProtocol::PlayerResult* mutable_player_result(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerResult >*
      mutable_player_result();
  const ::SCRAPIProtocol::PlayerResult& player_result(int index) const;
  ::SCRAPIProtocol::PlayerResult* add_player_result();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerResult >&
      player_result() const;

  // repeated .SCRAPIProtocol.ChatReceived chat = 5;
  int chat_size() const;
  void clear_chat();
  static const int kChatFieldNumber = 5;
  ::SCRAPIProtocol::ChatReceived* mutable_chat(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ChatReceived >*
      mutable_chat();
  const ::SCRAPIProtocol::ChatReceived& chat(int index) const;
  ::SCRAPIProtocol::ChatReceived* add_chat();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ChatReceived >&
      chat() const;

  // optional .SCRAPIProtocol.Observation observation = 3;
  bool has_observation() const;
  void clear_observation();
  static const int kObservationFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::Observation& _internal_observation() const;
  public:
  const ::SCRAPIProtocol::Observation& observation() const;
  ::SCRAPIProtocol::Observation* release_observation();
  ::SCRAPIProtocol::Observation* mutable_observation();
  void set_allocated_observation(::SCRAPIProtocol::Observation* observation);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseObservation)
 private:
  void set_has_observation();
  void clear_has_observation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Action > actions_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ActionError > action_errors_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerResult > player_result_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ChatReceived > chat_;
  ::SCRAPIProtocol::Observation* observation_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChatReceived : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ChatReceived) */ {
 public:
  ChatReceived();
  virtual ~ChatReceived();

  ChatReceived(const ChatReceived& from);

  inline ChatReceived& operator=(const ChatReceived& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChatReceived(ChatReceived&& from) noexcept
    : ChatReceived() {
    *this = ::std::move(from);
  }

  inline ChatReceived& operator=(ChatReceived&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatReceived& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatReceived* internal_default_instance() {
    return reinterpret_cast<const ChatReceived*>(
               &_ChatReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(ChatReceived* other);
  friend void swap(ChatReceived& a, ChatReceived& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChatReceived* New() const final {
    return CreateMaybeMessage<ChatReceived>(NULL);
  }

  ChatReceived* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChatReceived>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChatReceived& from);
  void MergeFrom(const ChatReceived& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatReceived* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ChatReceived)
 private:
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 player_id_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestAction) */ {
 public:
  RequestAction();
  virtual ~RequestAction();

  RequestAction(const RequestAction& from);

  inline RequestAction& operator=(const RequestAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestAction(RequestAction&& from) noexcept
    : RequestAction() {
    *this = ::std::move(from);
  }

  inline RequestAction& operator=(RequestAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestAction* internal_default_instance() {
    return reinterpret_cast<const RequestAction*>(
               &_RequestAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(RequestAction* other);
  friend void swap(RequestAction& a, RequestAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestAction* New() const final {
    return CreateMaybeMessage<RequestAction>(NULL);
  }

  RequestAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestAction& from);
  void MergeFrom(const RequestAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.Action actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  ::SCRAPIProtocol::Action* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Action >*
      mutable_actions();
  const ::SCRAPIProtocol::Action& actions(int index) const;
  ::SCRAPIProtocol::Action* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Action >&
      actions() const;

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Action > actions_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseAction) */ {
 public:
  ResponseAction();
  virtual ~ResponseAction();

  ResponseAction(const ResponseAction& from);

  inline ResponseAction& operator=(const ResponseAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseAction(ResponseAction&& from) noexcept
    : ResponseAction() {
    *this = ::std::move(from);
  }

  inline ResponseAction& operator=(ResponseAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseAction* internal_default_instance() {
    return reinterpret_cast<const ResponseAction*>(
               &_ResponseAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ResponseAction* other);
  friend void swap(ResponseAction& a, ResponseAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseAction* New() const final {
    return CreateMaybeMessage<ResponseAction>(NULL);
  }

  ResponseAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseAction& from);
  void MergeFrom(const ResponseAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.ActionResult result = 1;
  int result_size() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::SCRAPIProtocol::ActionResult result(int index) const;
  void set_result(int index, ::SCRAPIProtocol::ActionResult value);
  void add_result(::SCRAPIProtocol::ActionResult value);
  const ::google::protobuf::RepeatedField<int>& result() const;
  ::google::protobuf::RepeatedField<int>* mutable_result();

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> result_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestObserverAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestObserverAction) */ {
 public:
  RequestObserverAction();
  virtual ~RequestObserverAction();

  RequestObserverAction(const RequestObserverAction& from);

  inline RequestObserverAction& operator=(const RequestObserverAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestObserverAction(RequestObserverAction&& from) noexcept
    : RequestObserverAction() {
    *this = ::std::move(from);
  }

  inline RequestObserverAction& operator=(RequestObserverAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestObserverAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestObserverAction* internal_default_instance() {
    return reinterpret_cast<const RequestObserverAction*>(
               &_RequestObserverAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(RequestObserverAction* other);
  friend void swap(RequestObserverAction& a, RequestObserverAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestObserverAction* New() const final {
    return CreateMaybeMessage<RequestObserverAction>(NULL);
  }

  RequestObserverAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestObserverAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestObserverAction& from);
  void MergeFrom(const RequestObserverAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestObserverAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.ObserverAction actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  ::SCRAPIProtocol::ObserverAction* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ObserverAction >*
      mutable_actions();
  const ::SCRAPIProtocol::ObserverAction& actions(int index) const;
  ::SCRAPIProtocol::ObserverAction* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ObserverAction >&
      actions() const;

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestObserverAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ObserverAction > actions_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseObserverAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseObserverAction) */ {
 public:
  ResponseObserverAction();
  virtual ~ResponseObserverAction();

  ResponseObserverAction(const ResponseObserverAction& from);

  inline ResponseObserverAction& operator=(const ResponseObserverAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseObserverAction(ResponseObserverAction&& from) noexcept
    : ResponseObserverAction() {
    *this = ::std::move(from);
  }

  inline ResponseObserverAction& operator=(ResponseObserverAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseObserverAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseObserverAction* internal_default_instance() {
    return reinterpret_cast<const ResponseObserverAction*>(
               &_ResponseObserverAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ResponseObserverAction* other);
  friend void swap(ResponseObserverAction& a, ResponseObserverAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseObserverAction* New() const final {
    return CreateMaybeMessage<ResponseObserverAction>(NULL);
  }

  ResponseObserverAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseObserverAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseObserverAction& from);
  void MergeFrom(const ResponseObserverAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseObserverAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseObserverAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestStep) */ {
 public:
  RequestStep();
  virtual ~RequestStep();

  RequestStep(const RequestStep& from);

  inline RequestStep& operator=(const RequestStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestStep(RequestStep&& from) noexcept
    : RequestStep() {
    *this = ::std::move(from);
  }

  inline RequestStep& operator=(RequestStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestStep* internal_default_instance() {
    return reinterpret_cast<const RequestStep*>(
               &_RequestStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(RequestStep* other);
  friend void swap(RequestStep& a, RequestStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestStep* New() const final {
    return CreateMaybeMessage<RequestStep>(NULL);
  }

  RequestStep* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestStep>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestStep& from);
  void MergeFrom(const RequestStep& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestStep)
 private:
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 count_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseStep) */ {
 public:
  ResponseStep();
  virtual ~ResponseStep();

  ResponseStep(const ResponseStep& from);

  inline ResponseStep& operator=(const ResponseStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseStep(ResponseStep&& from) noexcept
    : ResponseStep() {
    *this = ::std::move(from);
  }

  inline ResponseStep& operator=(ResponseStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseStep* internal_default_instance() {
    return reinterpret_cast<const ResponseStep*>(
               &_ResponseStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(ResponseStep* other);
  friend void swap(ResponseStep& a, ResponseStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseStep* New() const final {
    return CreateMaybeMessage<ResponseStep>(NULL);
  }

  ResponseStep* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseStep>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseStep& from);
  void MergeFrom(const ResponseStep& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseStep)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestData) */ {
 public:
  RequestData();
  virtual ~RequestData();

  RequestData(const RequestData& from);

  inline RequestData& operator=(const RequestData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestData(RequestData&& from) noexcept
    : RequestData() {
    *this = ::std::move(from);
  }

  inline RequestData& operator=(RequestData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestData* internal_default_instance() {
    return reinterpret_cast<const RequestData*>(
               &_RequestData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(RequestData* other);
  friend void swap(RequestData& a, RequestData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestData* New() const final {
    return CreateMaybeMessage<RequestData>(NULL);
  }

  RequestData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestData& from);
  void MergeFrom(const RequestData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  bool ability_id() const;
  void set_ability_id(bool value);

  // optional bool unit_type_id = 2;
  bool has_unit_type_id() const;
  void clear_unit_type_id();
  static const int kUnitTypeIdFieldNumber = 2;
  bool unit_type_id() const;
  void set_unit_type_id(bool value);

  // optional bool upgrade_id = 3;
  bool has_upgrade_id() const;
  void clear_upgrade_id();
  static const int kUpgradeIdFieldNumber = 3;
  bool upgrade_id() const;
  void set_upgrade_id(bool value);

  // optional bool buff_id = 4;
  bool has_buff_id() const;
  void clear_buff_id();
  static const int kBuffIdFieldNumber = 4;
  bool buff_id() const;
  void set_buff_id(bool value);

  // optional bool effect_id = 5;
  bool has_effect_id() const;
  void clear_effect_id();
  static const int kEffectIdFieldNumber = 5;
  bool effect_id() const;
  void set_effect_id(bool value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestData)
 private:
  void set_has_ability_id();
  void clear_has_ability_id();
  void set_has_unit_type_id();
  void clear_has_unit_type_id();
  void set_has_upgrade_id();
  void clear_has_upgrade_id();
  void set_has_buff_id();
  void clear_has_buff_id();
  void set_has_effect_id();
  void clear_has_effect_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool ability_id_;
  bool unit_type_id_;
  bool upgrade_id_;
  bool buff_id_;
  bool effect_id_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseData) */ {
 public:
  ResponseData();
  virtual ~ResponseData();

  ResponseData(const ResponseData& from);

  inline ResponseData& operator=(const ResponseData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseData(ResponseData&& from) noexcept
    : ResponseData() {
    *this = ::std::move(from);
  }

  inline ResponseData& operator=(ResponseData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseData* internal_default_instance() {
    return reinterpret_cast<const ResponseData*>(
               &_ResponseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(ResponseData* other);
  friend void swap(ResponseData& a, ResponseData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseData* New() const final {
    return CreateMaybeMessage<ResponseData>(NULL);
  }

  ResponseData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseData& from);
  void MergeFrom(const ResponseData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.AbilityData abilities = 1;
  int abilities_size() const;
  void clear_abilities();
  static const int kAbilitiesFieldNumber = 1;
  ::SCRAPIProtocol::AbilityData* mutable_abilities(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::AbilityData >*
      mutable_abilities();
  const ::SCRAPIProtocol::AbilityData& abilities(int index) const;
  ::SCRAPIProtocol::AbilityData* add_abilities();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::AbilityData >&
      abilities() const;

  // repeated .SCRAPIProtocol.UnitTypeData units = 2;
  int units_size() const;
  void clear_units();
  static const int kUnitsFieldNumber = 2;
  ::SCRAPIProtocol::UnitTypeData* mutable_units(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitTypeData >*
      mutable_units();
  const ::SCRAPIProtocol::UnitTypeData& units(int index) const;
  ::SCRAPIProtocol::UnitTypeData* add_units();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitTypeData >&
      units() const;

  // repeated .SCRAPIProtocol.UpgradeData upgrades = 3;
  int upgrades_size() const;
  void clear_upgrades();
  static const int kUpgradesFieldNumber = 3;
  ::SCRAPIProtocol::UpgradeData* mutable_upgrades(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UpgradeData >*
      mutable_upgrades();
  const ::SCRAPIProtocol::UpgradeData& upgrades(int index) const;
  ::SCRAPIProtocol::UpgradeData* add_upgrades();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UpgradeData >&
      upgrades() const;

  // repeated .SCRAPIProtocol.BuffData buffs = 4;
  int buffs_size() const;
  void clear_buffs();
  static const int kBuffsFieldNumber = 4;
  ::SCRAPIProtocol::BuffData* mutable_buffs(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::BuffData >*
      mutable_buffs();
  const ::SCRAPIProtocol::BuffData& buffs(int index) const;
  ::SCRAPIProtocol::BuffData* add_buffs();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::BuffData >&
      buffs() const;

  // repeated .SCRAPIProtocol.EffectData effects = 5;
  int effects_size() const;
  void clear_effects();
  static const int kEffectsFieldNumber = 5;
  ::SCRAPIProtocol::EffectData* mutable_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::EffectData >*
      mutable_effects();
  const ::SCRAPIProtocol::EffectData& effects(int index) const;
  ::SCRAPIProtocol::EffectData* add_effects();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::EffectData >&
      effects() const;

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::AbilityData > abilities_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitTypeData > units_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UpgradeData > upgrades_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::BuffData > buffs_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::EffectData > effects_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestSaveReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestSaveReplay) */ {
 public:
  RequestSaveReplay();
  virtual ~RequestSaveReplay();

  RequestSaveReplay(const RequestSaveReplay& from);

  inline RequestSaveReplay& operator=(const RequestSaveReplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestSaveReplay(RequestSaveReplay&& from) noexcept
    : RequestSaveReplay() {
    *this = ::std::move(from);
  }

  inline RequestSaveReplay& operator=(RequestSaveReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSaveReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestSaveReplay* internal_default_instance() {
    return reinterpret_cast<const RequestSaveReplay*>(
               &_RequestSaveReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(RequestSaveReplay* other);
  friend void swap(RequestSaveReplay& a, RequestSaveReplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestSaveReplay* New() const final {
    return CreateMaybeMessage<RequestSaveReplay>(NULL);
  }

  RequestSaveReplay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestSaveReplay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestSaveReplay& from);
  void MergeFrom(const RequestSaveReplay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSaveReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestSaveReplay)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseSaveReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseSaveReplay) */ {
 public:
  ResponseSaveReplay();
  virtual ~ResponseSaveReplay();

  ResponseSaveReplay(const ResponseSaveReplay& from);

  inline ResponseSaveReplay& operator=(const ResponseSaveReplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseSaveReplay(ResponseSaveReplay&& from) noexcept
    : ResponseSaveReplay() {
    *this = ::std::move(from);
  }

  inline ResponseSaveReplay& operator=(ResponseSaveReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseSaveReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseSaveReplay* internal_default_instance() {
    return reinterpret_cast<const ResponseSaveReplay*>(
               &_ResponseSaveReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(ResponseSaveReplay* other);
  friend void swap(ResponseSaveReplay& a, ResponseSaveReplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseSaveReplay* New() const final {
    return CreateMaybeMessage<ResponseSaveReplay>(NULL);
  }

  ResponseSaveReplay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseSaveReplay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseSaveReplay& from);
  void MergeFrom(const ResponseSaveReplay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseSaveReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseSaveReplay)
 private:
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestReplayInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestReplayInfo) */ {
 public:
  RequestReplayInfo();
  virtual ~RequestReplayInfo();

  RequestReplayInfo(const RequestReplayInfo& from);

  inline RequestReplayInfo& operator=(const RequestReplayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestReplayInfo(RequestReplayInfo&& from) noexcept
    : RequestReplayInfo() {
    *this = ::std::move(from);
  }

  inline RequestReplayInfo& operator=(RequestReplayInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestReplayInfo& default_instance();

  enum ReplayCase {
    kReplayPath = 1,
    kReplayData = 2,
    REPLAY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestReplayInfo* internal_default_instance() {
    return reinterpret_cast<const RequestReplayInfo*>(
               &_RequestReplayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(RequestReplayInfo* other);
  friend void swap(RequestReplayInfo& a, RequestReplayInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestReplayInfo* New() const final {
    return CreateMaybeMessage<RequestReplayInfo>(NULL);
  }

  RequestReplayInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestReplayInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestReplayInfo& from);
  void MergeFrom(const RequestReplayInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestReplayInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool download_data = 3;
  bool has_download_data() const;
  void clear_download_data();
  static const int kDownloadDataFieldNumber = 3;
  bool download_data() const;
  void set_download_data(bool value);

  // optional string replay_path = 1;
  bool has_replay_path() const;
  void clear_replay_path();
  static const int kReplayPathFieldNumber = 1;
  const ::std::string& replay_path() const;
  void set_replay_path(const ::std::string& value);
  #if LANG_CXX11
  void set_replay_path(::std::string&& value);
  #endif
  void set_replay_path(const char* value);
  void set_replay_path(const char* value, size_t size);
  ::std::string* mutable_replay_path();
  ::std::string* release_replay_path();
  void set_allocated_replay_path(::std::string* replay_path);

  // optional bytes replay_data = 2;
  bool has_replay_data() const;
  void clear_replay_data();
  static const int kReplayDataFieldNumber = 2;
  const ::std::string& replay_data() const;
  void set_replay_data(const ::std::string& value);
  #if LANG_CXX11
  void set_replay_data(::std::string&& value);
  #endif
  void set_replay_data(const char* value);
  void set_replay_data(const void* value, size_t size);
  ::std::string* mutable_replay_data();
  ::std::string* release_replay_data();
  void set_allocated_replay_data(::std::string* replay_data);

  void clear_replay();
  ReplayCase replay_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestReplayInfo)
 private:
  void set_has_replay_path();
  void set_has_replay_data();
  void set_has_download_data();
  void clear_has_download_data();

  inline bool has_replay() const;
  inline void clear_has_replay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool download_data_;
  union ReplayUnion {
    ReplayUnion() {}
    ::google::protobuf::internal::ArenaStringPtr replay_path_;
    ::google::protobuf::internal::ArenaStringPtr replay_data_;
  } replay_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerInfoExtra : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.PlayerInfoExtra) */ {
 public:
  PlayerInfoExtra();
  virtual ~PlayerInfoExtra();

  PlayerInfoExtra(const PlayerInfoExtra& from);

  inline PlayerInfoExtra& operator=(const PlayerInfoExtra& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfoExtra(PlayerInfoExtra&& from) noexcept
    : PlayerInfoExtra() {
    *this = ::std::move(from);
  }

  inline PlayerInfoExtra& operator=(PlayerInfoExtra&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfoExtra& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfoExtra* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoExtra*>(
               &_PlayerInfoExtra_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(PlayerInfoExtra* other);
  friend void swap(PlayerInfoExtra& a, PlayerInfoExtra& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfoExtra* New() const final {
    return CreateMaybeMessage<PlayerInfoExtra>(NULL);
  }

  PlayerInfoExtra* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfoExtra>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerInfoExtra& from);
  void MergeFrom(const PlayerInfoExtra& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfoExtra* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.PlayerInfo player_info = 1;
  bool has_player_info() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::PlayerInfo& _internal_player_info() const;
  public:
  const ::SCRAPIProtocol::PlayerInfo& player_info() const;
  ::SCRAPIProtocol::PlayerInfo* release_player_info();
  ::SCRAPIProtocol::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::SCRAPIProtocol::PlayerInfo* player_info);

  // optional .SCRAPIProtocol.PlayerResult player_result = 2;
  bool has_player_result() const;
  void clear_player_result();
  static const int kPlayerResultFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::PlayerResult& _internal_player_result() const;
  public:
  const ::SCRAPIProtocol::PlayerResult& player_result() const;
  ::SCRAPIProtocol::PlayerResult* release_player_result();
  ::SCRAPIProtocol::PlayerResult* mutable_player_result();
  void set_allocated_player_result(::SCRAPIProtocol::PlayerResult* player_result);

  // optional int32 player_mmr = 3;
  bool has_player_mmr() const;
  void clear_player_mmr();
  static const int kPlayerMmrFieldNumber = 3;
  ::google::protobuf::int32 player_mmr() const;
  void set_player_mmr(::google::protobuf::int32 value);

  // optional int32 player_apm = 4;
  bool has_player_apm() const;
  void clear_player_apm();
  static const int kPlayerApmFieldNumber = 4;
  ::google::protobuf::int32 player_apm() const;
  void set_player_apm(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.PlayerInfoExtra)
 private:
  void set_has_player_info();
  void clear_has_player_info();
  void set_has_player_result();
  void clear_has_player_result();
  void set_has_player_mmr();
  void clear_has_player_mmr();
  void set_has_player_apm();
  void clear_has_player_apm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::PlayerInfo* player_info_;
  ::SCRAPIProtocol::PlayerResult* player_result_;
  ::google::protobuf::int32 player_mmr_;
  ::google::protobuf::int32 player_apm_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseReplayInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseReplayInfo) */ {
 public:
  ResponseReplayInfo();
  virtual ~ResponseReplayInfo();

  ResponseReplayInfo(const ResponseReplayInfo& from);

  inline ResponseReplayInfo& operator=(const ResponseReplayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseReplayInfo(ResponseReplayInfo&& from) noexcept
    : ResponseReplayInfo() {
    *this = ::std::move(from);
  }

  inline ResponseReplayInfo& operator=(ResponseReplayInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseReplayInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseReplayInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseReplayInfo*>(
               &_ResponseReplayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(ResponseReplayInfo* other);
  friend void swap(ResponseReplayInfo& a, ResponseReplayInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseReplayInfo* New() const final {
    return CreateMaybeMessage<ResponseReplayInfo>(NULL);
  }

  ResponseReplayInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseReplayInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseReplayInfo& from);
  void MergeFrom(const ResponseReplayInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseReplayInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseReplayInfo_Error Error;
  static const Error MissingReplay =
    ResponseReplayInfo_Error_MissingReplay;
  static const Error InvalidReplayPath =
    ResponseReplayInfo_Error_InvalidReplayPath;
  static const Error InvalidReplayData =
    ResponseReplayInfo_Error_InvalidReplayData;
  static const Error ParsingError =
    ResponseReplayInfo_Error_ParsingError;
  static const Error DownloadError =
    ResponseReplayInfo_Error_DownloadError;
  static inline bool Error_IsValid(int value) {
    return ResponseReplayInfo_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseReplayInfo_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseReplayInfo_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseReplayInfo_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseReplayInfo_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseReplayInfo_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseReplayInfo_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.PlayerInfoExtra player_info = 3;
  int player_info_size() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 3;
  ::SCRAPIProtocol::PlayerInfoExtra* mutable_player_info(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerInfoExtra >*
      mutable_player_info();
  const ::SCRAPIProtocol::PlayerInfoExtra& player_info(int index) const;
  ::SCRAPIProtocol::PlayerInfoExtra* add_player_info();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerInfoExtra >&
      player_info() const;

  // optional string map_name = 1;
  bool has_map_name() const;
  void clear_map_name();
  static const int kMapNameFieldNumber = 1;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_map_name(::std::string&& value);
  #endif
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // optional string local_map_path = 2;
  bool has_local_map_path() const;
  void clear_local_map_path();
  static const int kLocalMapPathFieldNumber = 2;
  const ::std::string& local_map_path() const;
  void set_local_map_path(const ::std::string& value);
  #if LANG_CXX11
  void set_local_map_path(::std::string&& value);
  #endif
  void set_local_map_path(const char* value);
  void set_local_map_path(const char* value, size_t size);
  ::std::string* mutable_local_map_path();
  ::std::string* release_local_map_path();
  void set_allocated_local_map_path(::std::string* local_map_path);

  // optional string game_version = 6;
  bool has_game_version() const;
  void clear_game_version();
  static const int kGameVersionFieldNumber = 6;
  const ::std::string& game_version() const;
  void set_game_version(const ::std::string& value);
  #if LANG_CXX11
  void set_game_version(::std::string&& value);
  #endif
  void set_game_version(const char* value);
  void set_game_version(const char* value, size_t size);
  ::std::string* mutable_game_version();
  ::std::string* release_game_version();
  void set_allocated_game_version(::std::string* game_version);

  // optional string error_details = 10;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 10;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  #if LANG_CXX11
  void set_error_details(::std::string&& value);
  #endif
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // optional string data_version = 11;
  bool has_data_version() const;
  void clear_data_version();
  static const int kDataVersionFieldNumber = 11;
  const ::std::string& data_version() const;
  void set_data_version(const ::std::string& value);
  #if LANG_CXX11
  void set_data_version(::std::string&& value);
  #endif
  void set_data_version(const char* value);
  void set_data_version(const char* value, size_t size);
  ::std::string* mutable_data_version();
  ::std::string* release_data_version();
  void set_allocated_data_version(::std::string* data_version);

  // optional uint32 game_duration_loops = 4;
  bool has_game_duration_loops() const;
  void clear_game_duration_loops();
  static const int kGameDurationLoopsFieldNumber = 4;
  ::google::protobuf::uint32 game_duration_loops() const;
  void set_game_duration_loops(::google::protobuf::uint32 value);

  // optional float game_duration_seconds = 5;
  bool has_game_duration_seconds() const;
  void clear_game_duration_seconds();
  static const int kGameDurationSecondsFieldNumber = 5;
  float game_duration_seconds() const;
  void set_game_duration_seconds(float value);

  // optional uint32 data_build = 7;
  bool has_data_build() const;
  void clear_data_build();
  static const int kDataBuildFieldNumber = 7;
  ::google::protobuf::uint32 data_build() const;
  void set_data_build(::google::protobuf::uint32 value);

  // optional uint32 base_build = 8;
  bool has_base_build() const;
  void clear_base_build();
  static const int kBaseBuildFieldNumber = 8;
  ::google::protobuf::uint32 base_build() const;
  void set_base_build(::google::protobuf::uint32 value);

  // optional .SCRAPIProtocol.ResponseReplayInfo.Error error = 9;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 9;
  ::SCRAPIProtocol::ResponseReplayInfo_Error error() const;
  void set_error(::SCRAPIProtocol::ResponseReplayInfo_Error value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseReplayInfo)
 private:
  void set_has_map_name();
  void clear_has_map_name();
  void set_has_local_map_path();
  void clear_has_local_map_path();
  void set_has_game_duration_loops();
  void clear_has_game_duration_loops();
  void set_has_game_duration_seconds();
  void clear_has_game_duration_seconds();
  void set_has_game_version();
  void clear_has_game_version();
  void set_has_data_version();
  void clear_has_data_version();
  void set_has_data_build();
  void clear_has_data_build();
  void set_has_base_build();
  void clear_has_base_build();
  void set_has_error();
  void clear_has_error();
  void set_has_error_details();
  void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerInfoExtra > player_info_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  ::google::protobuf::internal::ArenaStringPtr local_map_path_;
  ::google::protobuf::internal::ArenaStringPtr game_version_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  ::google::protobuf::internal::ArenaStringPtr data_version_;
  ::google::protobuf::uint32 game_duration_loops_;
  float game_duration_seconds_;
  ::google::protobuf::uint32 data_build_;
  ::google::protobuf::uint32 base_build_;
  int error_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestAvailableMaps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestAvailableMaps) */ {
 public:
  RequestAvailableMaps();
  virtual ~RequestAvailableMaps();

  RequestAvailableMaps(const RequestAvailableMaps& from);

  inline RequestAvailableMaps& operator=(const RequestAvailableMaps& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestAvailableMaps(RequestAvailableMaps&& from) noexcept
    : RequestAvailableMaps() {
    *this = ::std::move(from);
  }

  inline RequestAvailableMaps& operator=(RequestAvailableMaps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestAvailableMaps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestAvailableMaps* internal_default_instance() {
    return reinterpret_cast<const RequestAvailableMaps*>(
               &_RequestAvailableMaps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(RequestAvailableMaps* other);
  friend void swap(RequestAvailableMaps& a, RequestAvailableMaps& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestAvailableMaps* New() const final {
    return CreateMaybeMessage<RequestAvailableMaps>(NULL);
  }

  RequestAvailableMaps* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestAvailableMaps>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestAvailableMaps& from);
  void MergeFrom(const RequestAvailableMaps& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAvailableMaps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestAvailableMaps)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseAvailableMaps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseAvailableMaps) */ {
 public:
  ResponseAvailableMaps();
  virtual ~ResponseAvailableMaps();

  ResponseAvailableMaps(const ResponseAvailableMaps& from);

  inline ResponseAvailableMaps& operator=(const ResponseAvailableMaps& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseAvailableMaps(ResponseAvailableMaps&& from) noexcept
    : ResponseAvailableMaps() {
    *this = ::std::move(from);
  }

  inline ResponseAvailableMaps& operator=(ResponseAvailableMaps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseAvailableMaps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseAvailableMaps* internal_default_instance() {
    return reinterpret_cast<const ResponseAvailableMaps*>(
               &_ResponseAvailableMaps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(ResponseAvailableMaps* other);
  friend void swap(ResponseAvailableMaps& a, ResponseAvailableMaps& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseAvailableMaps* New() const final {
    return CreateMaybeMessage<ResponseAvailableMaps>(NULL);
  }

  ResponseAvailableMaps* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseAvailableMaps>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseAvailableMaps& from);
  void MergeFrom(const ResponseAvailableMaps& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseAvailableMaps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string local_map_paths = 1;
  int local_map_paths_size() const;
  void clear_local_map_paths();
  static const int kLocalMapPathsFieldNumber = 1;
  const ::std::string& local_map_paths(int index) const;
  ::std::string* mutable_local_map_paths(int index);
  void set_local_map_paths(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_local_map_paths(int index, ::std::string&& value);
  #endif
  void set_local_map_paths(int index, const char* value);
  void set_local_map_paths(int index, const char* value, size_t size);
  ::std::string* add_local_map_paths();
  void add_local_map_paths(const ::std::string& value);
  #if LANG_CXX11
  void add_local_map_paths(::std::string&& value);
  #endif
  void add_local_map_paths(const char* value);
  void add_local_map_paths(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& local_map_paths() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_local_map_paths();

  // repeated string battlenet_map_names = 2;
  int battlenet_map_names_size() const;
  void clear_battlenet_map_names();
  static const int kBattlenetMapNamesFieldNumber = 2;
  const ::std::string& battlenet_map_names(int index) const;
  ::std::string* mutable_battlenet_map_names(int index);
  void set_battlenet_map_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_battlenet_map_names(int index, ::std::string&& value);
  #endif
  void set_battlenet_map_names(int index, const char* value);
  void set_battlenet_map_names(int index, const char* value, size_t size);
  ::std::string* add_battlenet_map_names();
  void add_battlenet_map_names(const ::std::string& value);
  #if LANG_CXX11
  void add_battlenet_map_names(::std::string&& value);
  #endif
  void add_battlenet_map_names(const char* value);
  void add_battlenet_map_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& battlenet_map_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_battlenet_map_names();

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseAvailableMaps)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> local_map_paths_;
  ::google::protobuf::RepeatedPtrField< ::std::string> battlenet_map_names_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestSaveMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestSaveMap) */ {
 public:
  RequestSaveMap();
  virtual ~RequestSaveMap();

  RequestSaveMap(const RequestSaveMap& from);

  inline RequestSaveMap& operator=(const RequestSaveMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestSaveMap(RequestSaveMap&& from) noexcept
    : RequestSaveMap() {
    *this = ::std::move(from);
  }

  inline RequestSaveMap& operator=(RequestSaveMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSaveMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestSaveMap* internal_default_instance() {
    return reinterpret_cast<const RequestSaveMap*>(
               &_RequestSaveMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(RequestSaveMap* other);
  friend void swap(RequestSaveMap& a, RequestSaveMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestSaveMap* New() const final {
    return CreateMaybeMessage<RequestSaveMap>(NULL);
  }

  RequestSaveMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestSaveMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestSaveMap& from);
  void MergeFrom(const RequestSaveMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSaveMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string map_path = 1;
  bool has_map_path() const;
  void clear_map_path();
  static const int kMapPathFieldNumber = 1;
  const ::std::string& map_path() const;
  void set_map_path(const ::std::string& value);
  #if LANG_CXX11
  void set_map_path(::std::string&& value);
  #endif
  void set_map_path(const char* value);
  void set_map_path(const char* value, size_t size);
  ::std::string* mutable_map_path();
  ::std::string* release_map_path();
  void set_allocated_map_path(::std::string* map_path);

  // optional bytes map_data = 2;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 2;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  #if LANG_CXX11
  void set_map_data(::std::string&& value);
  #endif
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestSaveMap)
 private:
  void set_has_map_path();
  void clear_has_map_path();
  void set_has_map_data();
  void clear_has_map_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_path_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseSaveMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseSaveMap) */ {
 public:
  ResponseSaveMap();
  virtual ~ResponseSaveMap();

  ResponseSaveMap(const ResponseSaveMap& from);

  inline ResponseSaveMap& operator=(const ResponseSaveMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseSaveMap(ResponseSaveMap&& from) noexcept
    : ResponseSaveMap() {
    *this = ::std::move(from);
  }

  inline ResponseSaveMap& operator=(ResponseSaveMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseSaveMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseSaveMap* internal_default_instance() {
    return reinterpret_cast<const ResponseSaveMap*>(
               &_ResponseSaveMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(ResponseSaveMap* other);
  friend void swap(ResponseSaveMap& a, ResponseSaveMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseSaveMap* New() const final {
    return CreateMaybeMessage<ResponseSaveMap>(NULL);
  }

  ResponseSaveMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseSaveMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseSaveMap& from);
  void MergeFrom(const ResponseSaveMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseSaveMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseSaveMap_Error Error;
  static const Error InvalidMapData =
    ResponseSaveMap_Error_InvalidMapData;
  static inline bool Error_IsValid(int value) {
    return ResponseSaveMap_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseSaveMap_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseSaveMap_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseSaveMap_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseSaveMap_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseSaveMap_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseSaveMap_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ResponseSaveMap.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SCRAPIProtocol::ResponseSaveMap_Error error() const;
  void set_error(::SCRAPIProtocol::ResponseSaveMap_Error value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseSaveMap)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int error_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestPing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestPing) */ {
 public:
  RequestPing();
  virtual ~RequestPing();

  RequestPing(const RequestPing& from);

  inline RequestPing& operator=(const RequestPing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestPing(RequestPing&& from) noexcept
    : RequestPing() {
    *this = ::std::move(from);
  }

  inline RequestPing& operator=(RequestPing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestPing* internal_default_instance() {
    return reinterpret_cast<const RequestPing*>(
               &_RequestPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(RequestPing* other);
  friend void swap(RequestPing& a, RequestPing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestPing* New() const final {
    return CreateMaybeMessage<RequestPing>(NULL);
  }

  RequestPing* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestPing>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestPing& from);
  void MergeFrom(const RequestPing& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestPing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestPing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponsePing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponsePing) */ {
 public:
  ResponsePing();
  virtual ~ResponsePing();

  ResponsePing(const ResponsePing& from);

  inline ResponsePing& operator=(const ResponsePing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponsePing(ResponsePing&& from) noexcept
    : ResponsePing() {
    *this = ::std::move(from);
  }

  inline ResponsePing& operator=(ResponsePing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponsePing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponsePing* internal_default_instance() {
    return reinterpret_cast<const ResponsePing*>(
               &_ResponsePing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(ResponsePing* other);
  friend void swap(ResponsePing& a, ResponsePing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponsePing* New() const final {
    return CreateMaybeMessage<ResponsePing>(NULL);
  }

  ResponsePing* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponsePing>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponsePing& from);
  void MergeFrom(const ResponsePing& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponsePing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string game_version = 1;
  bool has_game_version() const;
  void clear_game_version();
  static const int kGameVersionFieldNumber = 1;
  const ::std::string& game_version() const;
  void set_game_version(const ::std::string& value);
  #if LANG_CXX11
  void set_game_version(::std::string&& value);
  #endif
  void set_game_version(const char* value);
  void set_game_version(const char* value, size_t size);
  ::std::string* mutable_game_version();
  ::std::string* release_game_version();
  void set_allocated_game_version(::std::string* game_version);

  // optional string data_version = 2;
  bool has_data_version() const;
  void clear_data_version();
  static const int kDataVersionFieldNumber = 2;
  const ::std::string& data_version() const;
  void set_data_version(const ::std::string& value);
  #if LANG_CXX11
  void set_data_version(::std::string&& value);
  #endif
  void set_data_version(const char* value);
  void set_data_version(const char* value, size_t size);
  ::std::string* mutable_data_version();
  ::std::string* release_data_version();
  void set_allocated_data_version(::std::string* data_version);

  // optional uint32 data_build = 3;
  bool has_data_build() const;
  void clear_data_build();
  static const int kDataBuildFieldNumber = 3;
  ::google::protobuf::uint32 data_build() const;
  void set_data_build(::google::protobuf::uint32 value);

  // optional uint32 base_build = 4;
  bool has_base_build() const;
  void clear_base_build();
  static const int kBaseBuildFieldNumber = 4;
  ::google::protobuf::uint32 base_build() const;
  void set_base_build(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponsePing)
 private:
  void set_has_game_version();
  void clear_has_game_version();
  void set_has_data_version();
  void clear_has_data_version();
  void set_has_data_build();
  void clear_has_data_build();
  void set_has_base_build();
  void clear_has_base_build();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr game_version_;
  ::google::protobuf::internal::ArenaStringPtr data_version_;
  ::google::protobuf::uint32 data_build_;
  ::google::protobuf::uint32 base_build_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestDebug : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestDebug) */ {
 public:
  RequestDebug();
  virtual ~RequestDebug();

  RequestDebug(const RequestDebug& from);

  inline RequestDebug& operator=(const RequestDebug& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestDebug(RequestDebug&& from) noexcept
    : RequestDebug() {
    *this = ::std::move(from);
  }

  inline RequestDebug& operator=(RequestDebug&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestDebug& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestDebug* internal_default_instance() {
    return reinterpret_cast<const RequestDebug*>(
               &_RequestDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(RequestDebug* other);
  friend void swap(RequestDebug& a, RequestDebug& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestDebug* New() const final {
    return CreateMaybeMessage<RequestDebug>(NULL);
  }

  RequestDebug* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestDebug>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestDebug& from);
  void MergeFrom(const RequestDebug& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestDebug* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.DebugCommand debug = 1;
  int debug_size() const;
  void clear_debug();
  static const int kDebugFieldNumber = 1;
  ::SCRAPIProtocol::DebugCommand* mutable_debug(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugCommand >*
      mutable_debug();
  const ::SCRAPIProtocol::DebugCommand& debug(int index) const;
  ::SCRAPIProtocol::DebugCommand* add_debug();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugCommand >&
      debug() const;

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestDebug)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugCommand > debug_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseDebug : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseDebug) */ {
 public:
  ResponseDebug();
  virtual ~ResponseDebug();

  ResponseDebug(const ResponseDebug& from);

  inline ResponseDebug& operator=(const ResponseDebug& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseDebug(ResponseDebug&& from) noexcept
    : ResponseDebug() {
    *this = ::std::move(from);
  }

  inline ResponseDebug& operator=(ResponseDebug&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseDebug& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseDebug* internal_default_instance() {
    return reinterpret_cast<const ResponseDebug*>(
               &_ResponseDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(ResponseDebug* other);
  friend void swap(ResponseDebug& a, ResponseDebug& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseDebug* New() const final {
    return CreateMaybeMessage<ResponseDebug>(NULL);
  }

  ResponseDebug* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseDebug>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseDebug& from);
  void MergeFrom(const ResponseDebug& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseDebug* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseDebug)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestConnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestConnect) */ {
 public:
  RequestConnect();
  virtual ~RequestConnect();

  RequestConnect(const RequestConnect& from);

  inline RequestConnect& operator=(const RequestConnect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestConnect(RequestConnect&& from) noexcept
    : RequestConnect() {
    *this = ::std::move(from);
  }

  inline RequestConnect& operator=(RequestConnect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestConnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestConnect* internal_default_instance() {
    return reinterpret_cast<const RequestConnect*>(
               &_RequestConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(RequestConnect* other);
  friend void swap(RequestConnect& a, RequestConnect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestConnect* New() const final {
    return CreateMaybeMessage<RequestConnect>(NULL);
  }

  RequestConnect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestConnect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestConnect& from);
  void MergeFrom(const RequestConnect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestConnect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestConnect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestEndOfQueue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.RequestEndOfQueue) */ {
 public:
  RequestEndOfQueue();
  virtual ~RequestEndOfQueue();

  RequestEndOfQueue(const RequestEndOfQueue& from);

  inline RequestEndOfQueue& operator=(const RequestEndOfQueue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestEndOfQueue(RequestEndOfQueue&& from) noexcept
    : RequestEndOfQueue() {
    *this = ::std::move(from);
  }

  inline RequestEndOfQueue& operator=(RequestEndOfQueue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestEndOfQueue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestEndOfQueue* internal_default_instance() {
    return reinterpret_cast<const RequestEndOfQueue*>(
               &_RequestEndOfQueue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(RequestEndOfQueue* other);
  friend void swap(RequestEndOfQueue& a, RequestEndOfQueue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestEndOfQueue* New() const final {
    return CreateMaybeMessage<RequestEndOfQueue>(NULL);
  }

  RequestEndOfQueue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestEndOfQueue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestEndOfQueue& from);
  void MergeFrom(const RequestEndOfQueue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestEndOfQueue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.RequestEndOfQueue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseConnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseConnect) */ {
 public:
  ResponseConnect();
  virtual ~ResponseConnect();

  ResponseConnect(const ResponseConnect& from);

  inline ResponseConnect& operator=(const ResponseConnect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseConnect(ResponseConnect&& from) noexcept
    : ResponseConnect() {
    *this = ::std::move(from);
  }

  inline ResponseConnect& operator=(ResponseConnect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseConnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseConnect* internal_default_instance() {
    return reinterpret_cast<const ResponseConnect*>(
               &_ResponseConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(ResponseConnect* other);
  friend void swap(ResponseConnect& a, ResponseConnect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseConnect* New() const final {
    return CreateMaybeMessage<ResponseConnect>(NULL);
  }

  ResponseConnect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseConnect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseConnect& from);
  void MergeFrom(const ResponseConnect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseConnect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseConnect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseEndOfQueue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ResponseEndOfQueue) */ {
 public:
  ResponseEndOfQueue();
  virtual ~ResponseEndOfQueue();

  ResponseEndOfQueue(const ResponseEndOfQueue& from);

  inline ResponseEndOfQueue& operator=(const ResponseEndOfQueue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseEndOfQueue(ResponseEndOfQueue&& from) noexcept
    : ResponseEndOfQueue() {
    *this = ::std::move(from);
  }

  inline ResponseEndOfQueue& operator=(ResponseEndOfQueue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseEndOfQueue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseEndOfQueue* internal_default_instance() {
    return reinterpret_cast<const ResponseEndOfQueue*>(
               &_ResponseEndOfQueue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(ResponseEndOfQueue* other);
  friend void swap(ResponseEndOfQueue& a, ResponseEndOfQueue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseEndOfQueue* New() const final {
    return CreateMaybeMessage<ResponseEndOfQueue>(NULL);
  }

  ResponseEndOfQueue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseEndOfQueue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseEndOfQueue& from);
  void MergeFrom(const ResponseEndOfQueue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseEndOfQueue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ResponseEndOfQueue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerSetup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.PlayerSetup) */ {
 public:
  PlayerSetup();
  virtual ~PlayerSetup();

  PlayerSetup(const PlayerSetup& from);

  inline PlayerSetup& operator=(const PlayerSetup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerSetup(PlayerSetup&& from) noexcept
    : PlayerSetup() {
    *this = ::std::move(from);
  }

  inline PlayerSetup& operator=(PlayerSetup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSetup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerSetup* internal_default_instance() {
    return reinterpret_cast<const PlayerSetup*>(
               &_PlayerSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(PlayerSetup* other);
  friend void swap(PlayerSetup& a, PlayerSetup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerSetup* New() const final {
    return CreateMaybeMessage<PlayerSetup>(NULL);
  }

  PlayerSetup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerSetup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerSetup& from);
  void MergeFrom(const PlayerSetup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerSetup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.Race race = 2;
  bool has_race() const;
  void clear_race();
  static const int kRaceFieldNumber = 2;
  ::SCRAPIProtocol::Race race() const;
  void set_race(::SCRAPIProtocol::Race value);

  // optional .SCRAPIProtocol.PlayerType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::SCRAPIProtocol::PlayerType type() const;
  void set_type(::SCRAPIProtocol::PlayerType value);

  // optional .SCRAPIProtocol.Difficulty difficulty = 3;
  bool has_difficulty() const;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 3;
  ::SCRAPIProtocol::Difficulty difficulty() const;
  void set_difficulty(::SCRAPIProtocol::Difficulty value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.PlayerSetup)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_race();
  void clear_has_race();
  void set_has_difficulty();
  void clear_has_difficulty();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int race_;
  int type_;
  int difficulty_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpatialCameraSetup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.SpatialCameraSetup) */ {
 public:
  SpatialCameraSetup();
  virtual ~SpatialCameraSetup();

  SpatialCameraSetup(const SpatialCameraSetup& from);

  inline SpatialCameraSetup& operator=(const SpatialCameraSetup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpatialCameraSetup(SpatialCameraSetup&& from) noexcept
    : SpatialCameraSetup() {
    *this = ::std::move(from);
  }

  inline SpatialCameraSetup& operator=(SpatialCameraSetup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpatialCameraSetup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpatialCameraSetup* internal_default_instance() {
    return reinterpret_cast<const SpatialCameraSetup*>(
               &_SpatialCameraSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(SpatialCameraSetup* other);
  friend void swap(SpatialCameraSetup& a, SpatialCameraSetup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpatialCameraSetup* New() const final {
    return CreateMaybeMessage<SpatialCameraSetup>(NULL);
  }

  SpatialCameraSetup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpatialCameraSetup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpatialCameraSetup& from);
  void MergeFrom(const SpatialCameraSetup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpatialCameraSetup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.Size2DI resolution = 2;
  bool has_resolution() const;
  void clear_resolution();
  static const int kResolutionFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::Size2DI& _internal_resolution() const;
  public:
  const ::SCRAPIProtocol::Size2DI& resolution() const;
  ::SCRAPIProtocol::Size2DI* release_resolution();
  ::SCRAPIProtocol::Size2DI* mutable_resolution();
  void set_allocated_resolution(::SCRAPIProtocol::Size2DI* resolution);

  // optional .SCRAPIProtocol.Size2DI minimap_resolution = 3;
  bool has_minimap_resolution() const;
  void clear_minimap_resolution();
  static const int kMinimapResolutionFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::Size2DI& _internal_minimap_resolution() const;
  public:
  const ::SCRAPIProtocol::Size2DI& minimap_resolution() const;
  ::SCRAPIProtocol::Size2DI* release_minimap_resolution();
  ::SCRAPIProtocol::Size2DI* mutable_minimap_resolution();
  void set_allocated_minimap_resolution(::SCRAPIProtocol::Size2DI* minimap_resolution);

  // optional float width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  float width() const;
  void set_width(float value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.SpatialCameraSetup)
 private:
  void set_has_width();
  void clear_has_width();
  void set_has_resolution();
  void clear_has_resolution();
  void set_has_minimap_resolution();
  void clear_has_minimap_resolution();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::Size2DI* resolution_;
  ::SCRAPIProtocol::Size2DI* minimap_resolution_;
  float width_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InterfaceOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.InterfaceOptions) */ {
 public:
  InterfaceOptions();
  virtual ~InterfaceOptions();

  InterfaceOptions(const InterfaceOptions& from);

  inline InterfaceOptions& operator=(const InterfaceOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InterfaceOptions(InterfaceOptions&& from) noexcept
    : InterfaceOptions() {
    *this = ::std::move(from);
  }

  inline InterfaceOptions& operator=(InterfaceOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterfaceOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InterfaceOptions* internal_default_instance() {
    return reinterpret_cast<const InterfaceOptions*>(
               &_InterfaceOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(InterfaceOptions* other);
  friend void swap(InterfaceOptions& a, InterfaceOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InterfaceOptions* New() const final {
    return CreateMaybeMessage<InterfaceOptions>(NULL);
  }

  InterfaceOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InterfaceOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InterfaceOptions& from);
  void MergeFrom(const InterfaceOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.SpatialCameraSetup feature_layer = 3;
  bool has_feature_layer() const;
  void clear_feature_layer();
  static const int kFeatureLayerFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::SpatialCameraSetup& _internal_feature_layer() const;
  public:
  const ::SCRAPIProtocol::SpatialCameraSetup& feature_layer() const;
  ::SCRAPIProtocol::SpatialCameraSetup* release_feature_layer();
  ::SCRAPIProtocol::SpatialCameraSetup* mutable_feature_layer();
  void set_allocated_feature_layer(::SCRAPIProtocol::SpatialCameraSetup* feature_layer);

  // optional .SCRAPIProtocol.SpatialCameraSetup render = 4;
  bool has_render() const;
  void clear_render();
  static const int kRenderFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::SpatialCameraSetup& _internal_render() const;
  public:
  const ::SCRAPIProtocol::SpatialCameraSetup& render() const;
  ::SCRAPIProtocol::SpatialCameraSetup* release_render();
  ::SCRAPIProtocol::SpatialCameraSetup* mutable_render();
  void set_allocated_render(::SCRAPIProtocol::SpatialCameraSetup* render);

  // optional bool raw = 1;
  bool has_raw() const;
  void clear_raw();
  static const int kRawFieldNumber = 1;
  bool raw() const;
  void set_raw(bool value);

  // optional bool score = 2;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  bool score() const;
  void set_score(bool value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.InterfaceOptions)
 private:
  void set_has_raw();
  void clear_has_raw();
  void set_has_score();
  void clear_has_score();
  void set_has_feature_layer();
  void clear_has_feature_layer();
  void set_has_render();
  void clear_has_render();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::SpatialCameraSetup* feature_layer_;
  ::SCRAPIProtocol::SpatialCameraSetup* render_;
  bool raw_;
  bool score_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(PlayerInfo* other);
  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return CreateMaybeMessage<PlayerInfo>(NULL);
  }

  PlayerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional .SCRAPIProtocol.Race race_requested = 3;
  bool has_race_requested() const;
  void clear_race_requested();
  static const int kRaceRequestedFieldNumber = 3;
  ::SCRAPIProtocol::Race race_requested() const;
  void set_race_requested(::SCRAPIProtocol::Race value);

  // optional .SCRAPIProtocol.Race race_actual = 4;
  bool has_race_actual() const;
  void clear_race_actual();
  static const int kRaceActualFieldNumber = 4;
  ::SCRAPIProtocol::Race race_actual() const;
  void set_race_actual(::SCRAPIProtocol::Race value);

  // optional .SCRAPIProtocol.PlayerType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::SCRAPIProtocol::PlayerType type() const;
  void set_type(::SCRAPIProtocol::PlayerType value);

  // optional .SCRAPIProtocol.Difficulty difficulty = 5;
  bool has_difficulty() const;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 5;
  ::SCRAPIProtocol::Difficulty difficulty() const;
  void set_difficulty(::SCRAPIProtocol::Difficulty value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.PlayerInfo)
 private:
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_type();
  void clear_has_type();
  void set_has_race_requested();
  void clear_has_race_requested();
  void set_has_race_actual();
  void clear_has_race_actual();
  void set_has_difficulty();
  void clear_has_difficulty();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 player_id_;
  int race_requested_;
  int race_actual_;
  int type_;
  int difficulty_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerCommon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.PlayerCommon) */ {
 public:
  PlayerCommon();
  virtual ~PlayerCommon();

  PlayerCommon(const PlayerCommon& from);

  inline PlayerCommon& operator=(const PlayerCommon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerCommon(PlayerCommon&& from) noexcept
    : PlayerCommon() {
    *this = ::std::move(from);
  }

  inline PlayerCommon& operator=(PlayerCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCommon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerCommon* internal_default_instance() {
    return reinterpret_cast<const PlayerCommon*>(
               &_PlayerCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(PlayerCommon* other);
  friend void swap(PlayerCommon& a, PlayerCommon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerCommon* New() const final {
    return CreateMaybeMessage<PlayerCommon>(NULL);
  }

  PlayerCommon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerCommon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerCommon& from);
  void MergeFrom(const PlayerCommon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerCommon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional uint32 minerals = 2;
  bool has_minerals() const;
  void clear_minerals();
  static const int kMineralsFieldNumber = 2;
  ::google::protobuf::uint32 minerals() const;
  void set_minerals(::google::protobuf::uint32 value);

  // optional uint32 vespene = 3;
  bool has_vespene() const;
  void clear_vespene();
  static const int kVespeneFieldNumber = 3;
  ::google::protobuf::uint32 vespene() const;
  void set_vespene(::google::protobuf::uint32 value);

  // optional uint32 food_cap = 4;
  bool has_food_cap() const;
  void clear_food_cap();
  static const int kFoodCapFieldNumber = 4;
  ::google::protobuf::uint32 food_cap() const;
  void set_food_cap(::google::protobuf::uint32 value);

  // optional uint32 food_used = 5;
  bool has_food_used() const;
  void clear_food_used();
  static const int kFoodUsedFieldNumber = 5;
  ::google::protobuf::uint32 food_used() const;
  void set_food_used(::google::protobuf::uint32 value);

  // optional uint32 food_army = 6;
  bool has_food_army() const;
  void clear_food_army();
  static const int kFoodArmyFieldNumber = 6;
  ::google::protobuf::uint32 food_army() const;
  void set_food_army(::google::protobuf::uint32 value);

  // optional uint32 food_workers = 7;
  bool has_food_workers() const;
  void clear_food_workers();
  static const int kFoodWorkersFieldNumber = 7;
  ::google::protobuf::uint32 food_workers() const;
  void set_food_workers(::google::protobuf::uint32 value);

  // optional uint32 idle_worker_count = 8;
  bool has_idle_worker_count() const;
  void clear_idle_worker_count();
  static const int kIdleWorkerCountFieldNumber = 8;
  ::google::protobuf::uint32 idle_worker_count() const;
  void set_idle_worker_count(::google::protobuf::uint32 value);

  // optional uint32 army_count = 9;
  bool has_army_count() const;
  void clear_army_count();
  static const int kArmyCountFieldNumber = 9;
  ::google::protobuf::uint32 army_count() const;
  void set_army_count(::google::protobuf::uint32 value);

  // optional uint32 warp_gate_count = 10;
  bool has_warp_gate_count() const;
  void clear_warp_gate_count();
  static const int kWarpGateCountFieldNumber = 10;
  ::google::protobuf::uint32 warp_gate_count() const;
  void set_warp_gate_count(::google::protobuf::uint32 value);

  // optional uint32 larva_count = 11;
  bool has_larva_count() const;
  void clear_larva_count();
  static const int kLarvaCountFieldNumber = 11;
  ::google::protobuf::uint32 larva_count() const;
  void set_larva_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.PlayerCommon)
 private:
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_minerals();
  void clear_has_minerals();
  void set_has_vespene();
  void clear_has_vespene();
  void set_has_food_cap();
  void clear_has_food_cap();
  void set_has_food_used();
  void clear_has_food_used();
  void set_has_food_army();
  void clear_has_food_army();
  void set_has_food_workers();
  void clear_has_food_workers();
  void set_has_idle_worker_count();
  void clear_has_idle_worker_count();
  void set_has_army_count();
  void clear_has_army_count();
  void set_has_warp_gate_count();
  void clear_has_warp_gate_count();
  void set_has_larva_count();
  void clear_has_larva_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 minerals_;
  ::google::protobuf::uint32 vespene_;
  ::google::protobuf::uint32 food_cap_;
  ::google::protobuf::uint32 food_used_;
  ::google::protobuf::uint32 food_army_;
  ::google::protobuf::uint32 food_workers_;
  ::google::protobuf::uint32 idle_worker_count_;
  ::google::protobuf::uint32 army_count_;
  ::google::protobuf::uint32 warp_gate_count_;
  ::google::protobuf::uint32 larva_count_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Observation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.Observation) */ {
 public:
  Observation();
  virtual ~Observation();

  Observation(const Observation& from);

  inline Observation& operator=(const Observation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Observation(Observation&& from) noexcept
    : Observation() {
    *this = ::std::move(from);
  }

  inline Observation& operator=(Observation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Observation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Observation* internal_default_instance() {
    return reinterpret_cast<const Observation*>(
               &_Observation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(Observation* other);
  friend void swap(Observation& a, Observation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Observation* New() const final {
    return CreateMaybeMessage<Observation>(NULL);
  }

  Observation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Observation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Observation& from);
  void MergeFrom(const Observation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Observation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.AvailableAbility abilities = 3;
  int abilities_size() const;
  void clear_abilities();
  static const int kAbilitiesFieldNumber = 3;
  ::SCRAPIProtocol::AvailableAbility* mutable_abilities(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::AvailableAbility >*
      mutable_abilities();
  const ::SCRAPIProtocol::AvailableAbility& abilities(int index) const;
  ::SCRAPIProtocol::AvailableAbility* add_abilities();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::AvailableAbility >&
      abilities() const;

  // repeated .SCRAPIProtocol.Alert alerts = 10;
  int alerts_size() const;
  void clear_alerts();
  static const int kAlertsFieldNumber = 10;
  ::SCRAPIProtocol::Alert alerts(int index) const;
  void set_alerts(int index, ::SCRAPIProtocol::Alert value);
  void add_alerts(::SCRAPIProtocol::Alert value);
  const ::google::protobuf::RepeatedField<int>& alerts() const;
  ::google::protobuf::RepeatedField<int>* mutable_alerts();

  // optional .SCRAPIProtocol.PlayerCommon player_common = 1;
  bool has_player_common() const;
  void clear_player_common();
  static const int kPlayerCommonFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::PlayerCommon& _internal_player_common() const;
  public:
  const ::SCRAPIProtocol::PlayerCommon& player_common() const;
  ::SCRAPIProtocol::PlayerCommon* release_player_common();
  ::SCRAPIProtocol::PlayerCommon* mutable_player_common();
  void set_allocated_player_common(::SCRAPIProtocol::PlayerCommon* player_common);

  // optional .SCRAPIProtocol.Score score = 4;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::Score& _internal_score() const;
  public:
  const ::SCRAPIProtocol::Score& score() const;
  ::SCRAPIProtocol::Score* release_score();
  ::SCRAPIProtocol::Score* mutable_score();
  void set_allocated_score(::SCRAPIProtocol::Score* score);

  // optional .SCRAPIProtocol.ObservationRaw raw_data = 5;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 5;
  private:
  const ::SCRAPIProtocol::ObservationRaw& _internal_raw_data() const;
  public:
  const ::SCRAPIProtocol::ObservationRaw& raw_data() const;
  ::SCRAPIProtocol::ObservationRaw* release_raw_data();
  ::SCRAPIProtocol::ObservationRaw* mutable_raw_data();
  void set_allocated_raw_data(::SCRAPIProtocol::ObservationRaw* raw_data);

  // optional .SCRAPIProtocol.ObservationFeatureLayer feature_layer_data = 6;
  bool has_feature_layer_data() const;
  void clear_feature_layer_data();
  static const int kFeatureLayerDataFieldNumber = 6;
  private:
  const ::SCRAPIProtocol::ObservationFeatureLayer& _internal_feature_layer_data() const;
  public:
  const ::SCRAPIProtocol::ObservationFeatureLayer& feature_layer_data() const;
  ::SCRAPIProtocol::ObservationFeatureLayer* release_feature_layer_data();
  ::SCRAPIProtocol::ObservationFeatureLayer* mutable_feature_layer_data();
  void set_allocated_feature_layer_data(::SCRAPIProtocol::ObservationFeatureLayer* feature_layer_data);

  // optional .SCRAPIProtocol.ObservationRender render_data = 7;
  bool has_render_data() const;
  void clear_render_data();
  static const int kRenderDataFieldNumber = 7;
  private:
  const ::SCRAPIProtocol::ObservationRender& _internal_render_data() const;
  public:
  const ::SCRAPIProtocol::ObservationRender& render_data() const;
  ::SCRAPIProtocol::ObservationRender* release_render_data();
  ::SCRAPIProtocol::ObservationRender* mutable_render_data();
  void set_allocated_render_data(::SCRAPIProtocol::ObservationRender* render_data);

  // optional .SCRAPIProtocol.ObservationUI ui_data = 8;
  bool has_ui_data() const;
  void clear_ui_data();
  static const int kUiDataFieldNumber = 8;
  private:
  const ::SCRAPIProtocol::ObservationUI& _internal_ui_data() const;
  public:
  const ::SCRAPIProtocol::ObservationUI& ui_data() const;
  ::SCRAPIProtocol::ObservationUI* release_ui_data();
  ::SCRAPIProtocol::ObservationUI* mutable_ui_data();
  void set_allocated_ui_data(::SCRAPIProtocol::ObservationUI* ui_data);

  // optional uint32 game_loop = 9;
  bool has_game_loop() const;
  void clear_game_loop();
  static const int kGameLoopFieldNumber = 9;
  ::google::protobuf::uint32 game_loop() const;
  void set_game_loop(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.Observation)
 private:
  void set_has_game_loop();
  void clear_has_game_loop();
  void set_has_player_common();
  void clear_has_player_common();
  void set_has_score();
  void clear_has_score();
  void set_has_raw_data();
  void clear_has_raw_data();
  void set_has_feature_layer_data();
  void clear_has_feature_layer_data();
  void set_has_render_data();
  void clear_has_render_data();
  void set_has_ui_data();
  void clear_has_ui_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::AvailableAbility > abilities_;
  ::google::protobuf::RepeatedField<int> alerts_;
  ::SCRAPIProtocol::PlayerCommon* player_common_;
  ::SCRAPIProtocol::Score* score_;
  ::SCRAPIProtocol::ObservationRaw* raw_data_;
  ::SCRAPIProtocol::ObservationFeatureLayer* feature_layer_data_;
  ::SCRAPIProtocol::ObservationRender* render_data_;
  ::SCRAPIProtocol::ObservationUI* ui_data_;
  ::google::protobuf::uint32 game_loop_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(Action* other);
  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const final {
    return CreateMaybeMessage<Action>(NULL);
  }

  Action* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ActionRaw action_raw = 1;
  bool has_action_raw() const;
  void clear_action_raw();
  static const int kActionRawFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::ActionRaw& _internal_action_raw() const;
  public:
  const ::SCRAPIProtocol::ActionRaw& action_raw() const;
  ::SCRAPIProtocol::ActionRaw* release_action_raw();
  ::SCRAPIProtocol::ActionRaw* mutable_action_raw();
  void set_allocated_action_raw(::SCRAPIProtocol::ActionRaw* action_raw);

  // optional .SCRAPIProtocol.ActionSpatial action_feature_layer = 2;
  bool has_action_feature_layer() const;
  void clear_action_feature_layer();
  static const int kActionFeatureLayerFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ActionSpatial& _internal_action_feature_layer() const;
  public:
  const ::SCRAPIProtocol::ActionSpatial& action_feature_layer() const;
  ::SCRAPIProtocol::ActionSpatial* release_action_feature_layer();
  ::SCRAPIProtocol::ActionSpatial* mutable_action_feature_layer();
  void set_allocated_action_feature_layer(::SCRAPIProtocol::ActionSpatial* action_feature_layer);

  // optional .SCRAPIProtocol.ActionSpatial action_render = 3;
  bool has_action_render() const;
  void clear_action_render();
  static const int kActionRenderFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::ActionSpatial& _internal_action_render() const;
  public:
  const ::SCRAPIProtocol::ActionSpatial& action_render() const;
  ::SCRAPIProtocol::ActionSpatial* release_action_render();
  ::SCRAPIProtocol::ActionSpatial* mutable_action_render();
  void set_allocated_action_render(::SCRAPIProtocol::ActionSpatial* action_render);

  // optional .SCRAPIProtocol.ActionUI action_ui = 4;
  bool has_action_ui() const;
  void clear_action_ui();
  static const int kActionUiFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::ActionUI& _internal_action_ui() const;
  public:
  const ::SCRAPIProtocol::ActionUI& action_ui() const;
  ::SCRAPIProtocol::ActionUI* release_action_ui();
  ::SCRAPIProtocol::ActionUI* mutable_action_ui();
  void set_allocated_action_ui(::SCRAPIProtocol::ActionUI* action_ui);

  // optional .SCRAPIProtocol.ActionChat action_chat = 6;
  bool has_action_chat() const;
  void clear_action_chat();
  static const int kActionChatFieldNumber = 6;
  private:
  const ::SCRAPIProtocol::ActionChat& _internal_action_chat() const;
  public:
  const ::SCRAPIProtocol::ActionChat& action_chat() const;
  ::SCRAPIProtocol::ActionChat* release_action_chat();
  ::SCRAPIProtocol::ActionChat* mutable_action_chat();
  void set_allocated_action_chat(::SCRAPIProtocol::ActionChat* action_chat);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.Action)
 private:
  void set_has_action_raw();
  void clear_has_action_raw();
  void set_has_action_feature_layer();
  void clear_has_action_feature_layer();
  void set_has_action_render();
  void clear_has_action_render();
  void set_has_action_ui();
  void clear_has_action_ui();
  void set_has_action_chat();
  void clear_has_action_chat();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::ActionRaw* action_raw_;
  ::SCRAPIProtocol::ActionSpatial* action_feature_layer_;
  ::SCRAPIProtocol::ActionSpatial* action_render_;
  ::SCRAPIProtocol::ActionUI* action_ui_;
  ::SCRAPIProtocol::ActionChat* action_chat_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionChat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionChat) */ {
 public:
  ActionChat();
  virtual ~ActionChat();

  ActionChat(const ActionChat& from);

  inline ActionChat& operator=(const ActionChat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionChat(ActionChat&& from) noexcept
    : ActionChat() {
    *this = ::std::move(from);
  }

  inline ActionChat& operator=(ActionChat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionChat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionChat* internal_default_instance() {
    return reinterpret_cast<const ActionChat*>(
               &_ActionChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(ActionChat* other);
  friend void swap(ActionChat& a, ActionChat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionChat* New() const final {
    return CreateMaybeMessage<ActionChat>(NULL);
  }

  ActionChat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionChat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionChat& from);
  void MergeFrom(const ActionChat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionChat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionChat_Channel Channel;
  static const Channel Broadcast =
    ActionChat_Channel_Broadcast;
  static const Channel Team =
    ActionChat_Channel_Team;
  static inline bool Channel_IsValid(int value) {
    return ActionChat_Channel_IsValid(value);
  }
  static const Channel Channel_MIN =
    ActionChat_Channel_Channel_MIN;
  static const Channel Channel_MAX =
    ActionChat_Channel_Channel_MAX;
  static const int Channel_ARRAYSIZE =
    ActionChat_Channel_Channel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Channel_descriptor() {
    return ActionChat_Channel_descriptor();
  }
  static inline const ::std::string& Channel_Name(Channel value) {
    return ActionChat_Channel_Name(value);
  }
  static inline bool Channel_Parse(const ::std::string& name,
      Channel* value) {
    return ActionChat_Channel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .SCRAPIProtocol.ActionChat.Channel channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::SCRAPIProtocol::ActionChat_Channel channel() const;
  void set_channel(::SCRAPIProtocol::ActionChat_Channel value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionChat)
 private:
  void set_has_channel();
  void clear_has_channel();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int channel_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionError) */ {
 public:
  ActionError();
  virtual ~ActionError();

  ActionError(const ActionError& from);

  inline ActionError& operator=(const ActionError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionError(ActionError&& from) noexcept
    : ActionError() {
    *this = ::std::move(from);
  }

  inline ActionError& operator=(ActionError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionError* internal_default_instance() {
    return reinterpret_cast<const ActionError*>(
               &_ActionError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(ActionError* other);
  friend void swap(ActionError& a, ActionError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionError* New() const final {
    return CreateMaybeMessage<ActionError>(NULL);
  }

  ActionError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionError& from);
  void MergeFrom(const ActionError& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 unit_tag = 1;
  bool has_unit_tag() const;
  void clear_unit_tag();
  static const int kUnitTagFieldNumber = 1;
  ::google::protobuf::uint64 unit_tag() const;
  void set_unit_tag(::google::protobuf::uint64 value);

  // optional uint64 ability_id = 2;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 2;
  ::google::protobuf::uint64 ability_id() const;
  void set_ability_id(::google::protobuf::uint64 value);

  // optional .SCRAPIProtocol.ActionResult result = 3;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  ::SCRAPIProtocol::ActionResult result() const;
  void set_result(::SCRAPIProtocol::ActionResult value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionError)
 private:
  void set_has_unit_tag();
  void clear_has_unit_tag();
  void set_has_ability_id();
  void clear_has_ability_id();
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 unit_tag_;
  ::google::protobuf::uint64 ability_id_;
  int result_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObserverAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ObserverAction) */ {
 public:
  ObserverAction();
  virtual ~ObserverAction();

  ObserverAction(const ObserverAction& from);

  inline ObserverAction& operator=(const ObserverAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObserverAction(ObserverAction&& from) noexcept
    : ObserverAction() {
    *this = ::std::move(from);
  }

  inline ObserverAction& operator=(ObserverAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObserverAction& default_instance();

  enum ActionCase {
    kPlayerPerspective = 1,
    kCameraMove = 2,
    kCameraFollowPlayer = 3,
    kCameraFollowUnits = 4,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObserverAction* internal_default_instance() {
    return reinterpret_cast<const ObserverAction*>(
               &_ObserverAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(ObserverAction* other);
  friend void swap(ObserverAction& a, ObserverAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObserverAction* New() const final {
    return CreateMaybeMessage<ObserverAction>(NULL);
  }

  ObserverAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObserverAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObserverAction& from);
  void MergeFrom(const ObserverAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObserverAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ActionObserverPlayerPerspective player_perspective = 1;
  bool has_player_perspective() const;
  void clear_player_perspective();
  static const int kPlayerPerspectiveFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::ActionObserverPlayerPerspective& _internal_player_perspective() const;
  public:
  const ::SCRAPIProtocol::ActionObserverPlayerPerspective& player_perspective() const;
  ::SCRAPIProtocol::ActionObserverPlayerPerspective* release_player_perspective();
  ::SCRAPIProtocol::ActionObserverPlayerPerspective* mutable_player_perspective();
  void set_allocated_player_perspective(::SCRAPIProtocol::ActionObserverPlayerPerspective* player_perspective);

  // optional .SCRAPIProtocol.ActionObserverCameraMove camera_move = 2;
  bool has_camera_move() const;
  void clear_camera_move();
  static const int kCameraMoveFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ActionObserverCameraMove& _internal_camera_move() const;
  public:
  const ::SCRAPIProtocol::ActionObserverCameraMove& camera_move() const;
  ::SCRAPIProtocol::ActionObserverCameraMove* release_camera_move();
  ::SCRAPIProtocol::ActionObserverCameraMove* mutable_camera_move();
  void set_allocated_camera_move(::SCRAPIProtocol::ActionObserverCameraMove* camera_move);

  // optional .SCRAPIProtocol.ActionObserverCameraFollowPlayer camera_follow_player = 3;
  bool has_camera_follow_player() const;
  void clear_camera_follow_player();
  static const int kCameraFollowPlayerFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::ActionObserverCameraFollowPlayer& _internal_camera_follow_player() const;
  public:
  const ::SCRAPIProtocol::ActionObserverCameraFollowPlayer& camera_follow_player() const;
  ::SCRAPIProtocol::ActionObserverCameraFollowPlayer* release_camera_follow_player();
  ::SCRAPIProtocol::ActionObserverCameraFollowPlayer* mutable_camera_follow_player();
  void set_allocated_camera_follow_player(::SCRAPIProtocol::ActionObserverCameraFollowPlayer* camera_follow_player);

  // optional .SCRAPIProtocol.ActionObserverCameraFollowUnits camera_follow_units = 4;
  bool has_camera_follow_units() const;
  void clear_camera_follow_units();
  static const int kCameraFollowUnitsFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::ActionObserverCameraFollowUnits& _internal_camera_follow_units() const;
  public:
  const ::SCRAPIProtocol::ActionObserverCameraFollowUnits& camera_follow_units() const;
  ::SCRAPIProtocol::ActionObserverCameraFollowUnits* release_camera_follow_units();
  ::SCRAPIProtocol::ActionObserverCameraFollowUnits* mutable_camera_follow_units();
  void set_allocated_camera_follow_units(::SCRAPIProtocol::ActionObserverCameraFollowUnits* camera_follow_units);

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ObserverAction)
 private:
  void set_has_player_perspective();
  void set_has_camera_move();
  void set_has_camera_follow_player();
  void set_has_camera_follow_units();

  inline bool has_action() const;
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ActionUnion {
    ActionUnion() {}
    ::SCRAPIProtocol::ActionObserverPlayerPerspective* player_perspective_;
    ::SCRAPIProtocol::ActionObserverCameraMove* camera_move_;
    ::SCRAPIProtocol::ActionObserverCameraFollowPlayer* camera_follow_player_;
    ::SCRAPIProtocol::ActionObserverCameraFollowUnits* camera_follow_units_;
  } action_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionObserverPlayerPerspective : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionObserverPlayerPerspective) */ {
 public:
  ActionObserverPlayerPerspective();
  virtual ~ActionObserverPlayerPerspective();

  ActionObserverPlayerPerspective(const ActionObserverPlayerPerspective& from);

  inline ActionObserverPlayerPerspective& operator=(const ActionObserverPlayerPerspective& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionObserverPlayerPerspective(ActionObserverPlayerPerspective&& from) noexcept
    : ActionObserverPlayerPerspective() {
    *this = ::std::move(from);
  }

  inline ActionObserverPlayerPerspective& operator=(ActionObserverPlayerPerspective&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionObserverPlayerPerspective& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverPlayerPerspective* internal_default_instance() {
    return reinterpret_cast<const ActionObserverPlayerPerspective*>(
               &_ActionObserverPlayerPerspective_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(ActionObserverPlayerPerspective* other);
  friend void swap(ActionObserverPlayerPerspective& a, ActionObserverPlayerPerspective& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverPlayerPerspective* New() const final {
    return CreateMaybeMessage<ActionObserverPlayerPerspective>(NULL);
  }

  ActionObserverPlayerPerspective* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverPlayerPerspective>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionObserverPlayerPerspective& from);
  void MergeFrom(const ActionObserverPlayerPerspective& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverPlayerPerspective* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionObserverPlayerPerspective)
 private:
  void set_has_player_id();
  void clear_has_player_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 player_id_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionObserverCameraMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionObserverCameraMove) */ {
 public:
  ActionObserverCameraMove();
  virtual ~ActionObserverCameraMove();

  ActionObserverCameraMove(const ActionObserverCameraMove& from);

  inline ActionObserverCameraMove& operator=(const ActionObserverCameraMove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionObserverCameraMove(ActionObserverCameraMove&& from) noexcept
    : ActionObserverCameraMove() {
    *this = ::std::move(from);
  }

  inline ActionObserverCameraMove& operator=(ActionObserverCameraMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionObserverCameraMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverCameraMove* internal_default_instance() {
    return reinterpret_cast<const ActionObserverCameraMove*>(
               &_ActionObserverCameraMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(ActionObserverCameraMove* other);
  friend void swap(ActionObserverCameraMove& a, ActionObserverCameraMove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverCameraMove* New() const final {
    return CreateMaybeMessage<ActionObserverCameraMove>(NULL);
  }

  ActionObserverCameraMove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverCameraMove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionObserverCameraMove& from);
  void MergeFrom(const ActionObserverCameraMove& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverCameraMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.Point2D world_pos = 1;
  bool has_world_pos() const;
  void clear_world_pos();
  static const int kWorldPosFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::Point2D& _internal_world_pos() const;
  public:
  const ::SCRAPIProtocol::Point2D& world_pos() const;
  ::SCRAPIProtocol::Point2D* release_world_pos();
  ::SCRAPIProtocol::Point2D* mutable_world_pos();
  void set_allocated_world_pos(::SCRAPIProtocol::Point2D* world_pos);

  // optional float distance = 2;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionObserverCameraMove)
 private:
  void set_has_world_pos();
  void clear_has_world_pos();
  void set_has_distance();
  void clear_has_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::Point2D* world_pos_;
  float distance_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionObserverCameraFollowPlayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionObserverCameraFollowPlayer) */ {
 public:
  ActionObserverCameraFollowPlayer();
  virtual ~ActionObserverCameraFollowPlayer();

  ActionObserverCameraFollowPlayer(const ActionObserverCameraFollowPlayer& from);

  inline ActionObserverCameraFollowPlayer& operator=(const ActionObserverCameraFollowPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionObserverCameraFollowPlayer(ActionObserverCameraFollowPlayer&& from) noexcept
    : ActionObserverCameraFollowPlayer() {
    *this = ::std::move(from);
  }

  inline ActionObserverCameraFollowPlayer& operator=(ActionObserverCameraFollowPlayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionObserverCameraFollowPlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverCameraFollowPlayer* internal_default_instance() {
    return reinterpret_cast<const ActionObserverCameraFollowPlayer*>(
               &_ActionObserverCameraFollowPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(ActionObserverCameraFollowPlayer* other);
  friend void swap(ActionObserverCameraFollowPlayer& a, ActionObserverCameraFollowPlayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverCameraFollowPlayer* New() const final {
    return CreateMaybeMessage<ActionObserverCameraFollowPlayer>(NULL);
  }

  ActionObserverCameraFollowPlayer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverCameraFollowPlayer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionObserverCameraFollowPlayer& from);
  void MergeFrom(const ActionObserverCameraFollowPlayer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverCameraFollowPlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionObserverCameraFollowPlayer)
 private:
  void set_has_player_id();
  void clear_has_player_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 player_id_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionObserverCameraFollowUnits : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionObserverCameraFollowUnits) */ {
 public:
  ActionObserverCameraFollowUnits();
  virtual ~ActionObserverCameraFollowUnits();

  ActionObserverCameraFollowUnits(const ActionObserverCameraFollowUnits& from);

  inline ActionObserverCameraFollowUnits& operator=(const ActionObserverCameraFollowUnits& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionObserverCameraFollowUnits(ActionObserverCameraFollowUnits&& from) noexcept
    : ActionObserverCameraFollowUnits() {
    *this = ::std::move(from);
  }

  inline ActionObserverCameraFollowUnits& operator=(ActionObserverCameraFollowUnits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionObserverCameraFollowUnits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverCameraFollowUnits* internal_default_instance() {
    return reinterpret_cast<const ActionObserverCameraFollowUnits*>(
               &_ActionObserverCameraFollowUnits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(ActionObserverCameraFollowUnits* other);
  friend void swap(ActionObserverCameraFollowUnits& a, ActionObserverCameraFollowUnits& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverCameraFollowUnits* New() const final {
    return CreateMaybeMessage<ActionObserverCameraFollowUnits>(NULL);
  }

  ActionObserverCameraFollowUnits* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverCameraFollowUnits>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionObserverCameraFollowUnits& from);
  void MergeFrom(const ActionObserverCameraFollowUnits& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverCameraFollowUnits* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 unit_tags = 1;
  int unit_tags_size() const;
  void clear_unit_tags();
  static const int kUnitTagsFieldNumber = 1;
  ::google::protobuf::uint64 unit_tags(int index) const;
  void set_unit_tags(int index, ::google::protobuf::uint64 value);
  void add_unit_tags(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      unit_tags() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_unit_tags();

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionObserverCameraFollowUnits)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > unit_tags_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.PlayerResult) */ {
 public:
  PlayerResult();
  virtual ~PlayerResult();

  PlayerResult(const PlayerResult& from);

  inline PlayerResult& operator=(const PlayerResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerResult(PlayerResult&& from) noexcept
    : PlayerResult() {
    *this = ::std::move(from);
  }

  inline PlayerResult& operator=(PlayerResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerResult* internal_default_instance() {
    return reinterpret_cast<const PlayerResult*>(
               &_PlayerResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(PlayerResult* other);
  friend void swap(PlayerResult& a, PlayerResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerResult* New() const final {
    return CreateMaybeMessage<PlayerResult>(NULL);
  }

  PlayerResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerResult& from);
  void MergeFrom(const PlayerResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional .SCRAPIProtocol.Result result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::SCRAPIProtocol::Result result() const;
  void set_result(::SCRAPIProtocol::Result value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.PlayerResult)
 private:
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 player_id_;
  int result_;
  friend struct ::protobuf_scrapi_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// optional .SCRAPIProtocol.RequestCreateGame create_game = 1;
inline bool Request::has_create_game() const {
  return request_case() == kCreateGame;
}
inline void Request::set_has_create_game() {
  _oneof_case_[0] = kCreateGame;
}
inline void Request::clear_create_game() {
  if (has_create_game()) {
    delete request_.create_game_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestCreateGame& Request::_internal_create_game() const {
  return *request_.create_game_;
}
inline ::SCRAPIProtocol::RequestCreateGame* Request::release_create_game() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.create_game)
  if (has_create_game()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestCreateGame* temp = request_.create_game_;
    request_.create_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestCreateGame& Request::create_game() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.create_game)
  return has_create_game()
      ? *request_.create_game_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestCreateGame*>(&::SCRAPIProtocol::_RequestCreateGame_default_instance_);
}
inline ::SCRAPIProtocol::RequestCreateGame* Request::mutable_create_game() {
  if (!has_create_game()) {
    clear_request();
    set_has_create_game();
    request_.create_game_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestCreateGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.create_game)
  return request_.create_game_;
}

// optional .SCRAPIProtocol.RequestJoinGame join_game = 2;
inline bool Request::has_join_game() const {
  return request_case() == kJoinGame;
}
inline void Request::set_has_join_game() {
  _oneof_case_[0] = kJoinGame;
}
inline void Request::clear_join_game() {
  if (has_join_game()) {
    delete request_.join_game_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestJoinGame& Request::_internal_join_game() const {
  return *request_.join_game_;
}
inline ::SCRAPIProtocol::RequestJoinGame* Request::release_join_game() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.join_game)
  if (has_join_game()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestJoinGame* temp = request_.join_game_;
    request_.join_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestJoinGame& Request::join_game() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.join_game)
  return has_join_game()
      ? *request_.join_game_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestJoinGame*>(&::SCRAPIProtocol::_RequestJoinGame_default_instance_);
}
inline ::SCRAPIProtocol::RequestJoinGame* Request::mutable_join_game() {
  if (!has_join_game()) {
    clear_request();
    set_has_join_game();
    request_.join_game_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestJoinGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.join_game)
  return request_.join_game_;
}

// optional .SCRAPIProtocol.RequestRestartGame restart_game = 3;
inline bool Request::has_restart_game() const {
  return request_case() == kRestartGame;
}
inline void Request::set_has_restart_game() {
  _oneof_case_[0] = kRestartGame;
}
inline void Request::clear_restart_game() {
  if (has_restart_game()) {
    delete request_.restart_game_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestRestartGame& Request::_internal_restart_game() const {
  return *request_.restart_game_;
}
inline ::SCRAPIProtocol::RequestRestartGame* Request::release_restart_game() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.restart_game)
  if (has_restart_game()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestRestartGame* temp = request_.restart_game_;
    request_.restart_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestRestartGame& Request::restart_game() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.restart_game)
  return has_restart_game()
      ? *request_.restart_game_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestRestartGame*>(&::SCRAPIProtocol::_RequestRestartGame_default_instance_);
}
inline ::SCRAPIProtocol::RequestRestartGame* Request::mutable_restart_game() {
  if (!has_restart_game()) {
    clear_request();
    set_has_restart_game();
    request_.restart_game_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestRestartGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.restart_game)
  return request_.restart_game_;
}

// optional .SCRAPIProtocol.RequestStartReplay start_replay = 4;
inline bool Request::has_start_replay() const {
  return request_case() == kStartReplay;
}
inline void Request::set_has_start_replay() {
  _oneof_case_[0] = kStartReplay;
}
inline void Request::clear_start_replay() {
  if (has_start_replay()) {
    delete request_.start_replay_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestStartReplay& Request::_internal_start_replay() const {
  return *request_.start_replay_;
}
inline ::SCRAPIProtocol::RequestStartReplay* Request::release_start_replay() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.start_replay)
  if (has_start_replay()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestStartReplay* temp = request_.start_replay_;
    request_.start_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestStartReplay& Request::start_replay() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.start_replay)
  return has_start_replay()
      ? *request_.start_replay_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestStartReplay*>(&::SCRAPIProtocol::_RequestStartReplay_default_instance_);
}
inline ::SCRAPIProtocol::RequestStartReplay* Request::mutable_start_replay() {
  if (!has_start_replay()) {
    clear_request();
    set_has_start_replay();
    request_.start_replay_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestStartReplay >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.start_replay)
  return request_.start_replay_;
}

// optional .SCRAPIProtocol.RequestLeaveGame leave_game = 5;
inline bool Request::has_leave_game() const {
  return request_case() == kLeaveGame;
}
inline void Request::set_has_leave_game() {
  _oneof_case_[0] = kLeaveGame;
}
inline void Request::clear_leave_game() {
  if (has_leave_game()) {
    delete request_.leave_game_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestLeaveGame& Request::_internal_leave_game() const {
  return *request_.leave_game_;
}
inline ::SCRAPIProtocol::RequestLeaveGame* Request::release_leave_game() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.leave_game)
  if (has_leave_game()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestLeaveGame* temp = request_.leave_game_;
    request_.leave_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestLeaveGame& Request::leave_game() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.leave_game)
  return has_leave_game()
      ? *request_.leave_game_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestLeaveGame*>(&::SCRAPIProtocol::_RequestLeaveGame_default_instance_);
}
inline ::SCRAPIProtocol::RequestLeaveGame* Request::mutable_leave_game() {
  if (!has_leave_game()) {
    clear_request();
    set_has_leave_game();
    request_.leave_game_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestLeaveGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.leave_game)
  return request_.leave_game_;
}

// optional .SCRAPIProtocol.RequestQuickSave quick_save = 6;
inline bool Request::has_quick_save() const {
  return request_case() == kQuickSave;
}
inline void Request::set_has_quick_save() {
  _oneof_case_[0] = kQuickSave;
}
inline void Request::clear_quick_save() {
  if (has_quick_save()) {
    delete request_.quick_save_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestQuickSave& Request::_internal_quick_save() const {
  return *request_.quick_save_;
}
inline ::SCRAPIProtocol::RequestQuickSave* Request::release_quick_save() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.quick_save)
  if (has_quick_save()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestQuickSave* temp = request_.quick_save_;
    request_.quick_save_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestQuickSave& Request::quick_save() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.quick_save)
  return has_quick_save()
      ? *request_.quick_save_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestQuickSave*>(&::SCRAPIProtocol::_RequestQuickSave_default_instance_);
}
inline ::SCRAPIProtocol::RequestQuickSave* Request::mutable_quick_save() {
  if (!has_quick_save()) {
    clear_request();
    set_has_quick_save();
    request_.quick_save_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestQuickSave >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.quick_save)
  return request_.quick_save_;
}

// optional .SCRAPIProtocol.RequestQuickLoad quick_load = 7;
inline bool Request::has_quick_load() const {
  return request_case() == kQuickLoad;
}
inline void Request::set_has_quick_load() {
  _oneof_case_[0] = kQuickLoad;
}
inline void Request::clear_quick_load() {
  if (has_quick_load()) {
    delete request_.quick_load_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestQuickLoad& Request::_internal_quick_load() const {
  return *request_.quick_load_;
}
inline ::SCRAPIProtocol::RequestQuickLoad* Request::release_quick_load() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.quick_load)
  if (has_quick_load()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestQuickLoad* temp = request_.quick_load_;
    request_.quick_load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestQuickLoad& Request::quick_load() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.quick_load)
  return has_quick_load()
      ? *request_.quick_load_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestQuickLoad*>(&::SCRAPIProtocol::_RequestQuickLoad_default_instance_);
}
inline ::SCRAPIProtocol::RequestQuickLoad* Request::mutable_quick_load() {
  if (!has_quick_load()) {
    clear_request();
    set_has_quick_load();
    request_.quick_load_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestQuickLoad >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.quick_load)
  return request_.quick_load_;
}

// optional .SCRAPIProtocol.RequestQuit quit = 8;
inline bool Request::has_quit() const {
  return request_case() == kQuit;
}
inline void Request::set_has_quit() {
  _oneof_case_[0] = kQuit;
}
inline void Request::clear_quit() {
  if (has_quit()) {
    delete request_.quit_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestQuit& Request::_internal_quit() const {
  return *request_.quit_;
}
inline ::SCRAPIProtocol::RequestQuit* Request::release_quit() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.quit)
  if (has_quit()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestQuit* temp = request_.quit_;
    request_.quit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestQuit& Request::quit() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.quit)
  return has_quit()
      ? *request_.quit_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestQuit*>(&::SCRAPIProtocol::_RequestQuit_default_instance_);
}
inline ::SCRAPIProtocol::RequestQuit* Request::mutable_quit() {
  if (!has_quit()) {
    clear_request();
    set_has_quit();
    request_.quit_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestQuit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.quit)
  return request_.quit_;
}

// optional .SCRAPIProtocol.RequestGameInfo game_info = 9;
inline bool Request::has_game_info() const {
  return request_case() == kGameInfo;
}
inline void Request::set_has_game_info() {
  _oneof_case_[0] = kGameInfo;
}
inline void Request::clear_game_info() {
  if (has_game_info()) {
    delete request_.game_info_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestGameInfo& Request::_internal_game_info() const {
  return *request_.game_info_;
}
inline ::SCRAPIProtocol::RequestGameInfo* Request::release_game_info() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.game_info)
  if (has_game_info()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestGameInfo* temp = request_.game_info_;
    request_.game_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestGameInfo& Request::game_info() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.game_info)
  return has_game_info()
      ? *request_.game_info_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestGameInfo*>(&::SCRAPIProtocol::_RequestGameInfo_default_instance_);
}
inline ::SCRAPIProtocol::RequestGameInfo* Request::mutable_game_info() {
  if (!has_game_info()) {
    clear_request();
    set_has_game_info();
    request_.game_info_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestGameInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.game_info)
  return request_.game_info_;
}

// optional .SCRAPIProtocol.RequestObservation observation = 10;
inline bool Request::has_observation() const {
  return request_case() == kObservation;
}
inline void Request::set_has_observation() {
  _oneof_case_[0] = kObservation;
}
inline void Request::clear_observation() {
  if (has_observation()) {
    delete request_.observation_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestObservation& Request::_internal_observation() const {
  return *request_.observation_;
}
inline ::SCRAPIProtocol::RequestObservation* Request::release_observation() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.observation)
  if (has_observation()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestObservation* temp = request_.observation_;
    request_.observation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestObservation& Request::observation() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.observation)
  return has_observation()
      ? *request_.observation_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestObservation*>(&::SCRAPIProtocol::_RequestObservation_default_instance_);
}
inline ::SCRAPIProtocol::RequestObservation* Request::mutable_observation() {
  if (!has_observation()) {
    clear_request();
    set_has_observation();
    request_.observation_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestObservation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.observation)
  return request_.observation_;
}

// optional .SCRAPIProtocol.RequestAction action = 11;
inline bool Request::has_action() const {
  return request_case() == kAction;
}
inline void Request::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void Request::clear_action() {
  if (has_action()) {
    delete request_.action_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestAction& Request::_internal_action() const {
  return *request_.action_;
}
inline ::SCRAPIProtocol::RequestAction* Request::release_action() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.action)
  if (has_action()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestAction* temp = request_.action_;
    request_.action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestAction& Request::action() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.action)
  return has_action()
      ? *request_.action_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestAction*>(&::SCRAPIProtocol::_RequestAction_default_instance_);
}
inline ::SCRAPIProtocol::RequestAction* Request::mutable_action() {
  if (!has_action()) {
    clear_request();
    set_has_action();
    request_.action_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestAction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.action)
  return request_.action_;
}

// optional .SCRAPIProtocol.RequestObserverAction obs_action = 21;
inline bool Request::has_obs_action() const {
  return request_case() == kObsAction;
}
inline void Request::set_has_obs_action() {
  _oneof_case_[0] = kObsAction;
}
inline void Request::clear_obs_action() {
  if (has_obs_action()) {
    delete request_.obs_action_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestObserverAction& Request::_internal_obs_action() const {
  return *request_.obs_action_;
}
inline ::SCRAPIProtocol::RequestObserverAction* Request::release_obs_action() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.obs_action)
  if (has_obs_action()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestObserverAction* temp = request_.obs_action_;
    request_.obs_action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestObserverAction& Request::obs_action() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.obs_action)
  return has_obs_action()
      ? *request_.obs_action_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestObserverAction*>(&::SCRAPIProtocol::_RequestObserverAction_default_instance_);
}
inline ::SCRAPIProtocol::RequestObserverAction* Request::mutable_obs_action() {
  if (!has_obs_action()) {
    clear_request();
    set_has_obs_action();
    request_.obs_action_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestObserverAction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.obs_action)
  return request_.obs_action_;
}

// optional .SCRAPIProtocol.RequestStep step = 12;
inline bool Request::has_step() const {
  return request_case() == kStep;
}
inline void Request::set_has_step() {
  _oneof_case_[0] = kStep;
}
inline void Request::clear_step() {
  if (has_step()) {
    delete request_.step_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestStep& Request::_internal_step() const {
  return *request_.step_;
}
inline ::SCRAPIProtocol::RequestStep* Request::release_step() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.step)
  if (has_step()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestStep* temp = request_.step_;
    request_.step_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestStep& Request::step() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.step)
  return has_step()
      ? *request_.step_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestStep*>(&::SCRAPIProtocol::_RequestStep_default_instance_);
}
inline ::SCRAPIProtocol::RequestStep* Request::mutable_step() {
  if (!has_step()) {
    clear_request();
    set_has_step();
    request_.step_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestStep >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.step)
  return request_.step_;
}

// optional .SCRAPIProtocol.RequestData data = 13;
inline bool Request::has_data() const {
  return request_case() == kData;
}
inline void Request::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Request::clear_data() {
  if (has_data()) {
    delete request_.data_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestData& Request::_internal_data() const {
  return *request_.data_;
}
inline ::SCRAPIProtocol::RequestData* Request::release_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.data)
  if (has_data()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestData* temp = request_.data_;
    request_.data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestData& Request::data() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.data)
  return has_data()
      ? *request_.data_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestData*>(&::SCRAPIProtocol::_RequestData_default_instance_);
}
inline ::SCRAPIProtocol::RequestData* Request::mutable_data() {
  if (!has_data()) {
    clear_request();
    set_has_data();
    request_.data_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.data)
  return request_.data_;
}

// optional .SCRAPIProtocol.RequestQuery query = 14;
inline bool Request::has_query() const {
  return request_case() == kQuery;
}
inline void Request::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline const ::SCRAPIProtocol::RequestQuery& Request::_internal_query() const {
  return *request_.query_;
}
inline ::SCRAPIProtocol::RequestQuery* Request::release_query() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.query)
  if (has_query()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestQuery* temp = request_.query_;
    request_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestQuery& Request::query() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.query)
  return has_query()
      ? *request_.query_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestQuery*>(&::SCRAPIProtocol::_RequestQuery_default_instance_);
}
inline ::SCRAPIProtocol::RequestQuery* Request::mutable_query() {
  if (!has_query()) {
    clear_request();
    set_has_query();
    request_.query_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestQuery >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.query)
  return request_.query_;
}

// optional .SCRAPIProtocol.RequestSaveReplay save_replay = 15;
inline bool Request::has_save_replay() const {
  return request_case() == kSaveReplay;
}
inline void Request::set_has_save_replay() {
  _oneof_case_[0] = kSaveReplay;
}
inline void Request::clear_save_replay() {
  if (has_save_replay()) {
    delete request_.save_replay_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestSaveReplay& Request::_internal_save_replay() const {
  return *request_.save_replay_;
}
inline ::SCRAPIProtocol::RequestSaveReplay* Request::release_save_replay() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.save_replay)
  if (has_save_replay()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestSaveReplay* temp = request_.save_replay_;
    request_.save_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestSaveReplay& Request::save_replay() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.save_replay)
  return has_save_replay()
      ? *request_.save_replay_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestSaveReplay*>(&::SCRAPIProtocol::_RequestSaveReplay_default_instance_);
}
inline ::SCRAPIProtocol::RequestSaveReplay* Request::mutable_save_replay() {
  if (!has_save_replay()) {
    clear_request();
    set_has_save_replay();
    request_.save_replay_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestSaveReplay >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.save_replay)
  return request_.save_replay_;
}

// optional .SCRAPIProtocol.RequestReplayInfo replay_info = 16;
inline bool Request::has_replay_info() const {
  return request_case() == kReplayInfo;
}
inline void Request::set_has_replay_info() {
  _oneof_case_[0] = kReplayInfo;
}
inline void Request::clear_replay_info() {
  if (has_replay_info()) {
    delete request_.replay_info_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestReplayInfo& Request::_internal_replay_info() const {
  return *request_.replay_info_;
}
inline ::SCRAPIProtocol::RequestReplayInfo* Request::release_replay_info() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.replay_info)
  if (has_replay_info()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestReplayInfo* temp = request_.replay_info_;
    request_.replay_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestReplayInfo& Request::replay_info() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.replay_info)
  return has_replay_info()
      ? *request_.replay_info_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestReplayInfo*>(&::SCRAPIProtocol::_RequestReplayInfo_default_instance_);
}
inline ::SCRAPIProtocol::RequestReplayInfo* Request::mutable_replay_info() {
  if (!has_replay_info()) {
    clear_request();
    set_has_replay_info();
    request_.replay_info_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestReplayInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.replay_info)
  return request_.replay_info_;
}

// optional .SCRAPIProtocol.RequestAvailableMaps available_maps = 17;
inline bool Request::has_available_maps() const {
  return request_case() == kAvailableMaps;
}
inline void Request::set_has_available_maps() {
  _oneof_case_[0] = kAvailableMaps;
}
inline void Request::clear_available_maps() {
  if (has_available_maps()) {
    delete request_.available_maps_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestAvailableMaps& Request::_internal_available_maps() const {
  return *request_.available_maps_;
}
inline ::SCRAPIProtocol::RequestAvailableMaps* Request::release_available_maps() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.available_maps)
  if (has_available_maps()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestAvailableMaps* temp = request_.available_maps_;
    request_.available_maps_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestAvailableMaps& Request::available_maps() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.available_maps)
  return has_available_maps()
      ? *request_.available_maps_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestAvailableMaps*>(&::SCRAPIProtocol::_RequestAvailableMaps_default_instance_);
}
inline ::SCRAPIProtocol::RequestAvailableMaps* Request::mutable_available_maps() {
  if (!has_available_maps()) {
    clear_request();
    set_has_available_maps();
    request_.available_maps_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestAvailableMaps >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.available_maps)
  return request_.available_maps_;
}

// optional .SCRAPIProtocol.RequestSaveMap save_map = 18;
inline bool Request::has_save_map() const {
  return request_case() == kSaveMap;
}
inline void Request::set_has_save_map() {
  _oneof_case_[0] = kSaveMap;
}
inline void Request::clear_save_map() {
  if (has_save_map()) {
    delete request_.save_map_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestSaveMap& Request::_internal_save_map() const {
  return *request_.save_map_;
}
inline ::SCRAPIProtocol::RequestSaveMap* Request::release_save_map() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.save_map)
  if (has_save_map()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestSaveMap* temp = request_.save_map_;
    request_.save_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestSaveMap& Request::save_map() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.save_map)
  return has_save_map()
      ? *request_.save_map_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestSaveMap*>(&::SCRAPIProtocol::_RequestSaveMap_default_instance_);
}
inline ::SCRAPIProtocol::RequestSaveMap* Request::mutable_save_map() {
  if (!has_save_map()) {
    clear_request();
    set_has_save_map();
    request_.save_map_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestSaveMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.save_map)
  return request_.save_map_;
}

// optional .SCRAPIProtocol.RequestPing ping = 19;
inline bool Request::has_ping() const {
  return request_case() == kPing;
}
inline void Request::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void Request::clear_ping() {
  if (has_ping()) {
    delete request_.ping_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestPing& Request::_internal_ping() const {
  return *request_.ping_;
}
inline ::SCRAPIProtocol::RequestPing* Request::release_ping() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.ping)
  if (has_ping()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestPing* temp = request_.ping_;
    request_.ping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestPing& Request::ping() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.ping)
  return has_ping()
      ? *request_.ping_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestPing*>(&::SCRAPIProtocol::_RequestPing_default_instance_);
}
inline ::SCRAPIProtocol::RequestPing* Request::mutable_ping() {
  if (!has_ping()) {
    clear_request();
    set_has_ping();
    request_.ping_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestPing >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.ping)
  return request_.ping_;
}

// optional .SCRAPIProtocol.RequestDebug debug = 20;
inline bool Request::has_debug() const {
  return request_case() == kDebug;
}
inline void Request::set_has_debug() {
  _oneof_case_[0] = kDebug;
}
inline void Request::clear_debug() {
  if (has_debug()) {
    delete request_.debug_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestDebug& Request::_internal_debug() const {
  return *request_.debug_;
}
inline ::SCRAPIProtocol::RequestDebug* Request::release_debug() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.debug)
  if (has_debug()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestDebug* temp = request_.debug_;
    request_.debug_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestDebug& Request::debug() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.debug)
  return has_debug()
      ? *request_.debug_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestDebug*>(&::SCRAPIProtocol::_RequestDebug_default_instance_);
}
inline ::SCRAPIProtocol::RequestDebug* Request::mutable_debug() {
  if (!has_debug()) {
    clear_request();
    set_has_debug();
    request_.debug_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestDebug >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.debug)
  return request_.debug_;
}

// optional .SCRAPIProtocol.RequestConnect connect = 22;
inline bool Request::has_connect() const {
  return request_case() == kConnect;
}
inline void Request::set_has_connect() {
  _oneof_case_[0] = kConnect;
}
inline void Request::clear_connect() {
  if (has_connect()) {
    delete request_.connect_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestConnect& Request::_internal_connect() const {
  return *request_.connect_;
}
inline ::SCRAPIProtocol::RequestConnect* Request::release_connect() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.connect)
  if (has_connect()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestConnect* temp = request_.connect_;
    request_.connect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestConnect& Request::connect() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.connect)
  return has_connect()
      ? *request_.connect_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestConnect*>(&::SCRAPIProtocol::_RequestConnect_default_instance_);
}
inline ::SCRAPIProtocol::RequestConnect* Request::mutable_connect() {
  if (!has_connect()) {
    clear_request();
    set_has_connect();
    request_.connect_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestConnect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.connect)
  return request_.connect_;
}

// optional .SCRAPIProtocol.RequestEndOfQueue end_of_queue = 23;
inline bool Request::has_end_of_queue() const {
  return request_case() == kEndOfQueue;
}
inline void Request::set_has_end_of_queue() {
  _oneof_case_[0] = kEndOfQueue;
}
inline void Request::clear_end_of_queue() {
  if (has_end_of_queue()) {
    delete request_.end_of_queue_;
    clear_has_request();
  }
}
inline const ::SCRAPIProtocol::RequestEndOfQueue& Request::_internal_end_of_queue() const {
  return *request_.end_of_queue_;
}
inline ::SCRAPIProtocol::RequestEndOfQueue* Request::release_end_of_queue() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Request.end_of_queue)
  if (has_end_of_queue()) {
    clear_has_request();
      ::SCRAPIProtocol::RequestEndOfQueue* temp = request_.end_of_queue_;
    request_.end_of_queue_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::RequestEndOfQueue& Request::end_of_queue() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Request.end_of_queue)
  return has_end_of_queue()
      ? *request_.end_of_queue_
      : *reinterpret_cast< ::SCRAPIProtocol::RequestEndOfQueue*>(&::SCRAPIProtocol::_RequestEndOfQueue_default_instance_);
}
inline ::SCRAPIProtocol::RequestEndOfQueue* Request::mutable_end_of_queue() {
  if (!has_end_of_queue()) {
    clear_request();
    set_has_end_of_queue();
    request_.end_of_queue_ = CreateMaybeMessage< ::SCRAPIProtocol::RequestEndOfQueue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Request.end_of_queue)
  return request_.end_of_queue_;
}

inline bool Request::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void Request::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline Request::RequestCase Request::request_case() const {
  return Request::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// optional .SCRAPIProtocol.ResponseCreateGame create_game = 1;
inline bool Response::has_create_game() const {
  return response_case() == kCreateGame;
}
inline void Response::set_has_create_game() {
  _oneof_case_[0] = kCreateGame;
}
inline void Response::clear_create_game() {
  if (has_create_game()) {
    delete response_.create_game_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseCreateGame& Response::_internal_create_game() const {
  return *response_.create_game_;
}
inline ::SCRAPIProtocol::ResponseCreateGame* Response::release_create_game() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.create_game)
  if (has_create_game()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseCreateGame* temp = response_.create_game_;
    response_.create_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseCreateGame& Response::create_game() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.create_game)
  return has_create_game()
      ? *response_.create_game_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseCreateGame*>(&::SCRAPIProtocol::_ResponseCreateGame_default_instance_);
}
inline ::SCRAPIProtocol::ResponseCreateGame* Response::mutable_create_game() {
  if (!has_create_game()) {
    clear_response();
    set_has_create_game();
    response_.create_game_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseCreateGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.create_game)
  return response_.create_game_;
}

// optional .SCRAPIProtocol.ResponseJoinGame join_game = 2;
inline bool Response::has_join_game() const {
  return response_case() == kJoinGame;
}
inline void Response::set_has_join_game() {
  _oneof_case_[0] = kJoinGame;
}
inline void Response::clear_join_game() {
  if (has_join_game()) {
    delete response_.join_game_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseJoinGame& Response::_internal_join_game() const {
  return *response_.join_game_;
}
inline ::SCRAPIProtocol::ResponseJoinGame* Response::release_join_game() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.join_game)
  if (has_join_game()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseJoinGame* temp = response_.join_game_;
    response_.join_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseJoinGame& Response::join_game() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.join_game)
  return has_join_game()
      ? *response_.join_game_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseJoinGame*>(&::SCRAPIProtocol::_ResponseJoinGame_default_instance_);
}
inline ::SCRAPIProtocol::ResponseJoinGame* Response::mutable_join_game() {
  if (!has_join_game()) {
    clear_response();
    set_has_join_game();
    response_.join_game_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseJoinGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.join_game)
  return response_.join_game_;
}

// optional .SCRAPIProtocol.ResponseRestartGame restart_game = 3;
inline bool Response::has_restart_game() const {
  return response_case() == kRestartGame;
}
inline void Response::set_has_restart_game() {
  _oneof_case_[0] = kRestartGame;
}
inline void Response::clear_restart_game() {
  if (has_restart_game()) {
    delete response_.restart_game_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseRestartGame& Response::_internal_restart_game() const {
  return *response_.restart_game_;
}
inline ::SCRAPIProtocol::ResponseRestartGame* Response::release_restart_game() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.restart_game)
  if (has_restart_game()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseRestartGame* temp = response_.restart_game_;
    response_.restart_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseRestartGame& Response::restart_game() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.restart_game)
  return has_restart_game()
      ? *response_.restart_game_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseRestartGame*>(&::SCRAPIProtocol::_ResponseRestartGame_default_instance_);
}
inline ::SCRAPIProtocol::ResponseRestartGame* Response::mutable_restart_game() {
  if (!has_restart_game()) {
    clear_response();
    set_has_restart_game();
    response_.restart_game_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseRestartGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.restart_game)
  return response_.restart_game_;
}

// optional .SCRAPIProtocol.ResponseStartReplay start_replay = 4;
inline bool Response::has_start_replay() const {
  return response_case() == kStartReplay;
}
inline void Response::set_has_start_replay() {
  _oneof_case_[0] = kStartReplay;
}
inline void Response::clear_start_replay() {
  if (has_start_replay()) {
    delete response_.start_replay_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseStartReplay& Response::_internal_start_replay() const {
  return *response_.start_replay_;
}
inline ::SCRAPIProtocol::ResponseStartReplay* Response::release_start_replay() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.start_replay)
  if (has_start_replay()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseStartReplay* temp = response_.start_replay_;
    response_.start_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseStartReplay& Response::start_replay() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.start_replay)
  return has_start_replay()
      ? *response_.start_replay_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseStartReplay*>(&::SCRAPIProtocol::_ResponseStartReplay_default_instance_);
}
inline ::SCRAPIProtocol::ResponseStartReplay* Response::mutable_start_replay() {
  if (!has_start_replay()) {
    clear_response();
    set_has_start_replay();
    response_.start_replay_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseStartReplay >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.start_replay)
  return response_.start_replay_;
}

// optional .SCRAPIProtocol.ResponseLeaveGame leave_game = 5;
inline bool Response::has_leave_game() const {
  return response_case() == kLeaveGame;
}
inline void Response::set_has_leave_game() {
  _oneof_case_[0] = kLeaveGame;
}
inline void Response::clear_leave_game() {
  if (has_leave_game()) {
    delete response_.leave_game_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseLeaveGame& Response::_internal_leave_game() const {
  return *response_.leave_game_;
}
inline ::SCRAPIProtocol::ResponseLeaveGame* Response::release_leave_game() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.leave_game)
  if (has_leave_game()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseLeaveGame* temp = response_.leave_game_;
    response_.leave_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseLeaveGame& Response::leave_game() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.leave_game)
  return has_leave_game()
      ? *response_.leave_game_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseLeaveGame*>(&::SCRAPIProtocol::_ResponseLeaveGame_default_instance_);
}
inline ::SCRAPIProtocol::ResponseLeaveGame* Response::mutable_leave_game() {
  if (!has_leave_game()) {
    clear_response();
    set_has_leave_game();
    response_.leave_game_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseLeaveGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.leave_game)
  return response_.leave_game_;
}

// optional .SCRAPIProtocol.ResponseQuickSave quick_save = 6;
inline bool Response::has_quick_save() const {
  return response_case() == kQuickSave;
}
inline void Response::set_has_quick_save() {
  _oneof_case_[0] = kQuickSave;
}
inline void Response::clear_quick_save() {
  if (has_quick_save()) {
    delete response_.quick_save_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseQuickSave& Response::_internal_quick_save() const {
  return *response_.quick_save_;
}
inline ::SCRAPIProtocol::ResponseQuickSave* Response::release_quick_save() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.quick_save)
  if (has_quick_save()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseQuickSave* temp = response_.quick_save_;
    response_.quick_save_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseQuickSave& Response::quick_save() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.quick_save)
  return has_quick_save()
      ? *response_.quick_save_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseQuickSave*>(&::SCRAPIProtocol::_ResponseQuickSave_default_instance_);
}
inline ::SCRAPIProtocol::ResponseQuickSave* Response::mutable_quick_save() {
  if (!has_quick_save()) {
    clear_response();
    set_has_quick_save();
    response_.quick_save_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseQuickSave >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.quick_save)
  return response_.quick_save_;
}

// optional .SCRAPIProtocol.ResponseQuickLoad quick_load = 7;
inline bool Response::has_quick_load() const {
  return response_case() == kQuickLoad;
}
inline void Response::set_has_quick_load() {
  _oneof_case_[0] = kQuickLoad;
}
inline void Response::clear_quick_load() {
  if (has_quick_load()) {
    delete response_.quick_load_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseQuickLoad& Response::_internal_quick_load() const {
  return *response_.quick_load_;
}
inline ::SCRAPIProtocol::ResponseQuickLoad* Response::release_quick_load() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.quick_load)
  if (has_quick_load()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseQuickLoad* temp = response_.quick_load_;
    response_.quick_load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseQuickLoad& Response::quick_load() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.quick_load)
  return has_quick_load()
      ? *response_.quick_load_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseQuickLoad*>(&::SCRAPIProtocol::_ResponseQuickLoad_default_instance_);
}
inline ::SCRAPIProtocol::ResponseQuickLoad* Response::mutable_quick_load() {
  if (!has_quick_load()) {
    clear_response();
    set_has_quick_load();
    response_.quick_load_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseQuickLoad >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.quick_load)
  return response_.quick_load_;
}

// optional .SCRAPIProtocol.ResponseQuit quit = 8;
inline bool Response::has_quit() const {
  return response_case() == kQuit;
}
inline void Response::set_has_quit() {
  _oneof_case_[0] = kQuit;
}
inline void Response::clear_quit() {
  if (has_quit()) {
    delete response_.quit_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseQuit& Response::_internal_quit() const {
  return *response_.quit_;
}
inline ::SCRAPIProtocol::ResponseQuit* Response::release_quit() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.quit)
  if (has_quit()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseQuit* temp = response_.quit_;
    response_.quit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseQuit& Response::quit() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.quit)
  return has_quit()
      ? *response_.quit_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseQuit*>(&::SCRAPIProtocol::_ResponseQuit_default_instance_);
}
inline ::SCRAPIProtocol::ResponseQuit* Response::mutable_quit() {
  if (!has_quit()) {
    clear_response();
    set_has_quit();
    response_.quit_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseQuit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.quit)
  return response_.quit_;
}

// optional .SCRAPIProtocol.ResponseGameInfo game_info = 9;
inline bool Response::has_game_info() const {
  return response_case() == kGameInfo;
}
inline void Response::set_has_game_info() {
  _oneof_case_[0] = kGameInfo;
}
inline void Response::clear_game_info() {
  if (has_game_info()) {
    delete response_.game_info_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseGameInfo& Response::_internal_game_info() const {
  return *response_.game_info_;
}
inline ::SCRAPIProtocol::ResponseGameInfo* Response::release_game_info() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.game_info)
  if (has_game_info()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseGameInfo* temp = response_.game_info_;
    response_.game_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseGameInfo& Response::game_info() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.game_info)
  return has_game_info()
      ? *response_.game_info_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseGameInfo*>(&::SCRAPIProtocol::_ResponseGameInfo_default_instance_);
}
inline ::SCRAPIProtocol::ResponseGameInfo* Response::mutable_game_info() {
  if (!has_game_info()) {
    clear_response();
    set_has_game_info();
    response_.game_info_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseGameInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.game_info)
  return response_.game_info_;
}

// optional .SCRAPIProtocol.ResponseObservation observation = 10;
inline bool Response::has_observation() const {
  return response_case() == kObservation;
}
inline void Response::set_has_observation() {
  _oneof_case_[0] = kObservation;
}
inline void Response::clear_observation() {
  if (has_observation()) {
    delete response_.observation_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseObservation& Response::_internal_observation() const {
  return *response_.observation_;
}
inline ::SCRAPIProtocol::ResponseObservation* Response::release_observation() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.observation)
  if (has_observation()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseObservation* temp = response_.observation_;
    response_.observation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseObservation& Response::observation() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.observation)
  return has_observation()
      ? *response_.observation_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseObservation*>(&::SCRAPIProtocol::_ResponseObservation_default_instance_);
}
inline ::SCRAPIProtocol::ResponseObservation* Response::mutable_observation() {
  if (!has_observation()) {
    clear_response();
    set_has_observation();
    response_.observation_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseObservation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.observation)
  return response_.observation_;
}

// optional .SCRAPIProtocol.ResponseAction action = 11;
inline bool Response::has_action() const {
  return response_case() == kAction;
}
inline void Response::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void Response::clear_action() {
  if (has_action()) {
    delete response_.action_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseAction& Response::_internal_action() const {
  return *response_.action_;
}
inline ::SCRAPIProtocol::ResponseAction* Response::release_action() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.action)
  if (has_action()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseAction* temp = response_.action_;
    response_.action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseAction& Response::action() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.action)
  return has_action()
      ? *response_.action_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseAction*>(&::SCRAPIProtocol::_ResponseAction_default_instance_);
}
inline ::SCRAPIProtocol::ResponseAction* Response::mutable_action() {
  if (!has_action()) {
    clear_response();
    set_has_action();
    response_.action_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseAction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.action)
  return response_.action_;
}

// optional .SCRAPIProtocol.ResponseObserverAction obs_action = 21;
inline bool Response::has_obs_action() const {
  return response_case() == kObsAction;
}
inline void Response::set_has_obs_action() {
  _oneof_case_[0] = kObsAction;
}
inline void Response::clear_obs_action() {
  if (has_obs_action()) {
    delete response_.obs_action_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseObserverAction& Response::_internal_obs_action() const {
  return *response_.obs_action_;
}
inline ::SCRAPIProtocol::ResponseObserverAction* Response::release_obs_action() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.obs_action)
  if (has_obs_action()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseObserverAction* temp = response_.obs_action_;
    response_.obs_action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseObserverAction& Response::obs_action() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.obs_action)
  return has_obs_action()
      ? *response_.obs_action_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseObserverAction*>(&::SCRAPIProtocol::_ResponseObserverAction_default_instance_);
}
inline ::SCRAPIProtocol::ResponseObserverAction* Response::mutable_obs_action() {
  if (!has_obs_action()) {
    clear_response();
    set_has_obs_action();
    response_.obs_action_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseObserverAction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.obs_action)
  return response_.obs_action_;
}

// optional .SCRAPIProtocol.ResponseStep step = 12;
inline bool Response::has_step() const {
  return response_case() == kStep;
}
inline void Response::set_has_step() {
  _oneof_case_[0] = kStep;
}
inline void Response::clear_step() {
  if (has_step()) {
    delete response_.step_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseStep& Response::_internal_step() const {
  return *response_.step_;
}
inline ::SCRAPIProtocol::ResponseStep* Response::release_step() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.step)
  if (has_step()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseStep* temp = response_.step_;
    response_.step_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseStep& Response::step() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.step)
  return has_step()
      ? *response_.step_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseStep*>(&::SCRAPIProtocol::_ResponseStep_default_instance_);
}
inline ::SCRAPIProtocol::ResponseStep* Response::mutable_step() {
  if (!has_step()) {
    clear_response();
    set_has_step();
    response_.step_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseStep >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.step)
  return response_.step_;
}

// optional .SCRAPIProtocol.ResponseData data = 13;
inline bool Response::has_data() const {
  return response_case() == kData;
}
inline void Response::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Response::clear_data() {
  if (has_data()) {
    delete response_.data_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseData& Response::_internal_data() const {
  return *response_.data_;
}
inline ::SCRAPIProtocol::ResponseData* Response::release_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.data)
  if (has_data()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseData* temp = response_.data_;
    response_.data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseData& Response::data() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.data)
  return has_data()
      ? *response_.data_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseData*>(&::SCRAPIProtocol::_ResponseData_default_instance_);
}
inline ::SCRAPIProtocol::ResponseData* Response::mutable_data() {
  if (!has_data()) {
    clear_response();
    set_has_data();
    response_.data_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.data)
  return response_.data_;
}

// optional .SCRAPIProtocol.ResponseQuery query = 14;
inline bool Response::has_query() const {
  return response_case() == kQuery;
}
inline void Response::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline const ::SCRAPIProtocol::ResponseQuery& Response::_internal_query() const {
  return *response_.query_;
}
inline ::SCRAPIProtocol::ResponseQuery* Response::release_query() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.query)
  if (has_query()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseQuery* temp = response_.query_;
    response_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseQuery& Response::query() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.query)
  return has_query()
      ? *response_.query_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseQuery*>(&::SCRAPIProtocol::_ResponseQuery_default_instance_);
}
inline ::SCRAPIProtocol::ResponseQuery* Response::mutable_query() {
  if (!has_query()) {
    clear_response();
    set_has_query();
    response_.query_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseQuery >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.query)
  return response_.query_;
}

// optional .SCRAPIProtocol.ResponseSaveReplay save_replay = 15;
inline bool Response::has_save_replay() const {
  return response_case() == kSaveReplay;
}
inline void Response::set_has_save_replay() {
  _oneof_case_[0] = kSaveReplay;
}
inline void Response::clear_save_replay() {
  if (has_save_replay()) {
    delete response_.save_replay_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseSaveReplay& Response::_internal_save_replay() const {
  return *response_.save_replay_;
}
inline ::SCRAPIProtocol::ResponseSaveReplay* Response::release_save_replay() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.save_replay)
  if (has_save_replay()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseSaveReplay* temp = response_.save_replay_;
    response_.save_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseSaveReplay& Response::save_replay() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.save_replay)
  return has_save_replay()
      ? *response_.save_replay_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseSaveReplay*>(&::SCRAPIProtocol::_ResponseSaveReplay_default_instance_);
}
inline ::SCRAPIProtocol::ResponseSaveReplay* Response::mutable_save_replay() {
  if (!has_save_replay()) {
    clear_response();
    set_has_save_replay();
    response_.save_replay_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseSaveReplay >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.save_replay)
  return response_.save_replay_;
}

// optional .SCRAPIProtocol.ResponseReplayInfo replay_info = 16;
inline bool Response::has_replay_info() const {
  return response_case() == kReplayInfo;
}
inline void Response::set_has_replay_info() {
  _oneof_case_[0] = kReplayInfo;
}
inline void Response::clear_replay_info() {
  if (has_replay_info()) {
    delete response_.replay_info_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseReplayInfo& Response::_internal_replay_info() const {
  return *response_.replay_info_;
}
inline ::SCRAPIProtocol::ResponseReplayInfo* Response::release_replay_info() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.replay_info)
  if (has_replay_info()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseReplayInfo* temp = response_.replay_info_;
    response_.replay_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseReplayInfo& Response::replay_info() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.replay_info)
  return has_replay_info()
      ? *response_.replay_info_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseReplayInfo*>(&::SCRAPIProtocol::_ResponseReplayInfo_default_instance_);
}
inline ::SCRAPIProtocol::ResponseReplayInfo* Response::mutable_replay_info() {
  if (!has_replay_info()) {
    clear_response();
    set_has_replay_info();
    response_.replay_info_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseReplayInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.replay_info)
  return response_.replay_info_;
}

// optional .SCRAPIProtocol.ResponseAvailableMaps available_maps = 17;
inline bool Response::has_available_maps() const {
  return response_case() == kAvailableMaps;
}
inline void Response::set_has_available_maps() {
  _oneof_case_[0] = kAvailableMaps;
}
inline void Response::clear_available_maps() {
  if (has_available_maps()) {
    delete response_.available_maps_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseAvailableMaps& Response::_internal_available_maps() const {
  return *response_.available_maps_;
}
inline ::SCRAPIProtocol::ResponseAvailableMaps* Response::release_available_maps() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.available_maps)
  if (has_available_maps()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseAvailableMaps* temp = response_.available_maps_;
    response_.available_maps_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseAvailableMaps& Response::available_maps() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.available_maps)
  return has_available_maps()
      ? *response_.available_maps_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseAvailableMaps*>(&::SCRAPIProtocol::_ResponseAvailableMaps_default_instance_);
}
inline ::SCRAPIProtocol::ResponseAvailableMaps* Response::mutable_available_maps() {
  if (!has_available_maps()) {
    clear_response();
    set_has_available_maps();
    response_.available_maps_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseAvailableMaps >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.available_maps)
  return response_.available_maps_;
}

// optional .SCRAPIProtocol.ResponseSaveMap save_map = 18;
inline bool Response::has_save_map() const {
  return response_case() == kSaveMap;
}
inline void Response::set_has_save_map() {
  _oneof_case_[0] = kSaveMap;
}
inline void Response::clear_save_map() {
  if (has_save_map()) {
    delete response_.save_map_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseSaveMap& Response::_internal_save_map() const {
  return *response_.save_map_;
}
inline ::SCRAPIProtocol::ResponseSaveMap* Response::release_save_map() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.save_map)
  if (has_save_map()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseSaveMap* temp = response_.save_map_;
    response_.save_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseSaveMap& Response::save_map() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.save_map)
  return has_save_map()
      ? *response_.save_map_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseSaveMap*>(&::SCRAPIProtocol::_ResponseSaveMap_default_instance_);
}
inline ::SCRAPIProtocol::ResponseSaveMap* Response::mutable_save_map() {
  if (!has_save_map()) {
    clear_response();
    set_has_save_map();
    response_.save_map_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseSaveMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.save_map)
  return response_.save_map_;
}

// optional .SCRAPIProtocol.ResponsePing ping = 19;
inline bool Response::has_ping() const {
  return response_case() == kPing;
}
inline void Response::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void Response::clear_ping() {
  if (has_ping()) {
    delete response_.ping_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponsePing& Response::_internal_ping() const {
  return *response_.ping_;
}
inline ::SCRAPIProtocol::ResponsePing* Response::release_ping() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.ping)
  if (has_ping()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponsePing* temp = response_.ping_;
    response_.ping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponsePing& Response::ping() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.ping)
  return has_ping()
      ? *response_.ping_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponsePing*>(&::SCRAPIProtocol::_ResponsePing_default_instance_);
}
inline ::SCRAPIProtocol::ResponsePing* Response::mutable_ping() {
  if (!has_ping()) {
    clear_response();
    set_has_ping();
    response_.ping_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponsePing >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.ping)
  return response_.ping_;
}

// optional .SCRAPIProtocol.ResponseDebug debug = 20;
inline bool Response::has_debug() const {
  return response_case() == kDebug;
}
inline void Response::set_has_debug() {
  _oneof_case_[0] = kDebug;
}
inline void Response::clear_debug() {
  if (has_debug()) {
    delete response_.debug_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseDebug& Response::_internal_debug() const {
  return *response_.debug_;
}
inline ::SCRAPIProtocol::ResponseDebug* Response::release_debug() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.debug)
  if (has_debug()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseDebug* temp = response_.debug_;
    response_.debug_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseDebug& Response::debug() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.debug)
  return has_debug()
      ? *response_.debug_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseDebug*>(&::SCRAPIProtocol::_ResponseDebug_default_instance_);
}
inline ::SCRAPIProtocol::ResponseDebug* Response::mutable_debug() {
  if (!has_debug()) {
    clear_response();
    set_has_debug();
    response_.debug_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseDebug >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.debug)
  return response_.debug_;
}

// optional .SCRAPIProtocol.ResponseConnect connect = 22;
inline bool Response::has_connect() const {
  return response_case() == kConnect;
}
inline void Response::set_has_connect() {
  _oneof_case_[0] = kConnect;
}
inline void Response::clear_connect() {
  if (has_connect()) {
    delete response_.connect_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseConnect& Response::_internal_connect() const {
  return *response_.connect_;
}
inline ::SCRAPIProtocol::ResponseConnect* Response::release_connect() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.connect)
  if (has_connect()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseConnect* temp = response_.connect_;
    response_.connect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseConnect& Response::connect() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.connect)
  return has_connect()
      ? *response_.connect_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseConnect*>(&::SCRAPIProtocol::_ResponseConnect_default_instance_);
}
inline ::SCRAPIProtocol::ResponseConnect* Response::mutable_connect() {
  if (!has_connect()) {
    clear_response();
    set_has_connect();
    response_.connect_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseConnect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.connect)
  return response_.connect_;
}

// optional .SCRAPIProtocol.ResponseEndOfQueue end_of_queue = 23;
inline bool Response::has_end_of_queue() const {
  return response_case() == kEndOfQueue;
}
inline void Response::set_has_end_of_queue() {
  _oneof_case_[0] = kEndOfQueue;
}
inline void Response::clear_end_of_queue() {
  if (has_end_of_queue()) {
    delete response_.end_of_queue_;
    clear_has_response();
  }
}
inline const ::SCRAPIProtocol::ResponseEndOfQueue& Response::_internal_end_of_queue() const {
  return *response_.end_of_queue_;
}
inline ::SCRAPIProtocol::ResponseEndOfQueue* Response::release_end_of_queue() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Response.end_of_queue)
  if (has_end_of_queue()) {
    clear_has_response();
      ::SCRAPIProtocol::ResponseEndOfQueue* temp = response_.end_of_queue_;
    response_.end_of_queue_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ResponseEndOfQueue& Response::end_of_queue() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.end_of_queue)
  return has_end_of_queue()
      ? *response_.end_of_queue_
      : *reinterpret_cast< ::SCRAPIProtocol::ResponseEndOfQueue*>(&::SCRAPIProtocol::_ResponseEndOfQueue_default_instance_);
}
inline ::SCRAPIProtocol::ResponseEndOfQueue* Response::mutable_end_of_queue() {
  if (!has_end_of_queue()) {
    clear_response();
    set_has_end_of_queue();
    response_.end_of_queue_ = CreateMaybeMessage< ::SCRAPIProtocol::ResponseEndOfQueue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.end_of_queue)
  return response_.end_of_queue_;
}

// repeated string error = 98;
inline int Response::error_size() const {
  return error_.size();
}
inline void Response::clear_error() {
  error_.Clear();
}
inline const ::std::string& Response::error(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.error)
  return error_.Get(index);
}
inline ::std::string* Response::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Response.error)
  return error_.Mutable(index);
}
inline void Response::set_error(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Response.error)
  error_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Response::set_error(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Response.error)
  error_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Response::set_error(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  error_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.Response.error)
}
inline void Response::set_error(int index, const char* value, size_t size) {
  error_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.Response.error)
}
inline ::std::string* Response::add_error() {
  // @@protoc_insertion_point(field_add_mutable:SCRAPIProtocol.Response.error)
  return error_.Add();
}
inline void Response::add_error(const ::std::string& value) {
  error_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.Response.error)
}
#if LANG_CXX11
inline void Response::add_error(::std::string&& value) {
  error_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.Response.error)
}
#endif
inline void Response::add_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  error_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SCRAPIProtocol.Response.error)
}
inline void Response::add_error(const char* value, size_t size) {
  error_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SCRAPIProtocol.Response.error)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Response::error() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.Response.error)
  return error_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Response::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.Response.error)
  return &error_;
}

// optional .SCRAPIProtocol.Status status = 99;
inline bool Response::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::SCRAPIProtocol::Status Response::status() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Response.status)
  return static_cast< ::SCRAPIProtocol::Status >(status_);
}
inline void Response::set_status(::SCRAPIProtocol::Status value) {
  assert(::SCRAPIProtocol::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Response.status)
}

inline bool Response::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void Response::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline Response::ResponseCase Response::response_case() const {
  return Response::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestCreateGame

// optional .SCRAPIProtocol.LocalMap local_map = 1;
inline bool RequestCreateGame::has_local_map() const {
  return Map_case() == kLocalMap;
}
inline void RequestCreateGame::set_has_local_map() {
  _oneof_case_[0] = kLocalMap;
}
inline void RequestCreateGame::clear_local_map() {
  if (has_local_map()) {
    delete Map_.local_map_;
    clear_has_Map();
  }
}
inline const ::SCRAPIProtocol::LocalMap& RequestCreateGame::_internal_local_map() const {
  return *Map_.local_map_;
}
inline ::SCRAPIProtocol::LocalMap* RequestCreateGame::release_local_map() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestCreateGame.local_map)
  if (has_local_map()) {
    clear_has_Map();
      ::SCRAPIProtocol::LocalMap* temp = Map_.local_map_;
    Map_.local_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::LocalMap& RequestCreateGame::local_map() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestCreateGame.local_map)
  return has_local_map()
      ? *Map_.local_map_
      : *reinterpret_cast< ::SCRAPIProtocol::LocalMap*>(&::SCRAPIProtocol::_LocalMap_default_instance_);
}
inline ::SCRAPIProtocol::LocalMap* RequestCreateGame::mutable_local_map() {
  if (!has_local_map()) {
    clear_Map();
    set_has_local_map();
    Map_.local_map_ = CreateMaybeMessage< ::SCRAPIProtocol::LocalMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestCreateGame.local_map)
  return Map_.local_map_;
}

// optional string battlenet_map_name = 2;
inline bool RequestCreateGame::has_battlenet_map_name() const {
  return Map_case() == kBattlenetMapName;
}
inline void RequestCreateGame::set_has_battlenet_map_name() {
  _oneof_case_[0] = kBattlenetMapName;
}
inline void RequestCreateGame::clear_battlenet_map_name() {
  if (has_battlenet_map_name()) {
    Map_.battlenet_map_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_Map();
  }
}
inline const ::std::string& RequestCreateGame::battlenet_map_name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestCreateGame.battlenet_map_name)
  if (has_battlenet_map_name()) {
    return Map_.battlenet_map_name_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestCreateGame::set_battlenet_map_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestCreateGame.battlenet_map_name)
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestCreateGame.battlenet_map_name)
}
#if LANG_CXX11
inline void RequestCreateGame::set_battlenet_map_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestCreateGame.battlenet_map_name)
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.RequestCreateGame.battlenet_map_name)
}
#endif
inline void RequestCreateGame::set_battlenet_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.RequestCreateGame.battlenet_map_name)
}
inline void RequestCreateGame::set_battlenet_map_name(const char* value, size_t size) {
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.RequestCreateGame.battlenet_map_name)
}
inline ::std::string* RequestCreateGame::mutable_battlenet_map_name() {
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestCreateGame.battlenet_map_name)
  return Map_.battlenet_map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCreateGame::release_battlenet_map_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestCreateGame.battlenet_map_name)
  if (has_battlenet_map_name()) {
    clear_has_Map();
    return Map_.battlenet_map_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestCreateGame::set_allocated_battlenet_map_name(::std::string* battlenet_map_name) {
  if (!has_battlenet_map_name()) {
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_Map();
  if (battlenet_map_name != NULL) {
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), battlenet_map_name);
  }
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestCreateGame.battlenet_map_name)
}

// repeated .SCRAPIProtocol.PlayerSetup player_setup = 3;
inline int RequestCreateGame::player_setup_size() const {
  return player_setup_.size();
}
inline void RequestCreateGame::clear_player_setup() {
  player_setup_.Clear();
}
inline ::SCRAPIProtocol::PlayerSetup* RequestCreateGame::mutable_player_setup(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestCreateGame.player_setup)
  return player_setup_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerSetup >*
RequestCreateGame::mutable_player_setup() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.RequestCreateGame.player_setup)
  return &player_setup_;
}
inline const ::SCRAPIProtocol::PlayerSetup& RequestCreateGame::player_setup(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestCreateGame.player_setup)
  return player_setup_.Get(index);
}
inline ::SCRAPIProtocol::PlayerSetup* RequestCreateGame::add_player_setup() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.RequestCreateGame.player_setup)
  return player_setup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerSetup >&
RequestCreateGame::player_setup() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.RequestCreateGame.player_setup)
  return player_setup_;
}

// optional bool disable_fog = 4;
inline bool RequestCreateGame::has_disable_fog() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCreateGame::set_has_disable_fog() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCreateGame::clear_has_disable_fog() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCreateGame::clear_disable_fog() {
  disable_fog_ = false;
  clear_has_disable_fog();
}
inline bool RequestCreateGame::disable_fog() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestCreateGame.disable_fog)
  return disable_fog_;
}
inline void RequestCreateGame::set_disable_fog(bool value) {
  set_has_disable_fog();
  disable_fog_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestCreateGame.disable_fog)
}

// optional uint32 random_seed = 5;
inline bool RequestCreateGame::has_random_seed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCreateGame::set_has_random_seed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCreateGame::clear_has_random_seed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCreateGame::clear_random_seed() {
  random_seed_ = 0u;
  clear_has_random_seed();
}
inline ::google::protobuf::uint32 RequestCreateGame::random_seed() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestCreateGame.random_seed)
  return random_seed_;
}
inline void RequestCreateGame::set_random_seed(::google::protobuf::uint32 value) {
  set_has_random_seed();
  random_seed_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestCreateGame.random_seed)
}

// optional bool realtime = 6;
inline bool RequestCreateGame::has_realtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestCreateGame::set_has_realtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestCreateGame::clear_has_realtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestCreateGame::clear_realtime() {
  realtime_ = false;
  clear_has_realtime();
}
inline bool RequestCreateGame::realtime() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestCreateGame.realtime)
  return realtime_;
}
inline void RequestCreateGame::set_realtime(bool value) {
  set_has_realtime();
  realtime_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestCreateGame.realtime)
}

inline bool RequestCreateGame::has_Map() const {
  return Map_case() != MAP_NOT_SET;
}
inline void RequestCreateGame::clear_has_Map() {
  _oneof_case_[0] = MAP_NOT_SET;
}
inline RequestCreateGame::MapCase RequestCreateGame::Map_case() const {
  return RequestCreateGame::MapCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalMap

// optional string map_path = 1;
inline bool LocalMap::has_map_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalMap::set_has_map_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalMap::clear_has_map_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalMap::clear_map_path() {
  map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_path();
}
inline const ::std::string& LocalMap::map_path() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.LocalMap.map_path)
  return map_path_.GetNoArena();
}
inline void LocalMap::set_map_path(const ::std::string& value) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.LocalMap.map_path)
}
#if LANG_CXX11
inline void LocalMap::set_map_path(::std::string&& value) {
  set_has_map_path();
  map_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.LocalMap.map_path)
}
#endif
inline void LocalMap::set_map_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.LocalMap.map_path)
}
inline void LocalMap::set_map_path(const char* value, size_t size) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.LocalMap.map_path)
}
inline ::std::string* LocalMap::mutable_map_path() {
  set_has_map_path();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.LocalMap.map_path)
  return map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LocalMap::release_map_path() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.LocalMap.map_path)
  if (!has_map_path()) {
    return NULL;
  }
  clear_has_map_path();
  return map_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocalMap::set_allocated_map_path(::std::string* map_path) {
  if (map_path != NULL) {
    set_has_map_path();
  } else {
    clear_has_map_path();
  }
  map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_path);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.LocalMap.map_path)
}

// optional bytes map_data = 7;
inline bool LocalMap::has_map_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalMap::set_has_map_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalMap::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalMap::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_data();
}
inline const ::std::string& LocalMap::map_data() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.LocalMap.map_data)
  return map_data_.GetNoArena();
}
inline void LocalMap::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.LocalMap.map_data)
}
#if LANG_CXX11
inline void LocalMap::set_map_data(::std::string&& value) {
  set_has_map_data();
  map_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.LocalMap.map_data)
}
#endif
inline void LocalMap::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.LocalMap.map_data)
}
inline void LocalMap::set_map_data(const void* value, size_t size) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.LocalMap.map_data)
}
inline ::std::string* LocalMap::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.LocalMap.map_data)
  return map_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LocalMap::release_map_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.LocalMap.map_data)
  if (!has_map_data()) {
    return NULL;
  }
  clear_has_map_data();
  return map_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocalMap::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.LocalMap.map_data)
}

// -------------------------------------------------------------------

// ResponseCreateGame

// optional .SCRAPIProtocol.ResponseCreateGame.Error error = 1;
inline bool ResponseCreateGame::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCreateGame::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCreateGame::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCreateGame::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SCRAPIProtocol::ResponseCreateGame_Error ResponseCreateGame::error() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseCreateGame.error)
  return static_cast< ::SCRAPIProtocol::ResponseCreateGame_Error >(error_);
}
inline void ResponseCreateGame::set_error(::SCRAPIProtocol::ResponseCreateGame_Error value) {
  assert(::SCRAPIProtocol::ResponseCreateGame_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseCreateGame.error)
}

// optional string error_details = 2;
inline bool ResponseCreateGame::has_error_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCreateGame::set_has_error_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCreateGame::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCreateGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseCreateGame::error_details() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseCreateGame.error_details)
  return error_details_.GetNoArena();
}
inline void ResponseCreateGame::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseCreateGame.error_details)
}
#if LANG_CXX11
inline void ResponseCreateGame::set_error_details(::std::string&& value) {
  set_has_error_details();
  error_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseCreateGame.error_details)
}
#endif
inline void ResponseCreateGame::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseCreateGame.error_details)
}
inline void ResponseCreateGame::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseCreateGame.error_details)
}
inline ::std::string* ResponseCreateGame::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseCreateGame.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCreateGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseCreateGame.error_details)
  if (!has_error_details()) {
    return NULL;
  }
  clear_has_error_details();
  return error_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCreateGame::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseCreateGame.error_details)
}

// -------------------------------------------------------------------

// RequestJoinGame

// optional .SCRAPIProtocol.Race race = 1;
inline bool RequestJoinGame::has_race() const {
  return participation_case() == kRace;
}
inline void RequestJoinGame::set_has_race() {
  _oneof_case_[0] = kRace;
}
inline void RequestJoinGame::clear_race() {
  if (has_race()) {
    participation_.race_ = 0;
    clear_has_participation();
  }
}
inline ::SCRAPIProtocol::Race RequestJoinGame::race() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestJoinGame.race)
  if (has_race()) {
    return static_cast< ::SCRAPIProtocol::Race >(participation_.race_);
  }
  return static_cast< ::SCRAPIProtocol::Race >(0);
}
inline void RequestJoinGame::set_race(::SCRAPIProtocol::Race value) {
  assert(::SCRAPIProtocol::Race_IsValid(value));
  if (!has_race()) {
    clear_participation();
    set_has_race();
  }
  participation_.race_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestJoinGame.race)
}

// optional uint32 observed_player_id = 2;
inline bool RequestJoinGame::has_observed_player_id() const {
  return participation_case() == kObservedPlayerId;
}
inline void RequestJoinGame::set_has_observed_player_id() {
  _oneof_case_[0] = kObservedPlayerId;
}
inline void RequestJoinGame::clear_observed_player_id() {
  if (has_observed_player_id()) {
    participation_.observed_player_id_ = 0u;
    clear_has_participation();
  }
}
inline ::google::protobuf::uint32 RequestJoinGame::observed_player_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestJoinGame.observed_player_id)
  if (has_observed_player_id()) {
    return participation_.observed_player_id_;
  }
  return 0u;
}
inline void RequestJoinGame::set_observed_player_id(::google::protobuf::uint32 value) {
  if (!has_observed_player_id()) {
    clear_participation();
    set_has_observed_player_id();
  }
  participation_.observed_player_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestJoinGame.observed_player_id)
}

// optional .SCRAPIProtocol.InterfaceOptions options = 3;
inline bool RequestJoinGame::has_options() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestJoinGame::set_has_options() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestJoinGame::clear_has_options() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestJoinGame::clear_options() {
  if (options_ != NULL) options_->Clear();
  clear_has_options();
}
inline const ::SCRAPIProtocol::InterfaceOptions& RequestJoinGame::_internal_options() const {
  return *options_;
}
inline const ::SCRAPIProtocol::InterfaceOptions& RequestJoinGame::options() const {
  const ::SCRAPIProtocol::InterfaceOptions* p = options_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestJoinGame.options)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::InterfaceOptions*>(
      &::SCRAPIProtocol::_InterfaceOptions_default_instance_);
}
inline ::SCRAPIProtocol::InterfaceOptions* RequestJoinGame::release_options() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestJoinGame.options)
  clear_has_options();
  ::SCRAPIProtocol::InterfaceOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::InterfaceOptions* RequestJoinGame::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::InterfaceOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestJoinGame.options)
  return options_;
}
inline void RequestJoinGame::set_allocated_options(::SCRAPIProtocol::InterfaceOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
  } else {
    clear_has_options();
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestJoinGame.options)
}

// optional .SCRAPIProtocol.PortSet server_ports = 4;
inline bool RequestJoinGame::has_server_ports() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestJoinGame::set_has_server_ports() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestJoinGame::clear_has_server_ports() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestJoinGame::clear_server_ports() {
  if (server_ports_ != NULL) server_ports_->Clear();
  clear_has_server_ports();
}
inline const ::SCRAPIProtocol::PortSet& RequestJoinGame::_internal_server_ports() const {
  return *server_ports_;
}
inline const ::SCRAPIProtocol::PortSet& RequestJoinGame::server_ports() const {
  const ::SCRAPIProtocol::PortSet* p = server_ports_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestJoinGame.server_ports)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::PortSet*>(
      &::SCRAPIProtocol::_PortSet_default_instance_);
}
inline ::SCRAPIProtocol::PortSet* RequestJoinGame::release_server_ports() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestJoinGame.server_ports)
  clear_has_server_ports();
  ::SCRAPIProtocol::PortSet* temp = server_ports_;
  server_ports_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::PortSet* RequestJoinGame::mutable_server_ports() {
  set_has_server_ports();
  if (server_ports_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::PortSet>(GetArenaNoVirtual());
    server_ports_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestJoinGame.server_ports)
  return server_ports_;
}
inline void RequestJoinGame::set_allocated_server_ports(::SCRAPIProtocol::PortSet* server_ports) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_ports_;
  }
  if (server_ports) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server_ports = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server_ports, submessage_arena);
    }
    set_has_server_ports();
  } else {
    clear_has_server_ports();
  }
  server_ports_ = server_ports;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestJoinGame.server_ports)
}

// repeated .SCRAPIProtocol.PortSet client_ports = 5;
inline int RequestJoinGame::client_ports_size() const {
  return client_ports_.size();
}
inline void RequestJoinGame::clear_client_ports() {
  client_ports_.Clear();
}
inline ::SCRAPIProtocol::PortSet* RequestJoinGame::mutable_client_ports(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestJoinGame.client_ports)
  return client_ports_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PortSet >*
RequestJoinGame::mutable_client_ports() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.RequestJoinGame.client_ports)
  return &client_ports_;
}
inline const ::SCRAPIProtocol::PortSet& RequestJoinGame::client_ports(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestJoinGame.client_ports)
  return client_ports_.Get(index);
}
inline ::SCRAPIProtocol::PortSet* RequestJoinGame::add_client_ports() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.RequestJoinGame.client_ports)
  return client_ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PortSet >&
RequestJoinGame::client_ports() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.RequestJoinGame.client_ports)
  return client_ports_;
}

// optional int32 shared_port = 6;
inline bool RequestJoinGame::has_shared_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestJoinGame::set_has_shared_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestJoinGame::clear_has_shared_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestJoinGame::clear_shared_port() {
  shared_port_ = 0;
  clear_has_shared_port();
}
inline ::google::protobuf::int32 RequestJoinGame::shared_port() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestJoinGame.shared_port)
  return shared_port_;
}
inline void RequestJoinGame::set_shared_port(::google::protobuf::int32 value) {
  set_has_shared_port();
  shared_port_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestJoinGame.shared_port)
}

inline bool RequestJoinGame::has_participation() const {
  return participation_case() != PARTICIPATION_NOT_SET;
}
inline void RequestJoinGame::clear_has_participation() {
  _oneof_case_[0] = PARTICIPATION_NOT_SET;
}
inline RequestJoinGame::ParticipationCase RequestJoinGame::participation_case() const {
  return RequestJoinGame::ParticipationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PortSet

// optional int32 game_port = 1;
inline bool PortSet::has_game_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortSet::set_has_game_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortSet::clear_has_game_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortSet::clear_game_port() {
  game_port_ = 0;
  clear_has_game_port();
}
inline ::google::protobuf::int32 PortSet::game_port() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PortSet.game_port)
  return game_port_;
}
inline void PortSet::set_game_port(::google::protobuf::int32 value) {
  set_has_game_port();
  game_port_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PortSet.game_port)
}

// optional int32 base_port = 2;
inline bool PortSet::has_base_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortSet::set_has_base_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortSet::clear_has_base_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortSet::clear_base_port() {
  base_port_ = 0;
  clear_has_base_port();
}
inline ::google::protobuf::int32 PortSet::base_port() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PortSet.base_port)
  return base_port_;
}
inline void PortSet::set_base_port(::google::protobuf::int32 value) {
  set_has_base_port();
  base_port_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PortSet.base_port)
}

// -------------------------------------------------------------------

// ResponseJoinGame

// optional uint32 player_id = 1;
inline bool ResponseJoinGame::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseJoinGame::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseJoinGame::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseJoinGame::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ResponseJoinGame::player_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseJoinGame.player_id)
  return player_id_;
}
inline void ResponseJoinGame::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseJoinGame.player_id)
}

// optional .SCRAPIProtocol.ResponseJoinGame.Error error = 2;
inline bool ResponseJoinGame::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseJoinGame::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseJoinGame::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseJoinGame::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SCRAPIProtocol::ResponseJoinGame_Error ResponseJoinGame::error() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseJoinGame.error)
  return static_cast< ::SCRAPIProtocol::ResponseJoinGame_Error >(error_);
}
inline void ResponseJoinGame::set_error(::SCRAPIProtocol::ResponseJoinGame_Error value) {
  assert(::SCRAPIProtocol::ResponseJoinGame_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseJoinGame.error)
}

// optional string error_details = 3;
inline bool ResponseJoinGame::has_error_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseJoinGame::set_has_error_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseJoinGame::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseJoinGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseJoinGame::error_details() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseJoinGame.error_details)
  return error_details_.GetNoArena();
}
inline void ResponseJoinGame::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseJoinGame.error_details)
}
#if LANG_CXX11
inline void ResponseJoinGame::set_error_details(::std::string&& value) {
  set_has_error_details();
  error_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseJoinGame.error_details)
}
#endif
inline void ResponseJoinGame::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseJoinGame.error_details)
}
inline void ResponseJoinGame::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseJoinGame.error_details)
}
inline ::std::string* ResponseJoinGame::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseJoinGame.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseJoinGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseJoinGame.error_details)
  if (!has_error_details()) {
    return NULL;
  }
  clear_has_error_details();
  return error_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseJoinGame::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseJoinGame.error_details)
}

// -------------------------------------------------------------------

// RequestRestartGame

// -------------------------------------------------------------------

// ResponseRestartGame

// optional .SCRAPIProtocol.ResponseRestartGame.Error error = 1;
inline bool ResponseRestartGame::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseRestartGame::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseRestartGame::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseRestartGame::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SCRAPIProtocol::ResponseRestartGame_Error ResponseRestartGame::error() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseRestartGame.error)
  return static_cast< ::SCRAPIProtocol::ResponseRestartGame_Error >(error_);
}
inline void ResponseRestartGame::set_error(::SCRAPIProtocol::ResponseRestartGame_Error value) {
  assert(::SCRAPIProtocol::ResponseRestartGame_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseRestartGame.error)
}

// optional string error_details = 2;
inline bool ResponseRestartGame::has_error_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRestartGame::set_has_error_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRestartGame::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRestartGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseRestartGame::error_details() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseRestartGame.error_details)
  return error_details_.GetNoArena();
}
inline void ResponseRestartGame::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseRestartGame.error_details)
}
#if LANG_CXX11
inline void ResponseRestartGame::set_error_details(::std::string&& value) {
  set_has_error_details();
  error_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseRestartGame.error_details)
}
#endif
inline void ResponseRestartGame::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseRestartGame.error_details)
}
inline void ResponseRestartGame::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseRestartGame.error_details)
}
inline ::std::string* ResponseRestartGame::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseRestartGame.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseRestartGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseRestartGame.error_details)
  if (!has_error_details()) {
    return NULL;
  }
  clear_has_error_details();
  return error_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseRestartGame::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseRestartGame.error_details)
}

// -------------------------------------------------------------------

// RequestStartReplay

// optional string replay_path = 1;
inline bool RequestStartReplay::has_replay_path() const {
  return replay_case() == kReplayPath;
}
inline void RequestStartReplay::set_has_replay_path() {
  _oneof_case_[0] = kReplayPath;
}
inline void RequestStartReplay::clear_replay_path() {
  if (has_replay_path()) {
    replay_.replay_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestStartReplay::replay_path() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestStartReplay.replay_path)
  if (has_replay_path()) {
    return replay_.replay_path_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestStartReplay::set_replay_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStartReplay.replay_path)
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStartReplay.replay_path)
}
#if LANG_CXX11
inline void RequestStartReplay::set_replay_path(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStartReplay.replay_path)
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.RequestStartReplay.replay_path)
}
#endif
inline void RequestStartReplay::set_replay_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.RequestStartReplay.replay_path)
}
inline void RequestStartReplay::set_replay_path(const char* value, size_t size) {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.RequestStartReplay.replay_path)
}
inline ::std::string* RequestStartReplay::mutable_replay_path() {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestStartReplay.replay_path)
  return replay_.replay_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestStartReplay::release_replay_path() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestStartReplay.replay_path)
  if (has_replay_path()) {
    clear_has_replay();
    return replay_.replay_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestStartReplay::set_allocated_replay_path(::std::string* replay_path) {
  if (!has_replay_path()) {
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_path != NULL) {
    set_has_replay_path();
    replay_.replay_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), replay_path);
  }
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestStartReplay.replay_path)
}

// optional bytes replay_data = 5;
inline bool RequestStartReplay::has_replay_data() const {
  return replay_case() == kReplayData;
}
inline void RequestStartReplay::set_has_replay_data() {
  _oneof_case_[0] = kReplayData;
}
inline void RequestStartReplay::clear_replay_data() {
  if (has_replay_data()) {
    replay_.replay_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestStartReplay::replay_data() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestStartReplay.replay_data)
  if (has_replay_data()) {
    return replay_.replay_data_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestStartReplay::set_replay_data(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStartReplay.replay_data)
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStartReplay.replay_data)
}
#if LANG_CXX11
inline void RequestStartReplay::set_replay_data(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStartReplay.replay_data)
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.RequestStartReplay.replay_data)
}
#endif
inline void RequestStartReplay::set_replay_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.RequestStartReplay.replay_data)
}
inline void RequestStartReplay::set_replay_data(const void* value, size_t size) {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.RequestStartReplay.replay_data)
}
inline ::std::string* RequestStartReplay::mutable_replay_data() {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestStartReplay.replay_data)
  return replay_.replay_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestStartReplay::release_replay_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestStartReplay.replay_data)
  if (has_replay_data()) {
    clear_has_replay();
    return replay_.replay_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestStartReplay::set_allocated_replay_data(::std::string* replay_data) {
  if (!has_replay_data()) {
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_data != NULL) {
    set_has_replay_data();
    replay_.replay_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), replay_data);
  }
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestStartReplay.replay_data)
}

// optional bytes map_data = 6;
inline bool RequestStartReplay::has_map_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStartReplay::set_has_map_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStartReplay::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStartReplay::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_data();
}
inline const ::std::string& RequestStartReplay::map_data() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestStartReplay.map_data)
  return map_data_.GetNoArena();
}
inline void RequestStartReplay::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStartReplay.map_data)
}
#if LANG_CXX11
inline void RequestStartReplay::set_map_data(::std::string&& value) {
  set_has_map_data();
  map_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.RequestStartReplay.map_data)
}
#endif
inline void RequestStartReplay::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.RequestStartReplay.map_data)
}
inline void RequestStartReplay::set_map_data(const void* value, size_t size) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.RequestStartReplay.map_data)
}
inline ::std::string* RequestStartReplay::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestStartReplay.map_data)
  return map_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestStartReplay::release_map_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestStartReplay.map_data)
  if (!has_map_data()) {
    return NULL;
  }
  clear_has_map_data();
  return map_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestStartReplay::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestStartReplay.map_data)
}

// optional int32 observed_player_id = 2;
inline bool RequestStartReplay::has_observed_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestStartReplay::set_has_observed_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestStartReplay::clear_has_observed_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestStartReplay::clear_observed_player_id() {
  observed_player_id_ = 0;
  clear_has_observed_player_id();
}
inline ::google::protobuf::int32 RequestStartReplay::observed_player_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestStartReplay.observed_player_id)
  return observed_player_id_;
}
inline void RequestStartReplay::set_observed_player_id(::google::protobuf::int32 value) {
  set_has_observed_player_id();
  observed_player_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStartReplay.observed_player_id)
}

// optional .SCRAPIProtocol.InterfaceOptions options = 3;
inline bool RequestStartReplay::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestStartReplay::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestStartReplay::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestStartReplay::clear_options() {
  if (options_ != NULL) options_->Clear();
  clear_has_options();
}
inline const ::SCRAPIProtocol::InterfaceOptions& RequestStartReplay::_internal_options() const {
  return *options_;
}
inline const ::SCRAPIProtocol::InterfaceOptions& RequestStartReplay::options() const {
  const ::SCRAPIProtocol::InterfaceOptions* p = options_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestStartReplay.options)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::InterfaceOptions*>(
      &::SCRAPIProtocol::_InterfaceOptions_default_instance_);
}
inline ::SCRAPIProtocol::InterfaceOptions* RequestStartReplay::release_options() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestStartReplay.options)
  clear_has_options();
  ::SCRAPIProtocol::InterfaceOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::InterfaceOptions* RequestStartReplay::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::InterfaceOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestStartReplay.options)
  return options_;
}
inline void RequestStartReplay::set_allocated_options(::SCRAPIProtocol::InterfaceOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
  } else {
    clear_has_options();
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestStartReplay.options)
}

// optional bool disable_fog = 4;
inline bool RequestStartReplay::has_disable_fog() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestStartReplay::set_has_disable_fog() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestStartReplay::clear_has_disable_fog() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestStartReplay::clear_disable_fog() {
  disable_fog_ = false;
  clear_has_disable_fog();
}
inline bool RequestStartReplay::disable_fog() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestStartReplay.disable_fog)
  return disable_fog_;
}
inline void RequestStartReplay::set_disable_fog(bool value) {
  set_has_disable_fog();
  disable_fog_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStartReplay.disable_fog)
}

// optional bool realtime = 7;
inline bool RequestStartReplay::has_realtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestStartReplay::set_has_realtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestStartReplay::clear_has_realtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestStartReplay::clear_realtime() {
  realtime_ = false;
  clear_has_realtime();
}
inline bool RequestStartReplay::realtime() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestStartReplay.realtime)
  return realtime_;
}
inline void RequestStartReplay::set_realtime(bool value) {
  set_has_realtime();
  realtime_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStartReplay.realtime)
}

inline bool RequestStartReplay::has_replay() const {
  return replay_case() != REPLAY_NOT_SET;
}
inline void RequestStartReplay::clear_has_replay() {
  _oneof_case_[0] = REPLAY_NOT_SET;
}
inline RequestStartReplay::ReplayCase RequestStartReplay::replay_case() const {
  return RequestStartReplay::ReplayCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseStartReplay

// optional .SCRAPIProtocol.ResponseStartReplay.Error error = 1;
inline bool ResponseStartReplay::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseStartReplay::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseStartReplay::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseStartReplay::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SCRAPIProtocol::ResponseStartReplay_Error ResponseStartReplay::error() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseStartReplay.error)
  return static_cast< ::SCRAPIProtocol::ResponseStartReplay_Error >(error_);
}
inline void ResponseStartReplay::set_error(::SCRAPIProtocol::ResponseStartReplay_Error value) {
  assert(::SCRAPIProtocol::ResponseStartReplay_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseStartReplay.error)
}

// optional string error_details = 2;
inline bool ResponseStartReplay::has_error_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseStartReplay::set_has_error_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseStartReplay::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseStartReplay::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseStartReplay::error_details() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseStartReplay.error_details)
  return error_details_.GetNoArena();
}
inline void ResponseStartReplay::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseStartReplay.error_details)
}
#if LANG_CXX11
inline void ResponseStartReplay::set_error_details(::std::string&& value) {
  set_has_error_details();
  error_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseStartReplay.error_details)
}
#endif
inline void ResponseStartReplay::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseStartReplay.error_details)
}
inline void ResponseStartReplay::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseStartReplay.error_details)
}
inline ::std::string* ResponseStartReplay::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseStartReplay.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseStartReplay::release_error_details() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseStartReplay.error_details)
  if (!has_error_details()) {
    return NULL;
  }
  clear_has_error_details();
  return error_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseStartReplay::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseStartReplay.error_details)
}

// -------------------------------------------------------------------

// RequestLeaveGame

// -------------------------------------------------------------------

// ResponseLeaveGame

// -------------------------------------------------------------------

// RequestQuickSave

// -------------------------------------------------------------------

// ResponseQuickSave

// -------------------------------------------------------------------

// RequestQuickLoad

// -------------------------------------------------------------------

// ResponseQuickLoad

// -------------------------------------------------------------------

// RequestQuit

// -------------------------------------------------------------------

// ResponseQuit

// -------------------------------------------------------------------

// RequestGameInfo

// -------------------------------------------------------------------

// ResponseGameInfo

// optional string map_name = 1;
inline bool ResponseGameInfo::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGameInfo::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGameInfo::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGameInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
inline const ::std::string& ResponseGameInfo::map_name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseGameInfo.map_name)
  return map_name_.GetNoArena();
}
inline void ResponseGameInfo::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseGameInfo.map_name)
}
#if LANG_CXX11
inline void ResponseGameInfo::set_map_name(::std::string&& value) {
  set_has_map_name();
  map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseGameInfo.map_name)
}
#endif
inline void ResponseGameInfo::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseGameInfo.map_name)
}
inline void ResponseGameInfo::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseGameInfo.map_name)
}
inline ::std::string* ResponseGameInfo::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseGameInfo.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseGameInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseGameInfo.map_name)
  if (!has_map_name()) {
    return NULL;
  }
  clear_has_map_name();
  return map_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseGameInfo::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseGameInfo.map_name)
}

// repeated string mod_names = 6;
inline int ResponseGameInfo::mod_names_size() const {
  return mod_names_.size();
}
inline void ResponseGameInfo::clear_mod_names() {
  mod_names_.Clear();
}
inline const ::std::string& ResponseGameInfo::mod_names(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseGameInfo.mod_names)
  return mod_names_.Get(index);
}
inline ::std::string* ResponseGameInfo::mutable_mod_names(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseGameInfo.mod_names)
  return mod_names_.Mutable(index);
}
inline void ResponseGameInfo::set_mod_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseGameInfo.mod_names)
  mod_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResponseGameInfo::set_mod_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseGameInfo.mod_names)
  mod_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResponseGameInfo::set_mod_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mod_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::set_mod_names(int index, const char* value, size_t size) {
  mod_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseGameInfo.mod_names)
}
inline ::std::string* ResponseGameInfo::add_mod_names() {
  // @@protoc_insertion_point(field_add_mutable:SCRAPIProtocol.ResponseGameInfo.mod_names)
  return mod_names_.Add();
}
inline void ResponseGameInfo::add_mod_names(const ::std::string& value) {
  mod_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseGameInfo.mod_names)
}
#if LANG_CXX11
inline void ResponseGameInfo::add_mod_names(::std::string&& value) {
  mod_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseGameInfo.mod_names)
}
#endif
inline void ResponseGameInfo::add_mod_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mod_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SCRAPIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::add_mod_names(const char* value, size_t size) {
  mod_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SCRAPIProtocol.ResponseGameInfo.mod_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseGameInfo::mod_names() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseGameInfo.mod_names)
  return mod_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseGameInfo::mutable_mod_names() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseGameInfo.mod_names)
  return &mod_names_;
}

// optional string local_map_path = 2;
inline bool ResponseGameInfo::has_local_map_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseGameInfo::set_has_local_map_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseGameInfo::clear_has_local_map_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseGameInfo::clear_local_map_path() {
  local_map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_map_path();
}
inline const ::std::string& ResponseGameInfo::local_map_path() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseGameInfo.local_map_path)
  return local_map_path_.GetNoArena();
}
inline void ResponseGameInfo::set_local_map_path(const ::std::string& value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseGameInfo.local_map_path)
}
#if LANG_CXX11
inline void ResponseGameInfo::set_local_map_path(::std::string&& value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseGameInfo.local_map_path)
}
#endif
inline void ResponseGameInfo::set_local_map_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseGameInfo.local_map_path)
}
inline void ResponseGameInfo::set_local_map_path(const char* value, size_t size) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseGameInfo.local_map_path)
}
inline ::std::string* ResponseGameInfo::mutable_local_map_path() {
  set_has_local_map_path();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseGameInfo.local_map_path)
  return local_map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseGameInfo::release_local_map_path() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseGameInfo.local_map_path)
  if (!has_local_map_path()) {
    return NULL;
  }
  clear_has_local_map_path();
  return local_map_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseGameInfo::set_allocated_local_map_path(::std::string* local_map_path) {
  if (local_map_path != NULL) {
    set_has_local_map_path();
  } else {
    clear_has_local_map_path();
  }
  local_map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_map_path);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseGameInfo.local_map_path)
}

// repeated .SCRAPIProtocol.PlayerInfo player_info = 3;
inline int ResponseGameInfo::player_info_size() const {
  return player_info_.size();
}
inline void ResponseGameInfo::clear_player_info() {
  player_info_.Clear();
}
inline ::SCRAPIProtocol::PlayerInfo* ResponseGameInfo::mutable_player_info(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseGameInfo.player_info)
  return player_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerInfo >*
ResponseGameInfo::mutable_player_info() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseGameInfo.player_info)
  return &player_info_;
}
inline const ::SCRAPIProtocol::PlayerInfo& ResponseGameInfo::player_info(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseGameInfo.player_info)
  return player_info_.Get(index);
}
inline ::SCRAPIProtocol::PlayerInfo* ResponseGameInfo::add_player_info() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseGameInfo.player_info)
  return player_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerInfo >&
ResponseGameInfo::player_info() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseGameInfo.player_info)
  return player_info_;
}

// optional .SCRAPIProtocol.StartRaw start_raw = 4;
inline bool ResponseGameInfo::has_start_raw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseGameInfo::set_has_start_raw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseGameInfo::clear_has_start_raw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SCRAPIProtocol::StartRaw& ResponseGameInfo::_internal_start_raw() const {
  return *start_raw_;
}
inline const ::SCRAPIProtocol::StartRaw& ResponseGameInfo::start_raw() const {
  const ::SCRAPIProtocol::StartRaw* p = start_raw_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseGameInfo.start_raw)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::StartRaw*>(
      &::SCRAPIProtocol::_StartRaw_default_instance_);
}
inline ::SCRAPIProtocol::StartRaw* ResponseGameInfo::release_start_raw() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseGameInfo.start_raw)
  clear_has_start_raw();
  ::SCRAPIProtocol::StartRaw* temp = start_raw_;
  start_raw_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::StartRaw* ResponseGameInfo::mutable_start_raw() {
  set_has_start_raw();
  if (start_raw_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::StartRaw>(GetArenaNoVirtual());
    start_raw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseGameInfo.start_raw)
  return start_raw_;
}
inline void ResponseGameInfo::set_allocated_start_raw(::SCRAPIProtocol::StartRaw* start_raw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_raw_);
  }
  if (start_raw) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_raw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_raw, submessage_arena);
    }
    set_has_start_raw();
  } else {
    clear_has_start_raw();
  }
  start_raw_ = start_raw;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseGameInfo.start_raw)
}

// optional .SCRAPIProtocol.InterfaceOptions options = 5;
inline bool ResponseGameInfo::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseGameInfo::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseGameInfo::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseGameInfo::clear_options() {
  if (options_ != NULL) options_->Clear();
  clear_has_options();
}
inline const ::SCRAPIProtocol::InterfaceOptions& ResponseGameInfo::_internal_options() const {
  return *options_;
}
inline const ::SCRAPIProtocol::InterfaceOptions& ResponseGameInfo::options() const {
  const ::SCRAPIProtocol::InterfaceOptions* p = options_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseGameInfo.options)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::InterfaceOptions*>(
      &::SCRAPIProtocol::_InterfaceOptions_default_instance_);
}
inline ::SCRAPIProtocol::InterfaceOptions* ResponseGameInfo::release_options() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseGameInfo.options)
  clear_has_options();
  ::SCRAPIProtocol::InterfaceOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::InterfaceOptions* ResponseGameInfo::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::InterfaceOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseGameInfo.options)
  return options_;
}
inline void ResponseGameInfo::set_allocated_options(::SCRAPIProtocol::InterfaceOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
  } else {
    clear_has_options();
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseGameInfo.options)
}

// -------------------------------------------------------------------

// RequestObservation

// optional bool disable_fog = 1;
inline bool RequestObservation::has_disable_fog() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestObservation::set_has_disable_fog() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestObservation::clear_has_disable_fog() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestObservation::clear_disable_fog() {
  disable_fog_ = false;
  clear_has_disable_fog();
}
inline bool RequestObservation::disable_fog() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestObservation.disable_fog)
  return disable_fog_;
}
inline void RequestObservation::set_disable_fog(bool value) {
  set_has_disable_fog();
  disable_fog_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestObservation.disable_fog)
}

// -------------------------------------------------------------------

// ResponseObservation

// repeated .SCRAPIProtocol.Action actions = 1;
inline int ResponseObservation::actions_size() const {
  return actions_.size();
}
inline void ResponseObservation::clear_actions() {
  actions_.Clear();
}
inline ::SCRAPIProtocol::Action* ResponseObservation::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseObservation.actions)
  return actions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Action >*
ResponseObservation::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseObservation.actions)
  return &actions_;
}
inline const ::SCRAPIProtocol::Action& ResponseObservation::actions(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseObservation.actions)
  return actions_.Get(index);
}
inline ::SCRAPIProtocol::Action* ResponseObservation::add_actions() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseObservation.actions)
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Action >&
ResponseObservation::actions() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseObservation.actions)
  return actions_;
}

// repeated .SCRAPIProtocol.ActionError action_errors = 2;
inline int ResponseObservation::action_errors_size() const {
  return action_errors_.size();
}
inline void ResponseObservation::clear_action_errors() {
  action_errors_.Clear();
}
inline ::SCRAPIProtocol::ActionError* ResponseObservation::mutable_action_errors(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseObservation.action_errors)
  return action_errors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ActionError >*
ResponseObservation::mutable_action_errors() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseObservation.action_errors)
  return &action_errors_;
}
inline const ::SCRAPIProtocol::ActionError& ResponseObservation::action_errors(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseObservation.action_errors)
  return action_errors_.Get(index);
}
inline ::SCRAPIProtocol::ActionError* ResponseObservation::add_action_errors() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseObservation.action_errors)
  return action_errors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ActionError >&
ResponseObservation::action_errors() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseObservation.action_errors)
  return action_errors_;
}

// optional .SCRAPIProtocol.Observation observation = 3;
inline bool ResponseObservation::has_observation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseObservation::set_has_observation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseObservation::clear_has_observation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseObservation::clear_observation() {
  if (observation_ != NULL) observation_->Clear();
  clear_has_observation();
}
inline const ::SCRAPIProtocol::Observation& ResponseObservation::_internal_observation() const {
  return *observation_;
}
inline const ::SCRAPIProtocol::Observation& ResponseObservation::observation() const {
  const ::SCRAPIProtocol::Observation* p = observation_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseObservation.observation)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Observation*>(
      &::SCRAPIProtocol::_Observation_default_instance_);
}
inline ::SCRAPIProtocol::Observation* ResponseObservation::release_observation() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseObservation.observation)
  clear_has_observation();
  ::SCRAPIProtocol::Observation* temp = observation_;
  observation_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Observation* ResponseObservation::mutable_observation() {
  set_has_observation();
  if (observation_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Observation>(GetArenaNoVirtual());
    observation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseObservation.observation)
  return observation_;
}
inline void ResponseObservation::set_allocated_observation(::SCRAPIProtocol::Observation* observation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete observation_;
  }
  if (observation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      observation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, observation, submessage_arena);
    }
    set_has_observation();
  } else {
    clear_has_observation();
  }
  observation_ = observation;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseObservation.observation)
}

// repeated .SCRAPIProtocol.PlayerResult player_result = 4;
inline int ResponseObservation::player_result_size() const {
  return player_result_.size();
}
inline void ResponseObservation::clear_player_result() {
  player_result_.Clear();
}
inline ::SCRAPIProtocol::PlayerResult* ResponseObservation::mutable_player_result(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseObservation.player_result)
  return player_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerResult >*
ResponseObservation::mutable_player_result() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseObservation.player_result)
  return &player_result_;
}
inline const ::SCRAPIProtocol::PlayerResult& ResponseObservation::player_result(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseObservation.player_result)
  return player_result_.Get(index);
}
inline ::SCRAPIProtocol::PlayerResult* ResponseObservation::add_player_result() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseObservation.player_result)
  return player_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerResult >&
ResponseObservation::player_result() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseObservation.player_result)
  return player_result_;
}

// repeated .SCRAPIProtocol.ChatReceived chat = 5;
inline int ResponseObservation::chat_size() const {
  return chat_.size();
}
inline void ResponseObservation::clear_chat() {
  chat_.Clear();
}
inline ::SCRAPIProtocol::ChatReceived* ResponseObservation::mutable_chat(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseObservation.chat)
  return chat_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ChatReceived >*
ResponseObservation::mutable_chat() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseObservation.chat)
  return &chat_;
}
inline const ::SCRAPIProtocol::ChatReceived& ResponseObservation::chat(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseObservation.chat)
  return chat_.Get(index);
}
inline ::SCRAPIProtocol::ChatReceived* ResponseObservation::add_chat() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseObservation.chat)
  return chat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ChatReceived >&
ResponseObservation::chat() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseObservation.chat)
  return chat_;
}

// -------------------------------------------------------------------

// ChatReceived

// optional uint32 player_id = 1;
inline bool ChatReceived::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatReceived::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatReceived::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatReceived::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ChatReceived::player_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ChatReceived.player_id)
  return player_id_;
}
inline void ChatReceived::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ChatReceived.player_id)
}

// optional string message = 2;
inline bool ChatReceived::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReceived::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReceived::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReceived::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ChatReceived::message() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ChatReceived.message)
  return message_.GetNoArena();
}
inline void ChatReceived::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ChatReceived.message)
}
#if LANG_CXX11
inline void ChatReceived::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ChatReceived.message)
}
#endif
inline void ChatReceived::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ChatReceived.message)
}
inline void ChatReceived::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ChatReceived.message)
}
inline ::std::string* ChatReceived::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ChatReceived.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatReceived::release_message() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ChatReceived.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatReceived::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ChatReceived.message)
}

// -------------------------------------------------------------------

// RequestAction

// repeated .SCRAPIProtocol.Action actions = 1;
inline int RequestAction::actions_size() const {
  return actions_.size();
}
inline void RequestAction::clear_actions() {
  actions_.Clear();
}
inline ::SCRAPIProtocol::Action* RequestAction::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestAction.actions)
  return actions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Action >*
RequestAction::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.RequestAction.actions)
  return &actions_;
}
inline const ::SCRAPIProtocol::Action& RequestAction::actions(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestAction.actions)
  return actions_.Get(index);
}
inline ::SCRAPIProtocol::Action* RequestAction::add_actions() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.RequestAction.actions)
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::Action >&
RequestAction::actions() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.RequestAction.actions)
  return actions_;
}

// -------------------------------------------------------------------

// ResponseAction

// repeated .SCRAPIProtocol.ActionResult result = 1;
inline int ResponseAction::result_size() const {
  return result_.size();
}
inline void ResponseAction::clear_result() {
  result_.Clear();
}
inline ::SCRAPIProtocol::ActionResult ResponseAction::result(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseAction.result)
  return static_cast< ::SCRAPIProtocol::ActionResult >(result_.Get(index));
}
inline void ResponseAction::set_result(int index, ::SCRAPIProtocol::ActionResult value) {
  assert(::SCRAPIProtocol::ActionResult_IsValid(value));
  result_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseAction.result)
}
inline void ResponseAction::add_result(::SCRAPIProtocol::ActionResult value) {
  assert(::SCRAPIProtocol::ActionResult_IsValid(value));
  result_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseAction.result)
}
inline const ::google::protobuf::RepeatedField<int>&
ResponseAction::result() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseAction.result)
  return result_;
}
inline ::google::protobuf::RepeatedField<int>*
ResponseAction::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseAction.result)
  return &result_;
}

// -------------------------------------------------------------------

// RequestObserverAction

// repeated .SCRAPIProtocol.ObserverAction actions = 1;
inline int RequestObserverAction::actions_size() const {
  return actions_.size();
}
inline void RequestObserverAction::clear_actions() {
  actions_.Clear();
}
inline ::SCRAPIProtocol::ObserverAction* RequestObserverAction::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestObserverAction.actions)
  return actions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ObserverAction >*
RequestObserverAction::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.RequestObserverAction.actions)
  return &actions_;
}
inline const ::SCRAPIProtocol::ObserverAction& RequestObserverAction::actions(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestObserverAction.actions)
  return actions_.Get(index);
}
inline ::SCRAPIProtocol::ObserverAction* RequestObserverAction::add_actions() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.RequestObserverAction.actions)
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ObserverAction >&
RequestObserverAction::actions() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.RequestObserverAction.actions)
  return actions_;
}

// -------------------------------------------------------------------

// ResponseObserverAction

// -------------------------------------------------------------------

// RequestStep

// optional uint32 count = 1;
inline bool RequestStep::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStep::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStep::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStep::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 RequestStep::count() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestStep.count)
  return count_;
}
inline void RequestStep::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestStep.count)
}

// -------------------------------------------------------------------

// ResponseStep

// -------------------------------------------------------------------

// RequestData

// optional bool ability_id = 1;
inline bool RequestData::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestData::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestData::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestData::clear_ability_id() {
  ability_id_ = false;
  clear_has_ability_id();
}
inline bool RequestData::ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestData.ability_id)
  return ability_id_;
}
inline void RequestData::set_ability_id(bool value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestData.ability_id)
}

// optional bool unit_type_id = 2;
inline bool RequestData::has_unit_type_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestData::set_has_unit_type_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestData::clear_has_unit_type_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestData::clear_unit_type_id() {
  unit_type_id_ = false;
  clear_has_unit_type_id();
}
inline bool RequestData::unit_type_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestData.unit_type_id)
  return unit_type_id_;
}
inline void RequestData::set_unit_type_id(bool value) {
  set_has_unit_type_id();
  unit_type_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestData.unit_type_id)
}

// optional bool upgrade_id = 3;
inline bool RequestData::has_upgrade_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestData::set_has_upgrade_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestData::clear_has_upgrade_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestData::clear_upgrade_id() {
  upgrade_id_ = false;
  clear_has_upgrade_id();
}
inline bool RequestData::upgrade_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestData.upgrade_id)
  return upgrade_id_;
}
inline void RequestData::set_upgrade_id(bool value) {
  set_has_upgrade_id();
  upgrade_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestData.upgrade_id)
}

// optional bool buff_id = 4;
inline bool RequestData::has_buff_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestData::set_has_buff_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestData::clear_has_buff_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestData::clear_buff_id() {
  buff_id_ = false;
  clear_has_buff_id();
}
inline bool RequestData::buff_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestData.buff_id)
  return buff_id_;
}
inline void RequestData::set_buff_id(bool value) {
  set_has_buff_id();
  buff_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestData.buff_id)
}

// optional bool effect_id = 5;
inline bool RequestData::has_effect_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestData::set_has_effect_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestData::clear_has_effect_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestData::clear_effect_id() {
  effect_id_ = false;
  clear_has_effect_id();
}
inline bool RequestData::effect_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestData.effect_id)
  return effect_id_;
}
inline void RequestData::set_effect_id(bool value) {
  set_has_effect_id();
  effect_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestData.effect_id)
}

// -------------------------------------------------------------------

// ResponseData

// repeated .SCRAPIProtocol.AbilityData abilities = 1;
inline int ResponseData::abilities_size() const {
  return abilities_.size();
}
inline ::SCRAPIProtocol::AbilityData* ResponseData::mutable_abilities(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseData.abilities)
  return abilities_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::AbilityData >*
ResponseData::mutable_abilities() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseData.abilities)
  return &abilities_;
}
inline const ::SCRAPIProtocol::AbilityData& ResponseData::abilities(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseData.abilities)
  return abilities_.Get(index);
}
inline ::SCRAPIProtocol::AbilityData* ResponseData::add_abilities() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseData.abilities)
  return abilities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::AbilityData >&
ResponseData::abilities() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseData.abilities)
  return abilities_;
}

// repeated .SCRAPIProtocol.UnitTypeData units = 2;
inline int ResponseData::units_size() const {
  return units_.size();
}
inline ::SCRAPIProtocol::UnitTypeData* ResponseData::mutable_units(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseData.units)
  return units_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitTypeData >*
ResponseData::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseData.units)
  return &units_;
}
inline const ::SCRAPIProtocol::UnitTypeData& ResponseData::units(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseData.units)
  return units_.Get(index);
}
inline ::SCRAPIProtocol::UnitTypeData* ResponseData::add_units() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseData.units)
  return units_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitTypeData >&
ResponseData::units() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseData.units)
  return units_;
}

// repeated .SCRAPIProtocol.UpgradeData upgrades = 3;
inline int ResponseData::upgrades_size() const {
  return upgrades_.size();
}
inline ::SCRAPIProtocol::UpgradeData* ResponseData::mutable_upgrades(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseData.upgrades)
  return upgrades_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UpgradeData >*
ResponseData::mutable_upgrades() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseData.upgrades)
  return &upgrades_;
}
inline const ::SCRAPIProtocol::UpgradeData& ResponseData::upgrades(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseData.upgrades)
  return upgrades_.Get(index);
}
inline ::SCRAPIProtocol::UpgradeData* ResponseData::add_upgrades() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseData.upgrades)
  return upgrades_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UpgradeData >&
ResponseData::upgrades() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseData.upgrades)
  return upgrades_;
}

// repeated .SCRAPIProtocol.BuffData buffs = 4;
inline int ResponseData::buffs_size() const {
  return buffs_.size();
}
inline ::SCRAPIProtocol::BuffData* ResponseData::mutable_buffs(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseData.buffs)
  return buffs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::BuffData >*
ResponseData::mutable_buffs() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseData.buffs)
  return &buffs_;
}
inline const ::SCRAPIProtocol::BuffData& ResponseData::buffs(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseData.buffs)
  return buffs_.Get(index);
}
inline ::SCRAPIProtocol::BuffData* ResponseData::add_buffs() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseData.buffs)
  return buffs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::BuffData >&
ResponseData::buffs() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseData.buffs)
  return buffs_;
}

// repeated .SCRAPIProtocol.EffectData effects = 5;
inline int ResponseData::effects_size() const {
  return effects_.size();
}
inline ::SCRAPIProtocol::EffectData* ResponseData::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseData.effects)
  return effects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::EffectData >*
ResponseData::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseData.effects)
  return &effects_;
}
inline const ::SCRAPIProtocol::EffectData& ResponseData::effects(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseData.effects)
  return effects_.Get(index);
}
inline ::SCRAPIProtocol::EffectData* ResponseData::add_effects() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseData.effects)
  return effects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::EffectData >&
ResponseData::effects() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseData.effects)
  return effects_;
}

// -------------------------------------------------------------------

// RequestSaveReplay

// -------------------------------------------------------------------

// ResponseSaveReplay

// optional bytes data = 1;
inline bool ResponseSaveReplay::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseSaveReplay::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseSaveReplay::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseSaveReplay::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ResponseSaveReplay::data() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseSaveReplay.data)
  return data_.GetNoArena();
}
inline void ResponseSaveReplay::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseSaveReplay.data)
}
#if LANG_CXX11
inline void ResponseSaveReplay::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseSaveReplay.data)
}
#endif
inline void ResponseSaveReplay::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseSaveReplay.data)
}
inline void ResponseSaveReplay::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseSaveReplay.data)
}
inline ::std::string* ResponseSaveReplay::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseSaveReplay.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseSaveReplay::release_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseSaveReplay.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSaveReplay::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseSaveReplay.data)
}

// -------------------------------------------------------------------

// RequestReplayInfo

// optional string replay_path = 1;
inline bool RequestReplayInfo::has_replay_path() const {
  return replay_case() == kReplayPath;
}
inline void RequestReplayInfo::set_has_replay_path() {
  _oneof_case_[0] = kReplayPath;
}
inline void RequestReplayInfo::clear_replay_path() {
  if (has_replay_path()) {
    replay_.replay_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestReplayInfo::replay_path() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestReplayInfo.replay_path)
  if (has_replay_path()) {
    return replay_.replay_path_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestReplayInfo::set_replay_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestReplayInfo.replay_path)
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestReplayInfo.replay_path)
}
#if LANG_CXX11
inline void RequestReplayInfo::set_replay_path(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestReplayInfo.replay_path)
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.RequestReplayInfo.replay_path)
}
#endif
inline void RequestReplayInfo::set_replay_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.RequestReplayInfo.replay_path)
}
inline void RequestReplayInfo::set_replay_path(const char* value, size_t size) {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.RequestReplayInfo.replay_path)
}
inline ::std::string* RequestReplayInfo::mutable_replay_path() {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestReplayInfo.replay_path)
  return replay_.replay_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestReplayInfo::release_replay_path() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestReplayInfo.replay_path)
  if (has_replay_path()) {
    clear_has_replay();
    return replay_.replay_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestReplayInfo::set_allocated_replay_path(::std::string* replay_path) {
  if (!has_replay_path()) {
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_path != NULL) {
    set_has_replay_path();
    replay_.replay_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), replay_path);
  }
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestReplayInfo.replay_path)
}

// optional bytes replay_data = 2;
inline bool RequestReplayInfo::has_replay_data() const {
  return replay_case() == kReplayData;
}
inline void RequestReplayInfo::set_has_replay_data() {
  _oneof_case_[0] = kReplayData;
}
inline void RequestReplayInfo::clear_replay_data() {
  if (has_replay_data()) {
    replay_.replay_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestReplayInfo::replay_data() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestReplayInfo.replay_data)
  if (has_replay_data()) {
    return replay_.replay_data_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestReplayInfo::set_replay_data(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestReplayInfo.replay_data)
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestReplayInfo.replay_data)
}
#if LANG_CXX11
inline void RequestReplayInfo::set_replay_data(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestReplayInfo.replay_data)
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.RequestReplayInfo.replay_data)
}
#endif
inline void RequestReplayInfo::set_replay_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.RequestReplayInfo.replay_data)
}
inline void RequestReplayInfo::set_replay_data(const void* value, size_t size) {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.RequestReplayInfo.replay_data)
}
inline ::std::string* RequestReplayInfo::mutable_replay_data() {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestReplayInfo.replay_data)
  return replay_.replay_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestReplayInfo::release_replay_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestReplayInfo.replay_data)
  if (has_replay_data()) {
    clear_has_replay();
    return replay_.replay_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestReplayInfo::set_allocated_replay_data(::std::string* replay_data) {
  if (!has_replay_data()) {
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_data != NULL) {
    set_has_replay_data();
    replay_.replay_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), replay_data);
  }
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestReplayInfo.replay_data)
}

// optional bool download_data = 3;
inline bool RequestReplayInfo::has_download_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestReplayInfo::set_has_download_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestReplayInfo::clear_has_download_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestReplayInfo::clear_download_data() {
  download_data_ = false;
  clear_has_download_data();
}
inline bool RequestReplayInfo::download_data() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestReplayInfo.download_data)
  return download_data_;
}
inline void RequestReplayInfo::set_download_data(bool value) {
  set_has_download_data();
  download_data_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestReplayInfo.download_data)
}

inline bool RequestReplayInfo::has_replay() const {
  return replay_case() != REPLAY_NOT_SET;
}
inline void RequestReplayInfo::clear_has_replay() {
  _oneof_case_[0] = REPLAY_NOT_SET;
}
inline RequestReplayInfo::ReplayCase RequestReplayInfo::replay_case() const {
  return RequestReplayInfo::ReplayCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlayerInfoExtra

// optional .SCRAPIProtocol.PlayerInfo player_info = 1;
inline bool PlayerInfoExtra::has_player_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoExtra::set_has_player_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfoExtra::clear_has_player_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfoExtra::clear_player_info() {
  if (player_info_ != NULL) player_info_->Clear();
  clear_has_player_info();
}
inline const ::SCRAPIProtocol::PlayerInfo& PlayerInfoExtra::_internal_player_info() const {
  return *player_info_;
}
inline const ::SCRAPIProtocol::PlayerInfo& PlayerInfoExtra::player_info() const {
  const ::SCRAPIProtocol::PlayerInfo* p = player_info_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerInfoExtra.player_info)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::PlayerInfo*>(
      &::SCRAPIProtocol::_PlayerInfo_default_instance_);
}
inline ::SCRAPIProtocol::PlayerInfo* PlayerInfoExtra::release_player_info() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.PlayerInfoExtra.player_info)
  clear_has_player_info();
  ::SCRAPIProtocol::PlayerInfo* temp = player_info_;
  player_info_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::PlayerInfo* PlayerInfoExtra::mutable_player_info() {
  set_has_player_info();
  if (player_info_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::PlayerInfo>(GetArenaNoVirtual());
    player_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.PlayerInfoExtra.player_info)
  return player_info_;
}
inline void PlayerInfoExtra::set_allocated_player_info(::SCRAPIProtocol::PlayerInfo* player_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_info_;
  }
  if (player_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    set_has_player_info();
  } else {
    clear_has_player_info();
  }
  player_info_ = player_info;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.PlayerInfoExtra.player_info)
}

// optional .SCRAPIProtocol.PlayerResult player_result = 2;
inline bool PlayerInfoExtra::has_player_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoExtra::set_has_player_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfoExtra::clear_has_player_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfoExtra::clear_player_result() {
  if (player_result_ != NULL) player_result_->Clear();
  clear_has_player_result();
}
inline const ::SCRAPIProtocol::PlayerResult& PlayerInfoExtra::_internal_player_result() const {
  return *player_result_;
}
inline const ::SCRAPIProtocol::PlayerResult& PlayerInfoExtra::player_result() const {
  const ::SCRAPIProtocol::PlayerResult* p = player_result_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerInfoExtra.player_result)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::PlayerResult*>(
      &::SCRAPIProtocol::_PlayerResult_default_instance_);
}
inline ::SCRAPIProtocol::PlayerResult* PlayerInfoExtra::release_player_result() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.PlayerInfoExtra.player_result)
  clear_has_player_result();
  ::SCRAPIProtocol::PlayerResult* temp = player_result_;
  player_result_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::PlayerResult* PlayerInfoExtra::mutable_player_result() {
  set_has_player_result();
  if (player_result_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::PlayerResult>(GetArenaNoVirtual());
    player_result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.PlayerInfoExtra.player_result)
  return player_result_;
}
inline void PlayerInfoExtra::set_allocated_player_result(::SCRAPIProtocol::PlayerResult* player_result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_result_;
  }
  if (player_result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_result, submessage_arena);
    }
    set_has_player_result();
  } else {
    clear_has_player_result();
  }
  player_result_ = player_result;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.PlayerInfoExtra.player_result)
}

// optional int32 player_mmr = 3;
inline bool PlayerInfoExtra::has_player_mmr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfoExtra::set_has_player_mmr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfoExtra::clear_has_player_mmr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfoExtra::clear_player_mmr() {
  player_mmr_ = 0;
  clear_has_player_mmr();
}
inline ::google::protobuf::int32 PlayerInfoExtra::player_mmr() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerInfoExtra.player_mmr)
  return player_mmr_;
}
inline void PlayerInfoExtra::set_player_mmr(::google::protobuf::int32 value) {
  set_has_player_mmr();
  player_mmr_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerInfoExtra.player_mmr)
}

// optional int32 player_apm = 4;
inline bool PlayerInfoExtra::has_player_apm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfoExtra::set_has_player_apm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfoExtra::clear_has_player_apm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfoExtra::clear_player_apm() {
  player_apm_ = 0;
  clear_has_player_apm();
}
inline ::google::protobuf::int32 PlayerInfoExtra::player_apm() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerInfoExtra.player_apm)
  return player_apm_;
}
inline void PlayerInfoExtra::set_player_apm(::google::protobuf::int32 value) {
  set_has_player_apm();
  player_apm_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerInfoExtra.player_apm)
}

// -------------------------------------------------------------------

// ResponseReplayInfo

// optional string map_name = 1;
inline bool ResponseReplayInfo::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseReplayInfo::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseReplayInfo::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseReplayInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
inline const ::std::string& ResponseReplayInfo::map_name() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.map_name)
  return map_name_.GetNoArena();
}
inline void ResponseReplayInfo::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseReplayInfo.map_name)
}
#if LANG_CXX11
inline void ResponseReplayInfo::set_map_name(::std::string&& value) {
  set_has_map_name();
  map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseReplayInfo.map_name)
}
#endif
inline void ResponseReplayInfo::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseReplayInfo.map_name)
}
inline void ResponseReplayInfo::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseReplayInfo.map_name)
}
inline ::std::string* ResponseReplayInfo::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseReplayInfo.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseReplayInfo.map_name)
  if (!has_map_name()) {
    return NULL;
  }
  clear_has_map_name();
  return map_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseReplayInfo.map_name)
}

// optional string local_map_path = 2;
inline bool ResponseReplayInfo::has_local_map_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseReplayInfo::set_has_local_map_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseReplayInfo::clear_has_local_map_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseReplayInfo::clear_local_map_path() {
  local_map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_map_path();
}
inline const ::std::string& ResponseReplayInfo::local_map_path() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.local_map_path)
  return local_map_path_.GetNoArena();
}
inline void ResponseReplayInfo::set_local_map_path(const ::std::string& value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseReplayInfo.local_map_path)
}
#if LANG_CXX11
inline void ResponseReplayInfo::set_local_map_path(::std::string&& value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseReplayInfo.local_map_path)
}
#endif
inline void ResponseReplayInfo::set_local_map_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseReplayInfo.local_map_path)
}
inline void ResponseReplayInfo::set_local_map_path(const char* value, size_t size) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseReplayInfo.local_map_path)
}
inline ::std::string* ResponseReplayInfo::mutable_local_map_path() {
  set_has_local_map_path();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseReplayInfo.local_map_path)
  return local_map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_local_map_path() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseReplayInfo.local_map_path)
  if (!has_local_map_path()) {
    return NULL;
  }
  clear_has_local_map_path();
  return local_map_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_local_map_path(::std::string* local_map_path) {
  if (local_map_path != NULL) {
    set_has_local_map_path();
  } else {
    clear_has_local_map_path();
  }
  local_map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_map_path);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseReplayInfo.local_map_path)
}

// repeated .SCRAPIProtocol.PlayerInfoExtra player_info = 3;
inline int ResponseReplayInfo::player_info_size() const {
  return player_info_.size();
}
inline void ResponseReplayInfo::clear_player_info() {
  player_info_.Clear();
}
inline ::SCRAPIProtocol::PlayerInfoExtra* ResponseReplayInfo::mutable_player_info(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseReplayInfo.player_info)
  return player_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerInfoExtra >*
ResponseReplayInfo::mutable_player_info() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseReplayInfo.player_info)
  return &player_info_;
}
inline const ::SCRAPIProtocol::PlayerInfoExtra& ResponseReplayInfo::player_info(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.player_info)
  return player_info_.Get(index);
}
inline ::SCRAPIProtocol::PlayerInfoExtra* ResponseReplayInfo::add_player_info() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseReplayInfo.player_info)
  return player_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::PlayerInfoExtra >&
ResponseReplayInfo::player_info() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseReplayInfo.player_info)
  return player_info_;
}

// optional uint32 game_duration_loops = 4;
inline bool ResponseReplayInfo::has_game_duration_loops() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseReplayInfo::set_has_game_duration_loops() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseReplayInfo::clear_has_game_duration_loops() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseReplayInfo::clear_game_duration_loops() {
  game_duration_loops_ = 0u;
  clear_has_game_duration_loops();
}
inline ::google::protobuf::uint32 ResponseReplayInfo::game_duration_loops() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.game_duration_loops)
  return game_duration_loops_;
}
inline void ResponseReplayInfo::set_game_duration_loops(::google::protobuf::uint32 value) {
  set_has_game_duration_loops();
  game_duration_loops_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseReplayInfo.game_duration_loops)
}

// optional float game_duration_seconds = 5;
inline bool ResponseReplayInfo::has_game_duration_seconds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseReplayInfo::set_has_game_duration_seconds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseReplayInfo::clear_has_game_duration_seconds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseReplayInfo::clear_game_duration_seconds() {
  game_duration_seconds_ = 0;
  clear_has_game_duration_seconds();
}
inline float ResponseReplayInfo::game_duration_seconds() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.game_duration_seconds)
  return game_duration_seconds_;
}
inline void ResponseReplayInfo::set_game_duration_seconds(float value) {
  set_has_game_duration_seconds();
  game_duration_seconds_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseReplayInfo.game_duration_seconds)
}

// optional string game_version = 6;
inline bool ResponseReplayInfo::has_game_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseReplayInfo::set_has_game_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseReplayInfo::clear_has_game_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseReplayInfo::clear_game_version() {
  game_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_version();
}
inline const ::std::string& ResponseReplayInfo::game_version() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.game_version)
  return game_version_.GetNoArena();
}
inline void ResponseReplayInfo::set_game_version(const ::std::string& value) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseReplayInfo.game_version)
}
#if LANG_CXX11
inline void ResponseReplayInfo::set_game_version(::std::string&& value) {
  set_has_game_version();
  game_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseReplayInfo.game_version)
}
#endif
inline void ResponseReplayInfo::set_game_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseReplayInfo.game_version)
}
inline void ResponseReplayInfo::set_game_version(const char* value, size_t size) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseReplayInfo.game_version)
}
inline ::std::string* ResponseReplayInfo::mutable_game_version() {
  set_has_game_version();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseReplayInfo.game_version)
  return game_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_game_version() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseReplayInfo.game_version)
  if (!has_game_version()) {
    return NULL;
  }
  clear_has_game_version();
  return game_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_game_version(::std::string* game_version) {
  if (game_version != NULL) {
    set_has_game_version();
  } else {
    clear_has_game_version();
  }
  game_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_version);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseReplayInfo.game_version)
}

// optional string data_version = 11;
inline bool ResponseReplayInfo::has_data_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseReplayInfo::set_has_data_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseReplayInfo::clear_has_data_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseReplayInfo::clear_data_version() {
  data_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_version();
}
inline const ::std::string& ResponseReplayInfo::data_version() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.data_version)
  return data_version_.GetNoArena();
}
inline void ResponseReplayInfo::set_data_version(const ::std::string& value) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseReplayInfo.data_version)
}
#if LANG_CXX11
inline void ResponseReplayInfo::set_data_version(::std::string&& value) {
  set_has_data_version();
  data_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseReplayInfo.data_version)
}
#endif
inline void ResponseReplayInfo::set_data_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseReplayInfo.data_version)
}
inline void ResponseReplayInfo::set_data_version(const char* value, size_t size) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseReplayInfo.data_version)
}
inline ::std::string* ResponseReplayInfo::mutable_data_version() {
  set_has_data_version();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseReplayInfo.data_version)
  return data_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_data_version() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseReplayInfo.data_version)
  if (!has_data_version()) {
    return NULL;
  }
  clear_has_data_version();
  return data_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_data_version(::std::string* data_version) {
  if (data_version != NULL) {
    set_has_data_version();
  } else {
    clear_has_data_version();
  }
  data_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_version);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseReplayInfo.data_version)
}

// optional uint32 data_build = 7;
inline bool ResponseReplayInfo::has_data_build() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseReplayInfo::set_has_data_build() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseReplayInfo::clear_has_data_build() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseReplayInfo::clear_data_build() {
  data_build_ = 0u;
  clear_has_data_build();
}
inline ::google::protobuf::uint32 ResponseReplayInfo::data_build() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.data_build)
  return data_build_;
}
inline void ResponseReplayInfo::set_data_build(::google::protobuf::uint32 value) {
  set_has_data_build();
  data_build_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseReplayInfo.data_build)
}

// optional uint32 base_build = 8;
inline bool ResponseReplayInfo::has_base_build() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseReplayInfo::set_has_base_build() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseReplayInfo::clear_has_base_build() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseReplayInfo::clear_base_build() {
  base_build_ = 0u;
  clear_has_base_build();
}
inline ::google::protobuf::uint32 ResponseReplayInfo::base_build() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.base_build)
  return base_build_;
}
inline void ResponseReplayInfo::set_base_build(::google::protobuf::uint32 value) {
  set_has_base_build();
  base_build_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseReplayInfo.base_build)
}

// optional .SCRAPIProtocol.ResponseReplayInfo.Error error = 9;
inline bool ResponseReplayInfo::has_error() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseReplayInfo::set_has_error() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseReplayInfo::clear_has_error() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseReplayInfo::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SCRAPIProtocol::ResponseReplayInfo_Error ResponseReplayInfo::error() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.error)
  return static_cast< ::SCRAPIProtocol::ResponseReplayInfo_Error >(error_);
}
inline void ResponseReplayInfo::set_error(::SCRAPIProtocol::ResponseReplayInfo_Error value) {
  assert(::SCRAPIProtocol::ResponseReplayInfo_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseReplayInfo.error)
}

// optional string error_details = 10;
inline bool ResponseReplayInfo::has_error_details() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseReplayInfo::set_has_error_details() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseReplayInfo::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseReplayInfo::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseReplayInfo::error_details() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseReplayInfo.error_details)
  return error_details_.GetNoArena();
}
inline void ResponseReplayInfo::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseReplayInfo.error_details)
}
#if LANG_CXX11
inline void ResponseReplayInfo::set_error_details(::std::string&& value) {
  set_has_error_details();
  error_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponseReplayInfo.error_details)
}
#endif
inline void ResponseReplayInfo::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseReplayInfo.error_details)
}
inline void ResponseReplayInfo::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseReplayInfo.error_details)
}
inline ::std::string* ResponseReplayInfo::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseReplayInfo.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_error_details() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponseReplayInfo.error_details)
  if (!has_error_details()) {
    return NULL;
  }
  clear_has_error_details();
  return error_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponseReplayInfo.error_details)
}

// -------------------------------------------------------------------

// RequestAvailableMaps

// -------------------------------------------------------------------

// ResponseAvailableMaps

// repeated string local_map_paths = 1;
inline int ResponseAvailableMaps::local_map_paths_size() const {
  return local_map_paths_.size();
}
inline void ResponseAvailableMaps::clear_local_map_paths() {
  local_map_paths_.Clear();
}
inline const ::std::string& ResponseAvailableMaps::local_map_paths(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_.Get(index);
}
inline ::std::string* ResponseAvailableMaps::mutable_local_map_paths(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_.Mutable(index);
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
  local_map_paths_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResponseAvailableMaps::set_local_map_paths(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
  local_map_paths_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResponseAvailableMaps::set_local_map_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  local_map_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, const char* value, size_t size) {
  local_map_paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline ::std::string* ResponseAvailableMaps::add_local_map_paths() {
  // @@protoc_insertion_point(field_add_mutable:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_.Add();
}
inline void ResponseAvailableMaps::add_local_map_paths(const ::std::string& value) {
  local_map_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
}
#if LANG_CXX11
inline void ResponseAvailableMaps::add_local_map_paths(::std::string&& value) {
  local_map_paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
}
#endif
inline void ResponseAvailableMaps::add_local_map_paths(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  local_map_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::add_local_map_paths(const char* value, size_t size) {
  local_map_paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseAvailableMaps::local_map_paths() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseAvailableMaps::mutable_local_map_paths() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseAvailableMaps.local_map_paths)
  return &local_map_paths_;
}

// repeated string battlenet_map_names = 2;
inline int ResponseAvailableMaps::battlenet_map_names_size() const {
  return battlenet_map_names_.size();
}
inline void ResponseAvailableMaps::clear_battlenet_map_names() {
  battlenet_map_names_.Clear();
}
inline const ::std::string& ResponseAvailableMaps::battlenet_map_names(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_.Get(index);
}
inline ::std::string* ResponseAvailableMaps::mutable_battlenet_map_names(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_.Mutable(index);
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
  battlenet_map_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
  battlenet_map_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  battlenet_map_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const char* value, size_t size) {
  battlenet_map_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline ::std::string* ResponseAvailableMaps::add_battlenet_map_names() {
  // @@protoc_insertion_point(field_add_mutable:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_.Add();
}
inline void ResponseAvailableMaps::add_battlenet_map_names(const ::std::string& value) {
  battlenet_map_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
#if LANG_CXX11
inline void ResponseAvailableMaps::add_battlenet_map_names(::std::string&& value) {
  battlenet_map_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
#endif
inline void ResponseAvailableMaps::add_battlenet_map_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  battlenet_map_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::add_battlenet_map_names(const char* value, size_t size) {
  battlenet_map_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseAvailableMaps::battlenet_map_names() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseAvailableMaps::mutable_battlenet_map_names() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return &battlenet_map_names_;
}

// -------------------------------------------------------------------

// RequestSaveMap

// optional string map_path = 1;
inline bool RequestSaveMap::has_map_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSaveMap::set_has_map_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSaveMap::clear_has_map_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSaveMap::clear_map_path() {
  map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_path();
}
inline const ::std::string& RequestSaveMap::map_path() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestSaveMap.map_path)
  return map_path_.GetNoArena();
}
inline void RequestSaveMap::set_map_path(const ::std::string& value) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestSaveMap.map_path)
}
#if LANG_CXX11
inline void RequestSaveMap::set_map_path(::std::string&& value) {
  set_has_map_path();
  map_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.RequestSaveMap.map_path)
}
#endif
inline void RequestSaveMap::set_map_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.RequestSaveMap.map_path)
}
inline void RequestSaveMap::set_map_path(const char* value, size_t size) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.RequestSaveMap.map_path)
}
inline ::std::string* RequestSaveMap::mutable_map_path() {
  set_has_map_path();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestSaveMap.map_path)
  return map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSaveMap::release_map_path() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestSaveMap.map_path)
  if (!has_map_path()) {
    return NULL;
  }
  clear_has_map_path();
  return map_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSaveMap::set_allocated_map_path(::std::string* map_path) {
  if (map_path != NULL) {
    set_has_map_path();
  } else {
    clear_has_map_path();
  }
  map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_path);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestSaveMap.map_path)
}

// optional bytes map_data = 2;
inline bool RequestSaveMap::has_map_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSaveMap::set_has_map_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSaveMap::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSaveMap::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_data();
}
inline const ::std::string& RequestSaveMap::map_data() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestSaveMap.map_data)
  return map_data_.GetNoArena();
}
inline void RequestSaveMap::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.RequestSaveMap.map_data)
}
#if LANG_CXX11
inline void RequestSaveMap::set_map_data(::std::string&& value) {
  set_has_map_data();
  map_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.RequestSaveMap.map_data)
}
#endif
inline void RequestSaveMap::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.RequestSaveMap.map_data)
}
inline void RequestSaveMap::set_map_data(const void* value, size_t size) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.RequestSaveMap.map_data)
}
inline ::std::string* RequestSaveMap::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestSaveMap.map_data)
  return map_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSaveMap::release_map_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.RequestSaveMap.map_data)
  if (!has_map_data()) {
    return NULL;
  }
  clear_has_map_data();
  return map_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSaveMap::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.RequestSaveMap.map_data)
}

// -------------------------------------------------------------------

// ResponseSaveMap

// optional .SCRAPIProtocol.ResponseSaveMap.Error error = 1;
inline bool ResponseSaveMap::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseSaveMap::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseSaveMap::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseSaveMap::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SCRAPIProtocol::ResponseSaveMap_Error ResponseSaveMap::error() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponseSaveMap.error)
  return static_cast< ::SCRAPIProtocol::ResponseSaveMap_Error >(error_);
}
inline void ResponseSaveMap::set_error(::SCRAPIProtocol::ResponseSaveMap_Error value) {
  assert(::SCRAPIProtocol::ResponseSaveMap_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponseSaveMap.error)
}

// -------------------------------------------------------------------

// RequestPing

// -------------------------------------------------------------------

// ResponsePing

// optional string game_version = 1;
inline bool ResponsePing::has_game_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponsePing::set_has_game_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponsePing::clear_has_game_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponsePing::clear_game_version() {
  game_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_version();
}
inline const ::std::string& ResponsePing::game_version() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponsePing.game_version)
  return game_version_.GetNoArena();
}
inline void ResponsePing::set_game_version(const ::std::string& value) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponsePing.game_version)
}
#if LANG_CXX11
inline void ResponsePing::set_game_version(::std::string&& value) {
  set_has_game_version();
  game_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponsePing.game_version)
}
#endif
inline void ResponsePing::set_game_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponsePing.game_version)
}
inline void ResponsePing::set_game_version(const char* value, size_t size) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponsePing.game_version)
}
inline ::std::string* ResponsePing::mutable_game_version() {
  set_has_game_version();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponsePing.game_version)
  return game_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponsePing::release_game_version() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponsePing.game_version)
  if (!has_game_version()) {
    return NULL;
  }
  clear_has_game_version();
  return game_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePing::set_allocated_game_version(::std::string* game_version) {
  if (game_version != NULL) {
    set_has_game_version();
  } else {
    clear_has_game_version();
  }
  game_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_version);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponsePing.game_version)
}

// optional string data_version = 2;
inline bool ResponsePing::has_data_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponsePing::set_has_data_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponsePing::clear_has_data_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponsePing::clear_data_version() {
  data_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_version();
}
inline const ::std::string& ResponsePing::data_version() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponsePing.data_version)
  return data_version_.GetNoArena();
}
inline void ResponsePing::set_data_version(const ::std::string& value) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponsePing.data_version)
}
#if LANG_CXX11
inline void ResponsePing::set_data_version(::std::string&& value) {
  set_has_data_version();
  data_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ResponsePing.data_version)
}
#endif
inline void ResponsePing::set_data_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ResponsePing.data_version)
}
inline void ResponsePing::set_data_version(const char* value, size_t size) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ResponsePing.data_version)
}
inline ::std::string* ResponsePing::mutable_data_version() {
  set_has_data_version();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ResponsePing.data_version)
  return data_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponsePing::release_data_version() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ResponsePing.data_version)
  if (!has_data_version()) {
    return NULL;
  }
  clear_has_data_version();
  return data_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePing::set_allocated_data_version(::std::string* data_version) {
  if (data_version != NULL) {
    set_has_data_version();
  } else {
    clear_has_data_version();
  }
  data_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_version);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ResponsePing.data_version)
}

// optional uint32 data_build = 3;
inline bool ResponsePing::has_data_build() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponsePing::set_has_data_build() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponsePing::clear_has_data_build() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponsePing::clear_data_build() {
  data_build_ = 0u;
  clear_has_data_build();
}
inline ::google::protobuf::uint32 ResponsePing::data_build() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponsePing.data_build)
  return data_build_;
}
inline void ResponsePing::set_data_build(::google::protobuf::uint32 value) {
  set_has_data_build();
  data_build_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponsePing.data_build)
}

// optional uint32 base_build = 4;
inline bool ResponsePing::has_base_build() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponsePing::set_has_base_build() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponsePing::clear_has_base_build() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponsePing::clear_base_build() {
  base_build_ = 0u;
  clear_has_base_build();
}
inline ::google::protobuf::uint32 ResponsePing::base_build() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ResponsePing.base_build)
  return base_build_;
}
inline void ResponsePing::set_base_build(::google::protobuf::uint32 value) {
  set_has_base_build();
  base_build_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ResponsePing.base_build)
}

// -------------------------------------------------------------------

// RequestDebug

// repeated .SCRAPIProtocol.DebugCommand debug = 1;
inline int RequestDebug::debug_size() const {
  return debug_.size();
}
inline ::SCRAPIProtocol::DebugCommand* RequestDebug::mutable_debug(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.RequestDebug.debug)
  return debug_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugCommand >*
RequestDebug::mutable_debug() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.RequestDebug.debug)
  return &debug_;
}
inline const ::SCRAPIProtocol::DebugCommand& RequestDebug::debug(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.RequestDebug.debug)
  return debug_.Get(index);
}
inline ::SCRAPIProtocol::DebugCommand* RequestDebug::add_debug() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.RequestDebug.debug)
  return debug_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::DebugCommand >&
RequestDebug::debug() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.RequestDebug.debug)
  return debug_;
}

// -------------------------------------------------------------------

// ResponseDebug

// -------------------------------------------------------------------

// RequestConnect

// -------------------------------------------------------------------

// RequestEndOfQueue

// -------------------------------------------------------------------

// ResponseConnect

// -------------------------------------------------------------------

// ResponseEndOfQueue

// -------------------------------------------------------------------

// PlayerSetup

// optional .SCRAPIProtocol.PlayerType type = 1;
inline bool PlayerSetup::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerSetup::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerSetup::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerSetup::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SCRAPIProtocol::PlayerType PlayerSetup::type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerSetup.type)
  return static_cast< ::SCRAPIProtocol::PlayerType >(type_);
}
inline void PlayerSetup::set_type(::SCRAPIProtocol::PlayerType value) {
  assert(::SCRAPIProtocol::PlayerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerSetup.type)
}

// optional .SCRAPIProtocol.Race race = 2;
inline bool PlayerSetup::has_race() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerSetup::set_has_race() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerSetup::clear_has_race() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerSetup::clear_race() {
  race_ = 0;
  clear_has_race();
}
inline ::SCRAPIProtocol::Race PlayerSetup::race() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerSetup.race)
  return static_cast< ::SCRAPIProtocol::Race >(race_);
}
inline void PlayerSetup::set_race(::SCRAPIProtocol::Race value) {
  assert(::SCRAPIProtocol::Race_IsValid(value));
  set_has_race();
  race_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerSetup.race)
}

// optional .SCRAPIProtocol.Difficulty difficulty = 3;
inline bool PlayerSetup::has_difficulty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerSetup::set_has_difficulty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerSetup::clear_has_difficulty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerSetup::clear_difficulty() {
  difficulty_ = 1;
  clear_has_difficulty();
}
inline ::SCRAPIProtocol::Difficulty PlayerSetup::difficulty() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerSetup.difficulty)
  return static_cast< ::SCRAPIProtocol::Difficulty >(difficulty_);
}
inline void PlayerSetup::set_difficulty(::SCRAPIProtocol::Difficulty value) {
  assert(::SCRAPIProtocol::Difficulty_IsValid(value));
  set_has_difficulty();
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerSetup.difficulty)
}

// -------------------------------------------------------------------

// SpatialCameraSetup

// optional float width = 1;
inline bool SpatialCameraSetup::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpatialCameraSetup::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpatialCameraSetup::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpatialCameraSetup::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float SpatialCameraSetup::width() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.SpatialCameraSetup.width)
  return width_;
}
inline void SpatialCameraSetup::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.SpatialCameraSetup.width)
}

// optional .SCRAPIProtocol.Size2DI resolution = 2;
inline bool SpatialCameraSetup::has_resolution() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpatialCameraSetup::set_has_resolution() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpatialCameraSetup::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::Size2DI& SpatialCameraSetup::_internal_resolution() const {
  return *resolution_;
}
inline const ::SCRAPIProtocol::Size2DI& SpatialCameraSetup::resolution() const {
  const ::SCRAPIProtocol::Size2DI* p = resolution_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.SpatialCameraSetup.resolution)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Size2DI*>(
      &::SCRAPIProtocol::_Size2DI_default_instance_);
}
inline ::SCRAPIProtocol::Size2DI* SpatialCameraSetup::release_resolution() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.SpatialCameraSetup.resolution)
  clear_has_resolution();
  ::SCRAPIProtocol::Size2DI* temp = resolution_;
  resolution_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Size2DI* SpatialCameraSetup::mutable_resolution() {
  set_has_resolution();
  if (resolution_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Size2DI>(GetArenaNoVirtual());
    resolution_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.SpatialCameraSetup.resolution)
  return resolution_;
}
inline void SpatialCameraSetup::set_allocated_resolution(::SCRAPIProtocol::Size2DI* resolution) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(resolution_);
  }
  if (resolution) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resolution = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resolution, submessage_arena);
    }
    set_has_resolution();
  } else {
    clear_has_resolution();
  }
  resolution_ = resolution;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.SpatialCameraSetup.resolution)
}

// optional .SCRAPIProtocol.Size2DI minimap_resolution = 3;
inline bool SpatialCameraSetup::has_minimap_resolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpatialCameraSetup::set_has_minimap_resolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpatialCameraSetup::clear_has_minimap_resolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::Size2DI& SpatialCameraSetup::_internal_minimap_resolution() const {
  return *minimap_resolution_;
}
inline const ::SCRAPIProtocol::Size2DI& SpatialCameraSetup::minimap_resolution() const {
  const ::SCRAPIProtocol::Size2DI* p = minimap_resolution_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.SpatialCameraSetup.minimap_resolution)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Size2DI*>(
      &::SCRAPIProtocol::_Size2DI_default_instance_);
}
inline ::SCRAPIProtocol::Size2DI* SpatialCameraSetup::release_minimap_resolution() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.SpatialCameraSetup.minimap_resolution)
  clear_has_minimap_resolution();
  ::SCRAPIProtocol::Size2DI* temp = minimap_resolution_;
  minimap_resolution_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Size2DI* SpatialCameraSetup::mutable_minimap_resolution() {
  set_has_minimap_resolution();
  if (minimap_resolution_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Size2DI>(GetArenaNoVirtual());
    minimap_resolution_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.SpatialCameraSetup.minimap_resolution)
  return minimap_resolution_;
}
inline void SpatialCameraSetup::set_allocated_minimap_resolution(::SCRAPIProtocol::Size2DI* minimap_resolution) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(minimap_resolution_);
  }
  if (minimap_resolution) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      minimap_resolution = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, minimap_resolution, submessage_arena);
    }
    set_has_minimap_resolution();
  } else {
    clear_has_minimap_resolution();
  }
  minimap_resolution_ = minimap_resolution;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.SpatialCameraSetup.minimap_resolution)
}

// -------------------------------------------------------------------

// InterfaceOptions

// optional bool raw = 1;
inline bool InterfaceOptions::has_raw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InterfaceOptions::set_has_raw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InterfaceOptions::clear_has_raw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InterfaceOptions::clear_raw() {
  raw_ = false;
  clear_has_raw();
}
inline bool InterfaceOptions::raw() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.InterfaceOptions.raw)
  return raw_;
}
inline void InterfaceOptions::set_raw(bool value) {
  set_has_raw();
  raw_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.InterfaceOptions.raw)
}

// optional bool score = 2;
inline bool InterfaceOptions::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InterfaceOptions::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InterfaceOptions::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InterfaceOptions::clear_score() {
  score_ = false;
  clear_has_score();
}
inline bool InterfaceOptions::score() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.InterfaceOptions.score)
  return score_;
}
inline void InterfaceOptions::set_score(bool value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.InterfaceOptions.score)
}

// optional .SCRAPIProtocol.SpatialCameraSetup feature_layer = 3;
inline bool InterfaceOptions::has_feature_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterfaceOptions::set_has_feature_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterfaceOptions::clear_has_feature_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterfaceOptions::clear_feature_layer() {
  if (feature_layer_ != NULL) feature_layer_->Clear();
  clear_has_feature_layer();
}
inline const ::SCRAPIProtocol::SpatialCameraSetup& InterfaceOptions::_internal_feature_layer() const {
  return *feature_layer_;
}
inline const ::SCRAPIProtocol::SpatialCameraSetup& InterfaceOptions::feature_layer() const {
  const ::SCRAPIProtocol::SpatialCameraSetup* p = feature_layer_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.InterfaceOptions.feature_layer)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::SpatialCameraSetup*>(
      &::SCRAPIProtocol::_SpatialCameraSetup_default_instance_);
}
inline ::SCRAPIProtocol::SpatialCameraSetup* InterfaceOptions::release_feature_layer() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.InterfaceOptions.feature_layer)
  clear_has_feature_layer();
  ::SCRAPIProtocol::SpatialCameraSetup* temp = feature_layer_;
  feature_layer_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::SpatialCameraSetup* InterfaceOptions::mutable_feature_layer() {
  set_has_feature_layer();
  if (feature_layer_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::SpatialCameraSetup>(GetArenaNoVirtual());
    feature_layer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.InterfaceOptions.feature_layer)
  return feature_layer_;
}
inline void InterfaceOptions::set_allocated_feature_layer(::SCRAPIProtocol::SpatialCameraSetup* feature_layer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete feature_layer_;
  }
  if (feature_layer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature_layer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature_layer, submessage_arena);
    }
    set_has_feature_layer();
  } else {
    clear_has_feature_layer();
  }
  feature_layer_ = feature_layer;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.InterfaceOptions.feature_layer)
}

// optional .SCRAPIProtocol.SpatialCameraSetup render = 4;
inline bool InterfaceOptions::has_render() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InterfaceOptions::set_has_render() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InterfaceOptions::clear_has_render() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InterfaceOptions::clear_render() {
  if (render_ != NULL) render_->Clear();
  clear_has_render();
}
inline const ::SCRAPIProtocol::SpatialCameraSetup& InterfaceOptions::_internal_render() const {
  return *render_;
}
inline const ::SCRAPIProtocol::SpatialCameraSetup& InterfaceOptions::render() const {
  const ::SCRAPIProtocol::SpatialCameraSetup* p = render_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.InterfaceOptions.render)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::SpatialCameraSetup*>(
      &::SCRAPIProtocol::_SpatialCameraSetup_default_instance_);
}
inline ::SCRAPIProtocol::SpatialCameraSetup* InterfaceOptions::release_render() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.InterfaceOptions.render)
  clear_has_render();
  ::SCRAPIProtocol::SpatialCameraSetup* temp = render_;
  render_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::SpatialCameraSetup* InterfaceOptions::mutable_render() {
  set_has_render();
  if (render_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::SpatialCameraSetup>(GetArenaNoVirtual());
    render_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.InterfaceOptions.render)
  return render_;
}
inline void InterfaceOptions::set_allocated_render(::SCRAPIProtocol::SpatialCameraSetup* render) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete render_;
  }
  if (render) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      render = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, render, submessage_arena);
    }
    set_has_render();
  } else {
    clear_has_render();
  }
  render_ = render;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.InterfaceOptions.render)
}

// -------------------------------------------------------------------

// PlayerInfo

// optional uint32 player_id = 1;
inline bool PlayerInfo::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfo::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfo::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfo::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerInfo::player_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerInfo.player_id)
  return player_id_;
}
inline void PlayerInfo::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerInfo.player_id)
}

// optional .SCRAPIProtocol.PlayerType type = 2;
inline bool PlayerInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SCRAPIProtocol::PlayerType PlayerInfo::type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerInfo.type)
  return static_cast< ::SCRAPIProtocol::PlayerType >(type_);
}
inline void PlayerInfo::set_type(::SCRAPIProtocol::PlayerType value) {
  assert(::SCRAPIProtocol::PlayerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerInfo.type)
}

// optional .SCRAPIProtocol.Race race_requested = 3;
inline bool PlayerInfo::has_race_requested() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfo::set_has_race_requested() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfo::clear_has_race_requested() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfo::clear_race_requested() {
  race_requested_ = 0;
  clear_has_race_requested();
}
inline ::SCRAPIProtocol::Race PlayerInfo::race_requested() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerInfo.race_requested)
  return static_cast< ::SCRAPIProtocol::Race >(race_requested_);
}
inline void PlayerInfo::set_race_requested(::SCRAPIProtocol::Race value) {
  assert(::SCRAPIProtocol::Race_IsValid(value));
  set_has_race_requested();
  race_requested_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerInfo.race_requested)
}

// optional .SCRAPIProtocol.Race race_actual = 4;
inline bool PlayerInfo::has_race_actual() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfo::set_has_race_actual() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfo::clear_has_race_actual() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfo::clear_race_actual() {
  race_actual_ = 0;
  clear_has_race_actual();
}
inline ::SCRAPIProtocol::Race PlayerInfo::race_actual() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerInfo.race_actual)
  return static_cast< ::SCRAPIProtocol::Race >(race_actual_);
}
inline void PlayerInfo::set_race_actual(::SCRAPIProtocol::Race value) {
  assert(::SCRAPIProtocol::Race_IsValid(value));
  set_has_race_actual();
  race_actual_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerInfo.race_actual)
}

// optional .SCRAPIProtocol.Difficulty difficulty = 5;
inline bool PlayerInfo::has_difficulty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerInfo::set_has_difficulty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerInfo::clear_has_difficulty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerInfo::clear_difficulty() {
  difficulty_ = 1;
  clear_has_difficulty();
}
inline ::SCRAPIProtocol::Difficulty PlayerInfo::difficulty() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerInfo.difficulty)
  return static_cast< ::SCRAPIProtocol::Difficulty >(difficulty_);
}
inline void PlayerInfo::set_difficulty(::SCRAPIProtocol::Difficulty value) {
  assert(::SCRAPIProtocol::Difficulty_IsValid(value));
  set_has_difficulty();
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerInfo.difficulty)
}

// -------------------------------------------------------------------

// PlayerCommon

// optional uint32 player_id = 1;
inline bool PlayerCommon::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCommon::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCommon::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCommon::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerCommon::player_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.player_id)
  return player_id_;
}
inline void PlayerCommon::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.player_id)
}

// optional uint32 minerals = 2;
inline bool PlayerCommon::has_minerals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCommon::set_has_minerals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCommon::clear_has_minerals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCommon::clear_minerals() {
  minerals_ = 0u;
  clear_has_minerals();
}
inline ::google::protobuf::uint32 PlayerCommon::minerals() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.minerals)
  return minerals_;
}
inline void PlayerCommon::set_minerals(::google::protobuf::uint32 value) {
  set_has_minerals();
  minerals_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.minerals)
}

// optional uint32 vespene = 3;
inline bool PlayerCommon::has_vespene() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerCommon::set_has_vespene() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerCommon::clear_has_vespene() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerCommon::clear_vespene() {
  vespene_ = 0u;
  clear_has_vespene();
}
inline ::google::protobuf::uint32 PlayerCommon::vespene() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.vespene)
  return vespene_;
}
inline void PlayerCommon::set_vespene(::google::protobuf::uint32 value) {
  set_has_vespene();
  vespene_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.vespene)
}

// optional uint32 food_cap = 4;
inline bool PlayerCommon::has_food_cap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerCommon::set_has_food_cap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerCommon::clear_has_food_cap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerCommon::clear_food_cap() {
  food_cap_ = 0u;
  clear_has_food_cap();
}
inline ::google::protobuf::uint32 PlayerCommon::food_cap() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.food_cap)
  return food_cap_;
}
inline void PlayerCommon::set_food_cap(::google::protobuf::uint32 value) {
  set_has_food_cap();
  food_cap_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.food_cap)
}

// optional uint32 food_used = 5;
inline bool PlayerCommon::has_food_used() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerCommon::set_has_food_used() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerCommon::clear_has_food_used() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerCommon::clear_food_used() {
  food_used_ = 0u;
  clear_has_food_used();
}
inline ::google::protobuf::uint32 PlayerCommon::food_used() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.food_used)
  return food_used_;
}
inline void PlayerCommon::set_food_used(::google::protobuf::uint32 value) {
  set_has_food_used();
  food_used_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.food_used)
}

// optional uint32 food_army = 6;
inline bool PlayerCommon::has_food_army() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerCommon::set_has_food_army() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerCommon::clear_has_food_army() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerCommon::clear_food_army() {
  food_army_ = 0u;
  clear_has_food_army();
}
inline ::google::protobuf::uint32 PlayerCommon::food_army() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.food_army)
  return food_army_;
}
inline void PlayerCommon::set_food_army(::google::protobuf::uint32 value) {
  set_has_food_army();
  food_army_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.food_army)
}

// optional uint32 food_workers = 7;
inline bool PlayerCommon::has_food_workers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerCommon::set_has_food_workers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerCommon::clear_has_food_workers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerCommon::clear_food_workers() {
  food_workers_ = 0u;
  clear_has_food_workers();
}
inline ::google::protobuf::uint32 PlayerCommon::food_workers() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.food_workers)
  return food_workers_;
}
inline void PlayerCommon::set_food_workers(::google::protobuf::uint32 value) {
  set_has_food_workers();
  food_workers_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.food_workers)
}

// optional uint32 idle_worker_count = 8;
inline bool PlayerCommon::has_idle_worker_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerCommon::set_has_idle_worker_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerCommon::clear_has_idle_worker_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerCommon::clear_idle_worker_count() {
  idle_worker_count_ = 0u;
  clear_has_idle_worker_count();
}
inline ::google::protobuf::uint32 PlayerCommon::idle_worker_count() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.idle_worker_count)
  return idle_worker_count_;
}
inline void PlayerCommon::set_idle_worker_count(::google::protobuf::uint32 value) {
  set_has_idle_worker_count();
  idle_worker_count_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.idle_worker_count)
}

// optional uint32 army_count = 9;
inline bool PlayerCommon::has_army_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerCommon::set_has_army_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerCommon::clear_has_army_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerCommon::clear_army_count() {
  army_count_ = 0u;
  clear_has_army_count();
}
inline ::google::protobuf::uint32 PlayerCommon::army_count() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.army_count)
  return army_count_;
}
inline void PlayerCommon::set_army_count(::google::protobuf::uint32 value) {
  set_has_army_count();
  army_count_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.army_count)
}

// optional uint32 warp_gate_count = 10;
inline bool PlayerCommon::has_warp_gate_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerCommon::set_has_warp_gate_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerCommon::clear_has_warp_gate_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerCommon::clear_warp_gate_count() {
  warp_gate_count_ = 0u;
  clear_has_warp_gate_count();
}
inline ::google::protobuf::uint32 PlayerCommon::warp_gate_count() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.warp_gate_count)
  return warp_gate_count_;
}
inline void PlayerCommon::set_warp_gate_count(::google::protobuf::uint32 value) {
  set_has_warp_gate_count();
  warp_gate_count_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.warp_gate_count)
}

// optional uint32 larva_count = 11;
inline bool PlayerCommon::has_larva_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerCommon::set_has_larva_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerCommon::clear_has_larva_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerCommon::clear_larva_count() {
  larva_count_ = 0u;
  clear_has_larva_count();
}
inline ::google::protobuf::uint32 PlayerCommon::larva_count() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerCommon.larva_count)
  return larva_count_;
}
inline void PlayerCommon::set_larva_count(::google::protobuf::uint32 value) {
  set_has_larva_count();
  larva_count_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerCommon.larva_count)
}

// -------------------------------------------------------------------

// Observation

// optional uint32 game_loop = 9;
inline bool Observation::has_game_loop() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Observation::set_has_game_loop() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Observation::clear_has_game_loop() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Observation::clear_game_loop() {
  game_loop_ = 0u;
  clear_has_game_loop();
}
inline ::google::protobuf::uint32 Observation::game_loop() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Observation.game_loop)
  return game_loop_;
}
inline void Observation::set_game_loop(::google::protobuf::uint32 value) {
  set_has_game_loop();
  game_loop_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Observation.game_loop)
}

// optional .SCRAPIProtocol.PlayerCommon player_common = 1;
inline bool Observation::has_player_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Observation::set_has_player_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Observation::clear_has_player_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Observation::clear_player_common() {
  if (player_common_ != NULL) player_common_->Clear();
  clear_has_player_common();
}
inline const ::SCRAPIProtocol::PlayerCommon& Observation::_internal_player_common() const {
  return *player_common_;
}
inline const ::SCRAPIProtocol::PlayerCommon& Observation::player_common() const {
  const ::SCRAPIProtocol::PlayerCommon* p = player_common_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Observation.player_common)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::PlayerCommon*>(
      &::SCRAPIProtocol::_PlayerCommon_default_instance_);
}
inline ::SCRAPIProtocol::PlayerCommon* Observation::release_player_common() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Observation.player_common)
  clear_has_player_common();
  ::SCRAPIProtocol::PlayerCommon* temp = player_common_;
  player_common_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::PlayerCommon* Observation::mutable_player_common() {
  set_has_player_common();
  if (player_common_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::PlayerCommon>(GetArenaNoVirtual());
    player_common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Observation.player_common)
  return player_common_;
}
inline void Observation::set_allocated_player_common(::SCRAPIProtocol::PlayerCommon* player_common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_common_;
  }
  if (player_common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_common, submessage_arena);
    }
    set_has_player_common();
  } else {
    clear_has_player_common();
  }
  player_common_ = player_common;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Observation.player_common)
}

// repeated .SCRAPIProtocol.Alert alerts = 10;
inline int Observation::alerts_size() const {
  return alerts_.size();
}
inline void Observation::clear_alerts() {
  alerts_.Clear();
}
inline ::SCRAPIProtocol::Alert Observation::alerts(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Observation.alerts)
  return static_cast< ::SCRAPIProtocol::Alert >(alerts_.Get(index));
}
inline void Observation::set_alerts(int index, ::SCRAPIProtocol::Alert value) {
  assert(::SCRAPIProtocol::Alert_IsValid(value));
  alerts_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.Observation.alerts)
}
inline void Observation::add_alerts(::SCRAPIProtocol::Alert value) {
  assert(::SCRAPIProtocol::Alert_IsValid(value));
  alerts_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.Observation.alerts)
}
inline const ::google::protobuf::RepeatedField<int>&
Observation::alerts() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.Observation.alerts)
  return alerts_;
}
inline ::google::protobuf::RepeatedField<int>*
Observation::mutable_alerts() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.Observation.alerts)
  return &alerts_;
}

// repeated .SCRAPIProtocol.AvailableAbility abilities = 3;
inline int Observation::abilities_size() const {
  return abilities_.size();
}
inline ::SCRAPIProtocol::AvailableAbility* Observation::mutable_abilities(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Observation.abilities)
  return abilities_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::AvailableAbility >*
Observation::mutable_abilities() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.Observation.abilities)
  return &abilities_;
}
inline const ::SCRAPIProtocol::AvailableAbility& Observation::abilities(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Observation.abilities)
  return abilities_.Get(index);
}
inline ::SCRAPIProtocol::AvailableAbility* Observation::add_abilities() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.Observation.abilities)
  return abilities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::AvailableAbility >&
Observation::abilities() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.Observation.abilities)
  return abilities_;
}

// optional .SCRAPIProtocol.Score score = 4;
inline bool Observation::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Observation::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Observation::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::Score& Observation::_internal_score() const {
  return *score_;
}
inline const ::SCRAPIProtocol::Score& Observation::score() const {
  const ::SCRAPIProtocol::Score* p = score_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Observation.score)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Score*>(
      &::SCRAPIProtocol::_Score_default_instance_);
}
inline ::SCRAPIProtocol::Score* Observation::release_score() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Observation.score)
  clear_has_score();
  ::SCRAPIProtocol::Score* temp = score_;
  score_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Score* Observation::mutable_score() {
  set_has_score();
  if (score_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Score>(GetArenaNoVirtual());
    score_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Observation.score)
  return score_;
}
inline void Observation::set_allocated_score(::SCRAPIProtocol::Score* score) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(score_);
  }
  if (score) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      score = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, score, submessage_arena);
    }
    set_has_score();
  } else {
    clear_has_score();
  }
  score_ = score;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Observation.score)
}

// optional .SCRAPIProtocol.ObservationRaw raw_data = 5;
inline bool Observation::has_raw_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Observation::set_has_raw_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Observation::clear_has_raw_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SCRAPIProtocol::ObservationRaw& Observation::_internal_raw_data() const {
  return *raw_data_;
}
inline const ::SCRAPIProtocol::ObservationRaw& Observation::raw_data() const {
  const ::SCRAPIProtocol::ObservationRaw* p = raw_data_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Observation.raw_data)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ObservationRaw*>(
      &::SCRAPIProtocol::_ObservationRaw_default_instance_);
}
inline ::SCRAPIProtocol::ObservationRaw* Observation::release_raw_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Observation.raw_data)
  clear_has_raw_data();
  ::SCRAPIProtocol::ObservationRaw* temp = raw_data_;
  raw_data_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ObservationRaw* Observation::mutable_raw_data() {
  set_has_raw_data();
  if (raw_data_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ObservationRaw>(GetArenaNoVirtual());
    raw_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Observation.raw_data)
  return raw_data_;
}
inline void Observation::set_allocated_raw_data(::SCRAPIProtocol::ObservationRaw* raw_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(raw_data_);
  }
  if (raw_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      raw_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    set_has_raw_data();
  } else {
    clear_has_raw_data();
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Observation.raw_data)
}

// optional .SCRAPIProtocol.ObservationFeatureLayer feature_layer_data = 6;
inline bool Observation::has_feature_layer_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Observation::set_has_feature_layer_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Observation::clear_has_feature_layer_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::SCRAPIProtocol::ObservationFeatureLayer& Observation::_internal_feature_layer_data() const {
  return *feature_layer_data_;
}
inline const ::SCRAPIProtocol::ObservationFeatureLayer& Observation::feature_layer_data() const {
  const ::SCRAPIProtocol::ObservationFeatureLayer* p = feature_layer_data_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Observation.feature_layer_data)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ObservationFeatureLayer*>(
      &::SCRAPIProtocol::_ObservationFeatureLayer_default_instance_);
}
inline ::SCRAPIProtocol::ObservationFeatureLayer* Observation::release_feature_layer_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Observation.feature_layer_data)
  clear_has_feature_layer_data();
  ::SCRAPIProtocol::ObservationFeatureLayer* temp = feature_layer_data_;
  feature_layer_data_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ObservationFeatureLayer* Observation::mutable_feature_layer_data() {
  set_has_feature_layer_data();
  if (feature_layer_data_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ObservationFeatureLayer>(GetArenaNoVirtual());
    feature_layer_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Observation.feature_layer_data)
  return feature_layer_data_;
}
inline void Observation::set_allocated_feature_layer_data(::SCRAPIProtocol::ObservationFeatureLayer* feature_layer_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(feature_layer_data_);
  }
  if (feature_layer_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature_layer_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature_layer_data, submessage_arena);
    }
    set_has_feature_layer_data();
  } else {
    clear_has_feature_layer_data();
  }
  feature_layer_data_ = feature_layer_data;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Observation.feature_layer_data)
}

// optional .SCRAPIProtocol.ObservationRender render_data = 7;
inline bool Observation::has_render_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Observation::set_has_render_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Observation::clear_has_render_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::SCRAPIProtocol::ObservationRender& Observation::_internal_render_data() const {
  return *render_data_;
}
inline const ::SCRAPIProtocol::ObservationRender& Observation::render_data() const {
  const ::SCRAPIProtocol::ObservationRender* p = render_data_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Observation.render_data)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ObservationRender*>(
      &::SCRAPIProtocol::_ObservationRender_default_instance_);
}
inline ::SCRAPIProtocol::ObservationRender* Observation::release_render_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Observation.render_data)
  clear_has_render_data();
  ::SCRAPIProtocol::ObservationRender* temp = render_data_;
  render_data_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ObservationRender* Observation::mutable_render_data() {
  set_has_render_data();
  if (render_data_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ObservationRender>(GetArenaNoVirtual());
    render_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Observation.render_data)
  return render_data_;
}
inline void Observation::set_allocated_render_data(::SCRAPIProtocol::ObservationRender* render_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(render_data_);
  }
  if (render_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      render_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, render_data, submessage_arena);
    }
    set_has_render_data();
  } else {
    clear_has_render_data();
  }
  render_data_ = render_data;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Observation.render_data)
}

// optional .SCRAPIProtocol.ObservationUI ui_data = 8;
inline bool Observation::has_ui_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Observation::set_has_ui_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Observation::clear_has_ui_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::SCRAPIProtocol::ObservationUI& Observation::_internal_ui_data() const {
  return *ui_data_;
}
inline const ::SCRAPIProtocol::ObservationUI& Observation::ui_data() const {
  const ::SCRAPIProtocol::ObservationUI* p = ui_data_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Observation.ui_data)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ObservationUI*>(
      &::SCRAPIProtocol::_ObservationUI_default_instance_);
}
inline ::SCRAPIProtocol::ObservationUI* Observation::release_ui_data() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Observation.ui_data)
  clear_has_ui_data();
  ::SCRAPIProtocol::ObservationUI* temp = ui_data_;
  ui_data_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ObservationUI* Observation::mutable_ui_data() {
  set_has_ui_data();
  if (ui_data_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ObservationUI>(GetArenaNoVirtual());
    ui_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Observation.ui_data)
  return ui_data_;
}
inline void Observation::set_allocated_ui_data(::SCRAPIProtocol::ObservationUI* ui_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ui_data_);
  }
  if (ui_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ui_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ui_data, submessage_arena);
    }
    set_has_ui_data();
  } else {
    clear_has_ui_data();
  }
  ui_data_ = ui_data;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Observation.ui_data)
}

// -------------------------------------------------------------------

// Action

// optional .SCRAPIProtocol.ActionRaw action_raw = 1;
inline bool Action::has_action_raw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Action::set_has_action_raw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Action::clear_has_action_raw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::ActionRaw& Action::_internal_action_raw() const {
  return *action_raw_;
}
inline const ::SCRAPIProtocol::ActionRaw& Action::action_raw() const {
  const ::SCRAPIProtocol::ActionRaw* p = action_raw_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Action.action_raw)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ActionRaw*>(
      &::SCRAPIProtocol::_ActionRaw_default_instance_);
}
inline ::SCRAPIProtocol::ActionRaw* Action::release_action_raw() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Action.action_raw)
  clear_has_action_raw();
  ::SCRAPIProtocol::ActionRaw* temp = action_raw_;
  action_raw_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ActionRaw* Action::mutable_action_raw() {
  set_has_action_raw();
  if (action_raw_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ActionRaw>(GetArenaNoVirtual());
    action_raw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Action.action_raw)
  return action_raw_;
}
inline void Action::set_allocated_action_raw(::SCRAPIProtocol::ActionRaw* action_raw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(action_raw_);
  }
  if (action_raw) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action_raw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action_raw, submessage_arena);
    }
    set_has_action_raw();
  } else {
    clear_has_action_raw();
  }
  action_raw_ = action_raw;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Action.action_raw)
}

// optional .SCRAPIProtocol.ActionSpatial action_feature_layer = 2;
inline bool Action::has_action_feature_layer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Action::set_has_action_feature_layer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Action::clear_has_action_feature_layer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::ActionSpatial& Action::_internal_action_feature_layer() const {
  return *action_feature_layer_;
}
inline const ::SCRAPIProtocol::ActionSpatial& Action::action_feature_layer() const {
  const ::SCRAPIProtocol::ActionSpatial* p = action_feature_layer_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Action.action_feature_layer)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ActionSpatial*>(
      &::SCRAPIProtocol::_ActionSpatial_default_instance_);
}
inline ::SCRAPIProtocol::ActionSpatial* Action::release_action_feature_layer() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Action.action_feature_layer)
  clear_has_action_feature_layer();
  ::SCRAPIProtocol::ActionSpatial* temp = action_feature_layer_;
  action_feature_layer_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ActionSpatial* Action::mutable_action_feature_layer() {
  set_has_action_feature_layer();
  if (action_feature_layer_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ActionSpatial>(GetArenaNoVirtual());
    action_feature_layer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Action.action_feature_layer)
  return action_feature_layer_;
}
inline void Action::set_allocated_action_feature_layer(::SCRAPIProtocol::ActionSpatial* action_feature_layer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(action_feature_layer_);
  }
  if (action_feature_layer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action_feature_layer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action_feature_layer, submessage_arena);
    }
    set_has_action_feature_layer();
  } else {
    clear_has_action_feature_layer();
  }
  action_feature_layer_ = action_feature_layer;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Action.action_feature_layer)
}

// optional .SCRAPIProtocol.ActionSpatial action_render = 3;
inline bool Action::has_action_render() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Action::set_has_action_render() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Action::clear_has_action_render() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SCRAPIProtocol::ActionSpatial& Action::_internal_action_render() const {
  return *action_render_;
}
inline const ::SCRAPIProtocol::ActionSpatial& Action::action_render() const {
  const ::SCRAPIProtocol::ActionSpatial* p = action_render_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Action.action_render)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ActionSpatial*>(
      &::SCRAPIProtocol::_ActionSpatial_default_instance_);
}
inline ::SCRAPIProtocol::ActionSpatial* Action::release_action_render() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Action.action_render)
  clear_has_action_render();
  ::SCRAPIProtocol::ActionSpatial* temp = action_render_;
  action_render_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ActionSpatial* Action::mutable_action_render() {
  set_has_action_render();
  if (action_render_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ActionSpatial>(GetArenaNoVirtual());
    action_render_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Action.action_render)
  return action_render_;
}
inline void Action::set_allocated_action_render(::SCRAPIProtocol::ActionSpatial* action_render) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(action_render_);
  }
  if (action_render) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action_render = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action_render, submessage_arena);
    }
    set_has_action_render();
  } else {
    clear_has_action_render();
  }
  action_render_ = action_render;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Action.action_render)
}

// optional .SCRAPIProtocol.ActionUI action_ui = 4;
inline bool Action::has_action_ui() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Action::set_has_action_ui() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Action::clear_has_action_ui() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::SCRAPIProtocol::ActionUI& Action::_internal_action_ui() const {
  return *action_ui_;
}
inline const ::SCRAPIProtocol::ActionUI& Action::action_ui() const {
  const ::SCRAPIProtocol::ActionUI* p = action_ui_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Action.action_ui)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ActionUI*>(
      &::SCRAPIProtocol::_ActionUI_default_instance_);
}
inline ::SCRAPIProtocol::ActionUI* Action::release_action_ui() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Action.action_ui)
  clear_has_action_ui();
  ::SCRAPIProtocol::ActionUI* temp = action_ui_;
  action_ui_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ActionUI* Action::mutable_action_ui() {
  set_has_action_ui();
  if (action_ui_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ActionUI>(GetArenaNoVirtual());
    action_ui_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Action.action_ui)
  return action_ui_;
}
inline void Action::set_allocated_action_ui(::SCRAPIProtocol::ActionUI* action_ui) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(action_ui_);
  }
  if (action_ui) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action_ui = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action_ui, submessage_arena);
    }
    set_has_action_ui();
  } else {
    clear_has_action_ui();
  }
  action_ui_ = action_ui;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Action.action_ui)
}

// optional .SCRAPIProtocol.ActionChat action_chat = 6;
inline bool Action::has_action_chat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Action::set_has_action_chat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Action::clear_has_action_chat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Action::clear_action_chat() {
  if (action_chat_ != NULL) action_chat_->Clear();
  clear_has_action_chat();
}
inline const ::SCRAPIProtocol::ActionChat& Action::_internal_action_chat() const {
  return *action_chat_;
}
inline const ::SCRAPIProtocol::ActionChat& Action::action_chat() const {
  const ::SCRAPIProtocol::ActionChat* p = action_chat_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.Action.action_chat)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ActionChat*>(
      &::SCRAPIProtocol::_ActionChat_default_instance_);
}
inline ::SCRAPIProtocol::ActionChat* Action::release_action_chat() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.Action.action_chat)
  clear_has_action_chat();
  ::SCRAPIProtocol::ActionChat* temp = action_chat_;
  action_chat_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ActionChat* Action::mutable_action_chat() {
  set_has_action_chat();
  if (action_chat_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ActionChat>(GetArenaNoVirtual());
    action_chat_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.Action.action_chat)
  return action_chat_;
}
inline void Action::set_allocated_action_chat(::SCRAPIProtocol::ActionChat* action_chat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete action_chat_;
  }
  if (action_chat) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action_chat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action_chat, submessage_arena);
    }
    set_has_action_chat();
  } else {
    clear_has_action_chat();
  }
  action_chat_ = action_chat;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.Action.action_chat)
}

// -------------------------------------------------------------------

// ActionChat

// optional .SCRAPIProtocol.ActionChat.Channel channel = 1;
inline bool ActionChat::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionChat::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionChat::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionChat::clear_channel() {
  channel_ = 1;
  clear_has_channel();
}
inline ::SCRAPIProtocol::ActionChat_Channel ActionChat::channel() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionChat.channel)
  return static_cast< ::SCRAPIProtocol::ActionChat_Channel >(channel_);
}
inline void ActionChat::set_channel(::SCRAPIProtocol::ActionChat_Channel value) {
  assert(::SCRAPIProtocol::ActionChat_Channel_IsValid(value));
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionChat.channel)
}

// optional string message = 2;
inline bool ActionChat::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionChat::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionChat::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionChat::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ActionChat::message() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionChat.message)
  return message_.GetNoArena();
}
inline void ActionChat::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionChat.message)
}
#if LANG_CXX11
inline void ActionChat::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SCRAPIProtocol.ActionChat.message)
}
#endif
inline void ActionChat::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SCRAPIProtocol.ActionChat.message)
}
inline void ActionChat::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SCRAPIProtocol.ActionChat.message)
}
inline ::std::string* ActionChat::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionChat.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionChat::release_message() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionChat.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionChat::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ActionChat.message)
}

// -------------------------------------------------------------------

// ActionError

// optional uint64 unit_tag = 1;
inline bool ActionError::has_unit_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionError::set_has_unit_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionError::clear_has_unit_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionError::clear_unit_tag() {
  unit_tag_ = GOOGLE_ULONGLONG(0);
  clear_has_unit_tag();
}
inline ::google::protobuf::uint64 ActionError::unit_tag() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionError.unit_tag)
  return unit_tag_;
}
inline void ActionError::set_unit_tag(::google::protobuf::uint64 value) {
  set_has_unit_tag();
  unit_tag_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionError.unit_tag)
}

// optional uint64 ability_id = 2;
inline bool ActionError::has_ability_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionError::set_has_ability_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionError::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionError::clear_ability_id() {
  ability_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ability_id();
}
inline ::google::protobuf::uint64 ActionError::ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionError.ability_id)
  return ability_id_;
}
inline void ActionError::set_ability_id(::google::protobuf::uint64 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionError.ability_id)
}

// optional .SCRAPIProtocol.ActionResult result = 3;
inline bool ActionError::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActionError::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActionError::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActionError::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::SCRAPIProtocol::ActionResult ActionError::result() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionError.result)
  return static_cast< ::SCRAPIProtocol::ActionResult >(result_);
}
inline void ActionError::set_result(::SCRAPIProtocol::ActionResult value) {
  assert(::SCRAPIProtocol::ActionResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionError.result)
}

// -------------------------------------------------------------------

// ObserverAction

// optional .SCRAPIProtocol.ActionObserverPlayerPerspective player_perspective = 1;
inline bool ObserverAction::has_player_perspective() const {
  return action_case() == kPlayerPerspective;
}
inline void ObserverAction::set_has_player_perspective() {
  _oneof_case_[0] = kPlayerPerspective;
}
inline void ObserverAction::clear_player_perspective() {
  if (has_player_perspective()) {
    delete action_.player_perspective_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionObserverPlayerPerspective& ObserverAction::_internal_player_perspective() const {
  return *action_.player_perspective_;
}
inline ::SCRAPIProtocol::ActionObserverPlayerPerspective* ObserverAction::release_player_perspective() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObserverAction.player_perspective)
  if (has_player_perspective()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionObserverPlayerPerspective* temp = action_.player_perspective_;
    action_.player_perspective_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionObserverPlayerPerspective& ObserverAction::player_perspective() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObserverAction.player_perspective)
  return has_player_perspective()
      ? *action_.player_perspective_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionObserverPlayerPerspective*>(&::SCRAPIProtocol::_ActionObserverPlayerPerspective_default_instance_);
}
inline ::SCRAPIProtocol::ActionObserverPlayerPerspective* ObserverAction::mutable_player_perspective() {
  if (!has_player_perspective()) {
    clear_action();
    set_has_player_perspective();
    action_.player_perspective_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionObserverPlayerPerspective >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObserverAction.player_perspective)
  return action_.player_perspective_;
}

// optional .SCRAPIProtocol.ActionObserverCameraMove camera_move = 2;
inline bool ObserverAction::has_camera_move() const {
  return action_case() == kCameraMove;
}
inline void ObserverAction::set_has_camera_move() {
  _oneof_case_[0] = kCameraMove;
}
inline void ObserverAction::clear_camera_move() {
  if (has_camera_move()) {
    delete action_.camera_move_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionObserverCameraMove& ObserverAction::_internal_camera_move() const {
  return *action_.camera_move_;
}
inline ::SCRAPIProtocol::ActionObserverCameraMove* ObserverAction::release_camera_move() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObserverAction.camera_move)
  if (has_camera_move()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionObserverCameraMove* temp = action_.camera_move_;
    action_.camera_move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionObserverCameraMove& ObserverAction::camera_move() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObserverAction.camera_move)
  return has_camera_move()
      ? *action_.camera_move_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionObserverCameraMove*>(&::SCRAPIProtocol::_ActionObserverCameraMove_default_instance_);
}
inline ::SCRAPIProtocol::ActionObserverCameraMove* ObserverAction::mutable_camera_move() {
  if (!has_camera_move()) {
    clear_action();
    set_has_camera_move();
    action_.camera_move_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionObserverCameraMove >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObserverAction.camera_move)
  return action_.camera_move_;
}

// optional .SCRAPIProtocol.ActionObserverCameraFollowPlayer camera_follow_player = 3;
inline bool ObserverAction::has_camera_follow_player() const {
  return action_case() == kCameraFollowPlayer;
}
inline void ObserverAction::set_has_camera_follow_player() {
  _oneof_case_[0] = kCameraFollowPlayer;
}
inline void ObserverAction::clear_camera_follow_player() {
  if (has_camera_follow_player()) {
    delete action_.camera_follow_player_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionObserverCameraFollowPlayer& ObserverAction::_internal_camera_follow_player() const {
  return *action_.camera_follow_player_;
}
inline ::SCRAPIProtocol::ActionObserverCameraFollowPlayer* ObserverAction::release_camera_follow_player() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObserverAction.camera_follow_player)
  if (has_camera_follow_player()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionObserverCameraFollowPlayer* temp = action_.camera_follow_player_;
    action_.camera_follow_player_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionObserverCameraFollowPlayer& ObserverAction::camera_follow_player() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObserverAction.camera_follow_player)
  return has_camera_follow_player()
      ? *action_.camera_follow_player_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionObserverCameraFollowPlayer*>(&::SCRAPIProtocol::_ActionObserverCameraFollowPlayer_default_instance_);
}
inline ::SCRAPIProtocol::ActionObserverCameraFollowPlayer* ObserverAction::mutable_camera_follow_player() {
  if (!has_camera_follow_player()) {
    clear_action();
    set_has_camera_follow_player();
    action_.camera_follow_player_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionObserverCameraFollowPlayer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObserverAction.camera_follow_player)
  return action_.camera_follow_player_;
}

// optional .SCRAPIProtocol.ActionObserverCameraFollowUnits camera_follow_units = 4;
inline bool ObserverAction::has_camera_follow_units() const {
  return action_case() == kCameraFollowUnits;
}
inline void ObserverAction::set_has_camera_follow_units() {
  _oneof_case_[0] = kCameraFollowUnits;
}
inline void ObserverAction::clear_camera_follow_units() {
  if (has_camera_follow_units()) {
    delete action_.camera_follow_units_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionObserverCameraFollowUnits& ObserverAction::_internal_camera_follow_units() const {
  return *action_.camera_follow_units_;
}
inline ::SCRAPIProtocol::ActionObserverCameraFollowUnits* ObserverAction::release_camera_follow_units() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObserverAction.camera_follow_units)
  if (has_camera_follow_units()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionObserverCameraFollowUnits* temp = action_.camera_follow_units_;
    action_.camera_follow_units_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionObserverCameraFollowUnits& ObserverAction::camera_follow_units() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObserverAction.camera_follow_units)
  return has_camera_follow_units()
      ? *action_.camera_follow_units_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionObserverCameraFollowUnits*>(&::SCRAPIProtocol::_ActionObserverCameraFollowUnits_default_instance_);
}
inline ::SCRAPIProtocol::ActionObserverCameraFollowUnits* ObserverAction::mutable_camera_follow_units() {
  if (!has_camera_follow_units()) {
    clear_action();
    set_has_camera_follow_units();
    action_.camera_follow_units_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionObserverCameraFollowUnits >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObserverAction.camera_follow_units)
  return action_.camera_follow_units_;
}

inline bool ObserverAction::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ObserverAction::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ObserverAction::ActionCase ObserverAction::action_case() const {
  return ObserverAction::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionObserverPlayerPerspective

// optional uint32 player_id = 1;
inline bool ActionObserverPlayerPerspective::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionObserverPlayerPerspective::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionObserverPlayerPerspective::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionObserverPlayerPerspective::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ActionObserverPlayerPerspective::player_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionObserverPlayerPerspective.player_id)
  return player_id_;
}
inline void ActionObserverPlayerPerspective::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionObserverPlayerPerspective.player_id)
}

// -------------------------------------------------------------------

// ActionObserverCameraMove

// optional .SCRAPIProtocol.Point2D world_pos = 1;
inline bool ActionObserverCameraMove::has_world_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionObserverCameraMove::set_has_world_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionObserverCameraMove::clear_has_world_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::Point2D& ActionObserverCameraMove::_internal_world_pos() const {
  return *world_pos_;
}
inline const ::SCRAPIProtocol::Point2D& ActionObserverCameraMove::world_pos() const {
  const ::SCRAPIProtocol::Point2D* p = world_pos_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionObserverCameraMove.world_pos)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::Point2D*>(
      &::SCRAPIProtocol::_Point2D_default_instance_);
}
inline ::SCRAPIProtocol::Point2D* ActionObserverCameraMove::release_world_pos() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionObserverCameraMove.world_pos)
  clear_has_world_pos();
  ::SCRAPIProtocol::Point2D* temp = world_pos_;
  world_pos_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::Point2D* ActionObserverCameraMove::mutable_world_pos() {
  set_has_world_pos();
  if (world_pos_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::Point2D>(GetArenaNoVirtual());
    world_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionObserverCameraMove.world_pos)
  return world_pos_;
}
inline void ActionObserverCameraMove::set_allocated_world_pos(::SCRAPIProtocol::Point2D* world_pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(world_pos_);
  }
  if (world_pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_pos, submessage_arena);
    }
    set_has_world_pos();
  } else {
    clear_has_world_pos();
  }
  world_pos_ = world_pos;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ActionObserverCameraMove.world_pos)
}

// optional float distance = 2;
inline bool ActionObserverCameraMove::has_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionObserverCameraMove::set_has_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionObserverCameraMove::clear_has_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionObserverCameraMove::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float ActionObserverCameraMove::distance() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionObserverCameraMove.distance)
  return distance_;
}
inline void ActionObserverCameraMove::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionObserverCameraMove.distance)
}

// -------------------------------------------------------------------

// ActionObserverCameraFollowPlayer

// optional uint32 player_id = 1;
inline bool ActionObserverCameraFollowPlayer::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionObserverCameraFollowPlayer::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionObserverCameraFollowPlayer::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionObserverCameraFollowPlayer::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ActionObserverCameraFollowPlayer::player_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionObserverCameraFollowPlayer.player_id)
  return player_id_;
}
inline void ActionObserverCameraFollowPlayer::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionObserverCameraFollowPlayer.player_id)
}

// -------------------------------------------------------------------

// ActionObserverCameraFollowUnits

// repeated uint64 unit_tags = 1;
inline int ActionObserverCameraFollowUnits::unit_tags_size() const {
  return unit_tags_.size();
}
inline void ActionObserverCameraFollowUnits::clear_unit_tags() {
  unit_tags_.Clear();
}
inline ::google::protobuf::uint64 ActionObserverCameraFollowUnits::unit_tags(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionObserverCameraFollowUnits.unit_tags)
  return unit_tags_.Get(index);
}
inline void ActionObserverCameraFollowUnits::set_unit_tags(int index, ::google::protobuf::uint64 value) {
  unit_tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionObserverCameraFollowUnits.unit_tags)
}
inline void ActionObserverCameraFollowUnits::add_unit_tags(::google::protobuf::uint64 value) {
  unit_tags_.Add(value);
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ActionObserverCameraFollowUnits.unit_tags)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ActionObserverCameraFollowUnits::unit_tags() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ActionObserverCameraFollowUnits.unit_tags)
  return unit_tags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ActionObserverCameraFollowUnits::mutable_unit_tags() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ActionObserverCameraFollowUnits.unit_tags)
  return &unit_tags_;
}

// -------------------------------------------------------------------

// PlayerResult

// optional uint32 player_id = 1;
inline bool PlayerResult::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerResult::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerResult::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerResult::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerResult::player_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerResult.player_id)
  return player_id_;
}
inline void PlayerResult::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerResult.player_id)
}

// optional .SCRAPIProtocol.Result result = 2;
inline bool PlayerResult::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerResult::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerResult::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::SCRAPIProtocol::Result PlayerResult::result() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.PlayerResult.result)
  return static_cast< ::SCRAPIProtocol::Result >(result_);
}
inline void PlayerResult::set_result(::SCRAPIProtocol::Result value) {
  assert(::SCRAPIProtocol::Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.PlayerResult.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SCRAPIProtocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SCRAPIProtocol::ResponseCreateGame_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ResponseCreateGame_Error>() {
  return ::SCRAPIProtocol::ResponseCreateGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::ResponseJoinGame_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ResponseJoinGame_Error>() {
  return ::SCRAPIProtocol::ResponseJoinGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::ResponseRestartGame_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ResponseRestartGame_Error>() {
  return ::SCRAPIProtocol::ResponseRestartGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::ResponseStartReplay_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ResponseStartReplay_Error>() {
  return ::SCRAPIProtocol::ResponseStartReplay_Error_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::ResponseReplayInfo_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ResponseReplayInfo_Error>() {
  return ::SCRAPIProtocol::ResponseReplayInfo_Error_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::ResponseSaveMap_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ResponseSaveMap_Error>() {
  return ::SCRAPIProtocol::ResponseSaveMap_Error_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::ActionChat_Channel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ActionChat_Channel>() {
  return ::SCRAPIProtocol::ActionChat_Channel_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::Status>() {
  return ::SCRAPIProtocol::Status_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::Difficulty> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::Difficulty>() {
  return ::SCRAPIProtocol::Difficulty_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::PlayerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::PlayerType>() {
  return ::SCRAPIProtocol::PlayerType_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::Alert> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::Alert>() {
  return ::SCRAPIProtocol::Alert_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::Result>() {
  return ::SCRAPIProtocol::Result_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_scrapi_2eproto
