// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spatial.proto

#ifndef PROTOBUF_INCLUDED_spatial_2eproto
#define PROTOBUF_INCLUDED_spatial_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_spatial_2eproto 

namespace protobuf_spatial_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_spatial_2eproto
namespace SCRAPIProtocol {
class ActionSpatial;
class ActionSpatialDefaultTypeInternal;
extern ActionSpatialDefaultTypeInternal _ActionSpatial_default_instance_;
class ActionSpatialCameraMove;
class ActionSpatialCameraMoveDefaultTypeInternal;
extern ActionSpatialCameraMoveDefaultTypeInternal _ActionSpatialCameraMove_default_instance_;
class ActionSpatialUnitCommand;
class ActionSpatialUnitCommandDefaultTypeInternal;
extern ActionSpatialUnitCommandDefaultTypeInternal _ActionSpatialUnitCommand_default_instance_;
class ActionSpatialUnitSelectionPoint;
class ActionSpatialUnitSelectionPointDefaultTypeInternal;
extern ActionSpatialUnitSelectionPointDefaultTypeInternal _ActionSpatialUnitSelectionPoint_default_instance_;
class ActionSpatialUnitSelectionRect;
class ActionSpatialUnitSelectionRectDefaultTypeInternal;
extern ActionSpatialUnitSelectionRectDefaultTypeInternal _ActionSpatialUnitSelectionRect_default_instance_;
class FeatureLayers;
class FeatureLayersDefaultTypeInternal;
extern FeatureLayersDefaultTypeInternal _FeatureLayers_default_instance_;
class FeatureLayersMinimap;
class FeatureLayersMinimapDefaultTypeInternal;
extern FeatureLayersMinimapDefaultTypeInternal _FeatureLayersMinimap_default_instance_;
class ObservationFeatureLayer;
class ObservationFeatureLayerDefaultTypeInternal;
extern ObservationFeatureLayerDefaultTypeInternal _ObservationFeatureLayer_default_instance_;
class ObservationRender;
class ObservationRenderDefaultTypeInternal;
extern ObservationRenderDefaultTypeInternal _ObservationRender_default_instance_;
}  // namespace SCRAPIProtocol
namespace google {
namespace protobuf {
template<> ::SCRAPIProtocol::ActionSpatial* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionSpatial>(Arena*);
template<> ::SCRAPIProtocol::ActionSpatialCameraMove* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionSpatialCameraMove>(Arena*);
template<> ::SCRAPIProtocol::ActionSpatialUnitCommand* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionSpatialUnitCommand>(Arena*);
template<> ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionSpatialUnitSelectionPoint>(Arena*);
template<> ::SCRAPIProtocol::ActionSpatialUnitSelectionRect* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionSpatialUnitSelectionRect>(Arena*);
template<> ::SCRAPIProtocol::FeatureLayers* Arena::CreateMaybeMessage<::SCRAPIProtocol::FeatureLayers>(Arena*);
template<> ::SCRAPIProtocol::FeatureLayersMinimap* Arena::CreateMaybeMessage<::SCRAPIProtocol::FeatureLayersMinimap>(Arena*);
template<> ::SCRAPIProtocol::ObservationFeatureLayer* Arena::CreateMaybeMessage<::SCRAPIProtocol::ObservationFeatureLayer>(Arena*);
template<> ::SCRAPIProtocol::ObservationRender* Arena::CreateMaybeMessage<::SCRAPIProtocol::ObservationRender>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace SCRAPIProtocol {

enum ActionSpatialUnitSelectionPoint_Type {
  ActionSpatialUnitSelectionPoint_Type_Select = 1,
  ActionSpatialUnitSelectionPoint_Type_Toggle = 2,
  ActionSpatialUnitSelectionPoint_Type_AllType = 3,
  ActionSpatialUnitSelectionPoint_Type_AddAllType = 4
};
bool ActionSpatialUnitSelectionPoint_Type_IsValid(int value);
const ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint_Type_Type_MIN = ActionSpatialUnitSelectionPoint_Type_Select;
const ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint_Type_Type_MAX = ActionSpatialUnitSelectionPoint_Type_AddAllType;
const int ActionSpatialUnitSelectionPoint_Type_Type_ARRAYSIZE = ActionSpatialUnitSelectionPoint_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionSpatialUnitSelectionPoint_Type_descriptor();
inline const ::std::string& ActionSpatialUnitSelectionPoint_Type_Name(ActionSpatialUnitSelectionPoint_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionSpatialUnitSelectionPoint_Type_descriptor(), value);
}
inline bool ActionSpatialUnitSelectionPoint_Type_Parse(
    const ::std::string& name, ActionSpatialUnitSelectionPoint_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionSpatialUnitSelectionPoint_Type>(
    ActionSpatialUnitSelectionPoint_Type_descriptor(), name, value);
}
// ===================================================================

class ObservationFeatureLayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ObservationFeatureLayer) */ {
 public:
  ObservationFeatureLayer();
  virtual ~ObservationFeatureLayer();

  ObservationFeatureLayer(const ObservationFeatureLayer& from);

  inline ObservationFeatureLayer& operator=(const ObservationFeatureLayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObservationFeatureLayer(ObservationFeatureLayer&& from) noexcept
    : ObservationFeatureLayer() {
    *this = ::std::move(from);
  }

  inline ObservationFeatureLayer& operator=(ObservationFeatureLayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObservationFeatureLayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObservationFeatureLayer* internal_default_instance() {
    return reinterpret_cast<const ObservationFeatureLayer*>(
               &_ObservationFeatureLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ObservationFeatureLayer* other);
  friend void swap(ObservationFeatureLayer& a, ObservationFeatureLayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObservationFeatureLayer* New() const final {
    return CreateMaybeMessage<ObservationFeatureLayer>(NULL);
  }

  ObservationFeatureLayer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObservationFeatureLayer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObservationFeatureLayer& from);
  void MergeFrom(const ObservationFeatureLayer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObservationFeatureLayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.FeatureLayers renders = 1;
  bool has_renders() const;
  void clear_renders();
  static const int kRendersFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::FeatureLayers& _internal_renders() const;
  public:
  const ::SCRAPIProtocol::FeatureLayers& renders() const;
  ::SCRAPIProtocol::FeatureLayers* release_renders();
  ::SCRAPIProtocol::FeatureLayers* mutable_renders();
  void set_allocated_renders(::SCRAPIProtocol::FeatureLayers* renders);

  // optional .SCRAPIProtocol.FeatureLayersMinimap minimap_renders = 2;
  bool has_minimap_renders() const;
  void clear_minimap_renders();
  static const int kMinimapRendersFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::FeatureLayersMinimap& _internal_minimap_renders() const;
  public:
  const ::SCRAPIProtocol::FeatureLayersMinimap& minimap_renders() const;
  ::SCRAPIProtocol::FeatureLayersMinimap* release_minimap_renders();
  ::SCRAPIProtocol::FeatureLayersMinimap* mutable_minimap_renders();
  void set_allocated_minimap_renders(::SCRAPIProtocol::FeatureLayersMinimap* minimap_renders);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ObservationFeatureLayer)
 private:
  void set_has_renders();
  void clear_has_renders();
  void set_has_minimap_renders();
  void clear_has_minimap_renders();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::FeatureLayers* renders_;
  ::SCRAPIProtocol::FeatureLayersMinimap* minimap_renders_;
  friend struct ::protobuf_spatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeatureLayers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.FeatureLayers) */ {
 public:
  FeatureLayers();
  virtual ~FeatureLayers();

  FeatureLayers(const FeatureLayers& from);

  inline FeatureLayers& operator=(const FeatureLayers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeatureLayers(FeatureLayers&& from) noexcept
    : FeatureLayers() {
    *this = ::std::move(from);
  }

  inline FeatureLayers& operator=(FeatureLayers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureLayers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureLayers* internal_default_instance() {
    return reinterpret_cast<const FeatureLayers*>(
               &_FeatureLayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FeatureLayers* other);
  friend void swap(FeatureLayers& a, FeatureLayers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeatureLayers* New() const final {
    return CreateMaybeMessage<FeatureLayers>(NULL);
  }

  FeatureLayers* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FeatureLayers>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FeatureLayers& from);
  void MergeFrom(const FeatureLayers& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureLayers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ImageData height_map = 1;
  bool has_height_map() const;
  void clear_height_map();
  static const int kHeightMapFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_height_map() const;
  public:
  const ::SCRAPIProtocol::ImageData& height_map() const;
  ::SCRAPIProtocol::ImageData* release_height_map();
  ::SCRAPIProtocol::ImageData* mutable_height_map();
  void set_allocated_height_map(::SCRAPIProtocol::ImageData* height_map);

  // optional .SCRAPIProtocol.ImageData visibility_map = 2;
  bool has_visibility_map() const;
  void clear_visibility_map();
  static const int kVisibilityMapFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_visibility_map() const;
  public:
  const ::SCRAPIProtocol::ImageData& visibility_map() const;
  ::SCRAPIProtocol::ImageData* release_visibility_map();
  ::SCRAPIProtocol::ImageData* mutable_visibility_map();
  void set_allocated_visibility_map(::SCRAPIProtocol::ImageData* visibility_map);

  // optional .SCRAPIProtocol.ImageData creep = 3;
  bool has_creep() const;
  void clear_creep();
  static const int kCreepFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_creep() const;
  public:
  const ::SCRAPIProtocol::ImageData& creep() const;
  ::SCRAPIProtocol::ImageData* release_creep();
  ::SCRAPIProtocol::ImageData* mutable_creep();
  void set_allocated_creep(::SCRAPIProtocol::ImageData* creep);

  // optional .SCRAPIProtocol.ImageData power = 4;
  bool has_power() const;
  void clear_power();
  static const int kPowerFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_power() const;
  public:
  const ::SCRAPIProtocol::ImageData& power() const;
  ::SCRAPIProtocol::ImageData* release_power();
  ::SCRAPIProtocol::ImageData* mutable_power();
  void set_allocated_power(::SCRAPIProtocol::ImageData* power);

  // optional .SCRAPIProtocol.ImageData player_id = 5;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 5;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_player_id() const;
  public:
  const ::SCRAPIProtocol::ImageData& player_id() const;
  ::SCRAPIProtocol::ImageData* release_player_id();
  ::SCRAPIProtocol::ImageData* mutable_player_id();
  void set_allocated_player_id(::SCRAPIProtocol::ImageData* player_id);

  // optional .SCRAPIProtocol.ImageData unit_type = 6;
  bool has_unit_type() const;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 6;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_unit_type() const;
  public:
  const ::SCRAPIProtocol::ImageData& unit_type() const;
  ::SCRAPIProtocol::ImageData* release_unit_type();
  ::SCRAPIProtocol::ImageData* mutable_unit_type();
  void set_allocated_unit_type(::SCRAPIProtocol::ImageData* unit_type);

  // optional .SCRAPIProtocol.ImageData selected = 7;
  bool has_selected() const;
  void clear_selected();
  static const int kSelectedFieldNumber = 7;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_selected() const;
  public:
  const ::SCRAPIProtocol::ImageData& selected() const;
  ::SCRAPIProtocol::ImageData* release_selected();
  ::SCRAPIProtocol::ImageData* mutable_selected();
  void set_allocated_selected(::SCRAPIProtocol::ImageData* selected);

  // optional .SCRAPIProtocol.ImageData unit_hit_points = 8;
  bool has_unit_hit_points() const;
  void clear_unit_hit_points();
  static const int kUnitHitPointsFieldNumber = 8;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_unit_hit_points() const;
  public:
  const ::SCRAPIProtocol::ImageData& unit_hit_points() const;
  ::SCRAPIProtocol::ImageData* release_unit_hit_points();
  ::SCRAPIProtocol::ImageData* mutable_unit_hit_points();
  void set_allocated_unit_hit_points(::SCRAPIProtocol::ImageData* unit_hit_points);

  // optional .SCRAPIProtocol.ImageData unit_energy = 9;
  bool has_unit_energy() const;
  void clear_unit_energy();
  static const int kUnitEnergyFieldNumber = 9;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_unit_energy() const;
  public:
  const ::SCRAPIProtocol::ImageData& unit_energy() const;
  ::SCRAPIProtocol::ImageData* release_unit_energy();
  ::SCRAPIProtocol::ImageData* mutable_unit_energy();
  void set_allocated_unit_energy(::SCRAPIProtocol::ImageData* unit_energy);

  // optional .SCRAPIProtocol.ImageData unit_shields = 10;
  bool has_unit_shields() const;
  void clear_unit_shields();
  static const int kUnitShieldsFieldNumber = 10;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_unit_shields() const;
  public:
  const ::SCRAPIProtocol::ImageData& unit_shields() const;
  ::SCRAPIProtocol::ImageData* release_unit_shields();
  ::SCRAPIProtocol::ImageData* mutable_unit_shields();
  void set_allocated_unit_shields(::SCRAPIProtocol::ImageData* unit_shields);

  // optional .SCRAPIProtocol.ImageData player_relative = 11;
  bool has_player_relative() const;
  void clear_player_relative();
  static const int kPlayerRelativeFieldNumber = 11;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_player_relative() const;
  public:
  const ::SCRAPIProtocol::ImageData& player_relative() const;
  ::SCRAPIProtocol::ImageData* release_player_relative();
  ::SCRAPIProtocol::ImageData* mutable_player_relative();
  void set_allocated_player_relative(::SCRAPIProtocol::ImageData* player_relative);

  // optional .SCRAPIProtocol.ImageData unit_density_aa = 14;
  bool has_unit_density_aa() const;
  void clear_unit_density_aa();
  static const int kUnitDensityAaFieldNumber = 14;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_unit_density_aa() const;
  public:
  const ::SCRAPIProtocol::ImageData& unit_density_aa() const;
  ::SCRAPIProtocol::ImageData* release_unit_density_aa();
  ::SCRAPIProtocol::ImageData* mutable_unit_density_aa();
  void set_allocated_unit_density_aa(::SCRAPIProtocol::ImageData* unit_density_aa);

  // optional .SCRAPIProtocol.ImageData unit_density = 15;
  bool has_unit_density() const;
  void clear_unit_density();
  static const int kUnitDensityFieldNumber = 15;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_unit_density() const;
  public:
  const ::SCRAPIProtocol::ImageData& unit_density() const;
  ::SCRAPIProtocol::ImageData* release_unit_density();
  ::SCRAPIProtocol::ImageData* mutable_unit_density();
  void set_allocated_unit_density(::SCRAPIProtocol::ImageData* unit_density);

  // optional .SCRAPIProtocol.ImageData unit_hit_points_ratio = 17;
  bool has_unit_hit_points_ratio() const;
  void clear_unit_hit_points_ratio();
  static const int kUnitHitPointsRatioFieldNumber = 17;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_unit_hit_points_ratio() const;
  public:
  const ::SCRAPIProtocol::ImageData& unit_hit_points_ratio() const;
  ::SCRAPIProtocol::ImageData* release_unit_hit_points_ratio();
  ::SCRAPIProtocol::ImageData* mutable_unit_hit_points_ratio();
  void set_allocated_unit_hit_points_ratio(::SCRAPIProtocol::ImageData* unit_hit_points_ratio);

  // optional .SCRAPIProtocol.ImageData unit_energy_ratio = 18;
  bool has_unit_energy_ratio() const;
  void clear_unit_energy_ratio();
  static const int kUnitEnergyRatioFieldNumber = 18;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_unit_energy_ratio() const;
  public:
  const ::SCRAPIProtocol::ImageData& unit_energy_ratio() const;
  ::SCRAPIProtocol::ImageData* release_unit_energy_ratio();
  ::SCRAPIProtocol::ImageData* mutable_unit_energy_ratio();
  void set_allocated_unit_energy_ratio(::SCRAPIProtocol::ImageData* unit_energy_ratio);

  // optional .SCRAPIProtocol.ImageData unit_shields_ratio = 19;
  bool has_unit_shields_ratio() const;
  void clear_unit_shields_ratio();
  static const int kUnitShieldsRatioFieldNumber = 19;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_unit_shields_ratio() const;
  public:
  const ::SCRAPIProtocol::ImageData& unit_shields_ratio() const;
  ::SCRAPIProtocol::ImageData* release_unit_shields_ratio();
  ::SCRAPIProtocol::ImageData* mutable_unit_shields_ratio();
  void set_allocated_unit_shields_ratio(::SCRAPIProtocol::ImageData* unit_shields_ratio);

  // optional .SCRAPIProtocol.ImageData effects = 20;
  bool has_effects() const;
  void clear_effects();
  static const int kEffectsFieldNumber = 20;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_effects() const;
  public:
  const ::SCRAPIProtocol::ImageData& effects() const;
  ::SCRAPIProtocol::ImageData* release_effects();
  ::SCRAPIProtocol::ImageData* mutable_effects();
  void set_allocated_effects(::SCRAPIProtocol::ImageData* effects);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.FeatureLayers)
 private:
  void set_has_height_map();
  void clear_has_height_map();
  void set_has_visibility_map();
  void clear_has_visibility_map();
  void set_has_creep();
  void clear_has_creep();
  void set_has_power();
  void clear_has_power();
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_unit_type();
  void clear_has_unit_type();
  void set_has_selected();
  void clear_has_selected();
  void set_has_unit_hit_points();
  void clear_has_unit_hit_points();
  void set_has_unit_hit_points_ratio();
  void clear_has_unit_hit_points_ratio();
  void set_has_unit_energy();
  void clear_has_unit_energy();
  void set_has_unit_energy_ratio();
  void clear_has_unit_energy_ratio();
  void set_has_unit_shields();
  void clear_has_unit_shields();
  void set_has_unit_shields_ratio();
  void clear_has_unit_shields_ratio();
  void set_has_player_relative();
  void clear_has_player_relative();
  void set_has_unit_density_aa();
  void clear_has_unit_density_aa();
  void set_has_unit_density();
  void clear_has_unit_density();
  void set_has_effects();
  void clear_has_effects();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::ImageData* height_map_;
  ::SCRAPIProtocol::ImageData* visibility_map_;
  ::SCRAPIProtocol::ImageData* creep_;
  ::SCRAPIProtocol::ImageData* power_;
  ::SCRAPIProtocol::ImageData* player_id_;
  ::SCRAPIProtocol::ImageData* unit_type_;
  ::SCRAPIProtocol::ImageData* selected_;
  ::SCRAPIProtocol::ImageData* unit_hit_points_;
  ::SCRAPIProtocol::ImageData* unit_energy_;
  ::SCRAPIProtocol::ImageData* unit_shields_;
  ::SCRAPIProtocol::ImageData* player_relative_;
  ::SCRAPIProtocol::ImageData* unit_density_aa_;
  ::SCRAPIProtocol::ImageData* unit_density_;
  ::SCRAPIProtocol::ImageData* unit_hit_points_ratio_;
  ::SCRAPIProtocol::ImageData* unit_energy_ratio_;
  ::SCRAPIProtocol::ImageData* unit_shields_ratio_;
  ::SCRAPIProtocol::ImageData* effects_;
  friend struct ::protobuf_spatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeatureLayersMinimap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.FeatureLayersMinimap) */ {
 public:
  FeatureLayersMinimap();
  virtual ~FeatureLayersMinimap();

  FeatureLayersMinimap(const FeatureLayersMinimap& from);

  inline FeatureLayersMinimap& operator=(const FeatureLayersMinimap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeatureLayersMinimap(FeatureLayersMinimap&& from) noexcept
    : FeatureLayersMinimap() {
    *this = ::std::move(from);
  }

  inline FeatureLayersMinimap& operator=(FeatureLayersMinimap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureLayersMinimap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureLayersMinimap* internal_default_instance() {
    return reinterpret_cast<const FeatureLayersMinimap*>(
               &_FeatureLayersMinimap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FeatureLayersMinimap* other);
  friend void swap(FeatureLayersMinimap& a, FeatureLayersMinimap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeatureLayersMinimap* New() const final {
    return CreateMaybeMessage<FeatureLayersMinimap>(NULL);
  }

  FeatureLayersMinimap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FeatureLayersMinimap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FeatureLayersMinimap& from);
  void MergeFrom(const FeatureLayersMinimap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureLayersMinimap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ImageData height_map = 1;
  bool has_height_map() const;
  void clear_height_map();
  static const int kHeightMapFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_height_map() const;
  public:
  const ::SCRAPIProtocol::ImageData& height_map() const;
  ::SCRAPIProtocol::ImageData* release_height_map();
  ::SCRAPIProtocol::ImageData* mutable_height_map();
  void set_allocated_height_map(::SCRAPIProtocol::ImageData* height_map);

  // optional .SCRAPIProtocol.ImageData visibility_map = 2;
  bool has_visibility_map() const;
  void clear_visibility_map();
  static const int kVisibilityMapFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_visibility_map() const;
  public:
  const ::SCRAPIProtocol::ImageData& visibility_map() const;
  ::SCRAPIProtocol::ImageData* release_visibility_map();
  ::SCRAPIProtocol::ImageData* mutable_visibility_map();
  void set_allocated_visibility_map(::SCRAPIProtocol::ImageData* visibility_map);

  // optional .SCRAPIProtocol.ImageData creep = 3;
  bool has_creep() const;
  void clear_creep();
  static const int kCreepFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_creep() const;
  public:
  const ::SCRAPIProtocol::ImageData& creep() const;
  ::SCRAPIProtocol::ImageData* release_creep();
  ::SCRAPIProtocol::ImageData* mutable_creep();
  void set_allocated_creep(::SCRAPIProtocol::ImageData* creep);

  // optional .SCRAPIProtocol.ImageData camera = 4;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_camera() const;
  public:
  const ::SCRAPIProtocol::ImageData& camera() const;
  ::SCRAPIProtocol::ImageData* release_camera();
  ::SCRAPIProtocol::ImageData* mutable_camera();
  void set_allocated_camera(::SCRAPIProtocol::ImageData* camera);

  // optional .SCRAPIProtocol.ImageData player_id = 5;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 5;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_player_id() const;
  public:
  const ::SCRAPIProtocol::ImageData& player_id() const;
  ::SCRAPIProtocol::ImageData* release_player_id();
  ::SCRAPIProtocol::ImageData* mutable_player_id();
  void set_allocated_player_id(::SCRAPIProtocol::ImageData* player_id);

  // optional .SCRAPIProtocol.ImageData player_relative = 6;
  bool has_player_relative() const;
  void clear_player_relative();
  static const int kPlayerRelativeFieldNumber = 6;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_player_relative() const;
  public:
  const ::SCRAPIProtocol::ImageData& player_relative() const;
  ::SCRAPIProtocol::ImageData* release_player_relative();
  ::SCRAPIProtocol::ImageData* mutable_player_relative();
  void set_allocated_player_relative(::SCRAPIProtocol::ImageData* player_relative);

  // optional .SCRAPIProtocol.ImageData selected = 7;
  bool has_selected() const;
  void clear_selected();
  static const int kSelectedFieldNumber = 7;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_selected() const;
  public:
  const ::SCRAPIProtocol::ImageData& selected() const;
  ::SCRAPIProtocol::ImageData* release_selected();
  ::SCRAPIProtocol::ImageData* mutable_selected();
  void set_allocated_selected(::SCRAPIProtocol::ImageData* selected);

  // optional .SCRAPIProtocol.ImageData unit_type = 8;
  bool has_unit_type() const;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 8;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_unit_type() const;
  public:
  const ::SCRAPIProtocol::ImageData& unit_type() const;
  ::SCRAPIProtocol::ImageData* release_unit_type();
  ::SCRAPIProtocol::ImageData* mutable_unit_type();
  void set_allocated_unit_type(::SCRAPIProtocol::ImageData* unit_type);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.FeatureLayersMinimap)
 private:
  void set_has_height_map();
  void clear_has_height_map();
  void set_has_visibility_map();
  void clear_has_visibility_map();
  void set_has_creep();
  void clear_has_creep();
  void set_has_camera();
  void clear_has_camera();
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_player_relative();
  void clear_has_player_relative();
  void set_has_selected();
  void clear_has_selected();
  void set_has_unit_type();
  void clear_has_unit_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::ImageData* height_map_;
  ::SCRAPIProtocol::ImageData* visibility_map_;
  ::SCRAPIProtocol::ImageData* creep_;
  ::SCRAPIProtocol::ImageData* camera_;
  ::SCRAPIProtocol::ImageData* player_id_;
  ::SCRAPIProtocol::ImageData* player_relative_;
  ::SCRAPIProtocol::ImageData* selected_;
  ::SCRAPIProtocol::ImageData* unit_type_;
  friend struct ::protobuf_spatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObservationRender : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ObservationRender) */ {
 public:
  ObservationRender();
  virtual ~ObservationRender();

  ObservationRender(const ObservationRender& from);

  inline ObservationRender& operator=(const ObservationRender& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObservationRender(ObservationRender&& from) noexcept
    : ObservationRender() {
    *this = ::std::move(from);
  }

  inline ObservationRender& operator=(ObservationRender&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObservationRender& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObservationRender* internal_default_instance() {
    return reinterpret_cast<const ObservationRender*>(
               &_ObservationRender_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ObservationRender* other);
  friend void swap(ObservationRender& a, ObservationRender& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObservationRender* New() const final {
    return CreateMaybeMessage<ObservationRender>(NULL);
  }

  ObservationRender* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObservationRender>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObservationRender& from);
  void MergeFrom(const ObservationRender& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObservationRender* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ImageData map = 1;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_map() const;
  public:
  const ::SCRAPIProtocol::ImageData& map() const;
  ::SCRAPIProtocol::ImageData* release_map();
  ::SCRAPIProtocol::ImageData* mutable_map();
  void set_allocated_map(::SCRAPIProtocol::ImageData* map);

  // optional .SCRAPIProtocol.ImageData minimap = 2;
  bool has_minimap() const;
  void clear_minimap();
  static const int kMinimapFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ImageData& _internal_minimap() const;
  public:
  const ::SCRAPIProtocol::ImageData& minimap() const;
  ::SCRAPIProtocol::ImageData* release_minimap();
  ::SCRAPIProtocol::ImageData* mutable_minimap();
  void set_allocated_minimap(::SCRAPIProtocol::ImageData* minimap);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ObservationRender)
 private:
  void set_has_map();
  void clear_has_map();
  void set_has_minimap();
  void clear_has_minimap();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::ImageData* map_;
  ::SCRAPIProtocol::ImageData* minimap_;
  friend struct ::protobuf_spatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionSpatial : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionSpatial) */ {
 public:
  ActionSpatial();
  virtual ~ActionSpatial();

  ActionSpatial(const ActionSpatial& from);

  inline ActionSpatial& operator=(const ActionSpatial& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionSpatial(ActionSpatial&& from) noexcept
    : ActionSpatial() {
    *this = ::std::move(from);
  }

  inline ActionSpatial& operator=(ActionSpatial&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSpatial& default_instance();

  enum ActionCase {
    kUnitCommand = 1,
    kCameraMove = 2,
    kUnitSelectionPoint = 3,
    kUnitSelectionRect = 4,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpatial* internal_default_instance() {
    return reinterpret_cast<const ActionSpatial*>(
               &_ActionSpatial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ActionSpatial* other);
  friend void swap(ActionSpatial& a, ActionSpatial& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionSpatial* New() const final {
    return CreateMaybeMessage<ActionSpatial>(NULL);
  }

  ActionSpatial* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpatial>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionSpatial& from);
  void MergeFrom(const ActionSpatial& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatial* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ActionSpatialUnitCommand unit_command = 1;
  bool has_unit_command() const;
  void clear_unit_command();
  static const int kUnitCommandFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::ActionSpatialUnitCommand& _internal_unit_command() const;
  public:
  const ::SCRAPIProtocol::ActionSpatialUnitCommand& unit_command() const;
  ::SCRAPIProtocol::ActionSpatialUnitCommand* release_unit_command();
  ::SCRAPIProtocol::ActionSpatialUnitCommand* mutable_unit_command();
  void set_allocated_unit_command(::SCRAPIProtocol::ActionSpatialUnitCommand* unit_command);

  // optional .SCRAPIProtocol.ActionSpatialCameraMove camera_move = 2;
  bool has_camera_move() const;
  void clear_camera_move();
  static const int kCameraMoveFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ActionSpatialCameraMove& _internal_camera_move() const;
  public:
  const ::SCRAPIProtocol::ActionSpatialCameraMove& camera_move() const;
  ::SCRAPIProtocol::ActionSpatialCameraMove* release_camera_move();
  ::SCRAPIProtocol::ActionSpatialCameraMove* mutable_camera_move();
  void set_allocated_camera_move(::SCRAPIProtocol::ActionSpatialCameraMove* camera_move);

  // optional .SCRAPIProtocol.ActionSpatialUnitSelectionPoint unit_selection_point = 3;
  bool has_unit_selection_point() const;
  void clear_unit_selection_point();
  static const int kUnitSelectionPointFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint& _internal_unit_selection_point() const;
  public:
  const ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint& unit_selection_point() const;
  ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint* release_unit_selection_point();
  ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint* mutable_unit_selection_point();
  void set_allocated_unit_selection_point(::SCRAPIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point);

  // optional .SCRAPIProtocol.ActionSpatialUnitSelectionRect unit_selection_rect = 4;
  bool has_unit_selection_rect() const;
  void clear_unit_selection_rect();
  static const int kUnitSelectionRectFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::ActionSpatialUnitSelectionRect& _internal_unit_selection_rect() const;
  public:
  const ::SCRAPIProtocol::ActionSpatialUnitSelectionRect& unit_selection_rect() const;
  ::SCRAPIProtocol::ActionSpatialUnitSelectionRect* release_unit_selection_rect();
  ::SCRAPIProtocol::ActionSpatialUnitSelectionRect* mutable_unit_selection_rect();
  void set_allocated_unit_selection_rect(::SCRAPIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect);

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionSpatial)
 private:
  void set_has_unit_command();
  void set_has_camera_move();
  void set_has_unit_selection_point();
  void set_has_unit_selection_rect();

  inline bool has_action() const;
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ActionUnion {
    ActionUnion() {}
    ::SCRAPIProtocol::ActionSpatialUnitCommand* unit_command_;
    ::SCRAPIProtocol::ActionSpatialCameraMove* camera_move_;
    ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point_;
    ::SCRAPIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect_;
  } action_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_spatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionSpatialUnitCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionSpatialUnitCommand) */ {
 public:
  ActionSpatialUnitCommand();
  virtual ~ActionSpatialUnitCommand();

  ActionSpatialUnitCommand(const ActionSpatialUnitCommand& from);

  inline ActionSpatialUnitCommand& operator=(const ActionSpatialUnitCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionSpatialUnitCommand(ActionSpatialUnitCommand&& from) noexcept
    : ActionSpatialUnitCommand() {
    *this = ::std::move(from);
  }

  inline ActionSpatialUnitCommand& operator=(ActionSpatialUnitCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSpatialUnitCommand& default_instance();

  enum TargetCase {
    kTargetScreenCoord = 2,
    kTargetMinimapCoord = 3,
    TARGET_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpatialUnitCommand* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialUnitCommand*>(
               &_ActionSpatialUnitCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ActionSpatialUnitCommand* other);
  friend void swap(ActionSpatialUnitCommand& a, ActionSpatialUnitCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionSpatialUnitCommand* New() const final {
    return CreateMaybeMessage<ActionSpatialUnitCommand>(NULL);
  }

  ActionSpatialUnitCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpatialUnitCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionSpatialUnitCommand& from);
  void MergeFrom(const ActionSpatialUnitCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialUnitCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  ::google::protobuf::int32 ability_id() const;
  void set_ability_id(::google::protobuf::int32 value);

  // optional bool queue_command = 4;
  bool has_queue_command() const;
  void clear_queue_command();
  static const int kQueueCommandFieldNumber = 4;
  bool queue_command() const;
  void set_queue_command(bool value);

  // optional .SCRAPIProtocol.PointI target_screen_coord = 2;
  bool has_target_screen_coord() const;
  void clear_target_screen_coord();
  static const int kTargetScreenCoordFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::PointI& _internal_target_screen_coord() const;
  public:
  const ::SCRAPIProtocol::PointI& target_screen_coord() const;
  ::SCRAPIProtocol::PointI* release_target_screen_coord();
  ::SCRAPIProtocol::PointI* mutable_target_screen_coord();
  void set_allocated_target_screen_coord(::SCRAPIProtocol::PointI* target_screen_coord);

  // optional .SCRAPIProtocol.PointI target_minimap_coord = 3;
  bool has_target_minimap_coord() const;
  void clear_target_minimap_coord();
  static const int kTargetMinimapCoordFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::PointI& _internal_target_minimap_coord() const;
  public:
  const ::SCRAPIProtocol::PointI& target_minimap_coord() const;
  ::SCRAPIProtocol::PointI* release_target_minimap_coord();
  ::SCRAPIProtocol::PointI* mutable_target_minimap_coord();
  void set_allocated_target_minimap_coord(::SCRAPIProtocol::PointI* target_minimap_coord);

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionSpatialUnitCommand)
 private:
  void set_has_ability_id();
  void clear_has_ability_id();
  void set_has_target_screen_coord();
  void set_has_target_minimap_coord();
  void set_has_queue_command();
  void clear_has_queue_command();

  inline bool has_target() const;
  inline void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 ability_id_;
  bool queue_command_;
  union TargetUnion {
    TargetUnion() {}
    ::SCRAPIProtocol::PointI* target_screen_coord_;
    ::SCRAPIProtocol::PointI* target_minimap_coord_;
  } target_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_spatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionSpatialCameraMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionSpatialCameraMove) */ {
 public:
  ActionSpatialCameraMove();
  virtual ~ActionSpatialCameraMove();

  ActionSpatialCameraMove(const ActionSpatialCameraMove& from);

  inline ActionSpatialCameraMove& operator=(const ActionSpatialCameraMove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionSpatialCameraMove(ActionSpatialCameraMove&& from) noexcept
    : ActionSpatialCameraMove() {
    *this = ::std::move(from);
  }

  inline ActionSpatialCameraMove& operator=(ActionSpatialCameraMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSpatialCameraMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpatialCameraMove* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialCameraMove*>(
               &_ActionSpatialCameraMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ActionSpatialCameraMove* other);
  friend void swap(ActionSpatialCameraMove& a, ActionSpatialCameraMove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionSpatialCameraMove* New() const final {
    return CreateMaybeMessage<ActionSpatialCameraMove>(NULL);
  }

  ActionSpatialCameraMove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpatialCameraMove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionSpatialCameraMove& from);
  void MergeFrom(const ActionSpatialCameraMove& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialCameraMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.PointI center_minimap = 1;
  bool has_center_minimap() const;
  void clear_center_minimap();
  static const int kCenterMinimapFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::PointI& _internal_center_minimap() const;
  public:
  const ::SCRAPIProtocol::PointI& center_minimap() const;
  ::SCRAPIProtocol::PointI* release_center_minimap();
  ::SCRAPIProtocol::PointI* mutable_center_minimap();
  void set_allocated_center_minimap(::SCRAPIProtocol::PointI* center_minimap);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionSpatialCameraMove)
 private:
  void set_has_center_minimap();
  void clear_has_center_minimap();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::PointI* center_minimap_;
  friend struct ::protobuf_spatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionSpatialUnitSelectionPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionSpatialUnitSelectionPoint) */ {
 public:
  ActionSpatialUnitSelectionPoint();
  virtual ~ActionSpatialUnitSelectionPoint();

  ActionSpatialUnitSelectionPoint(const ActionSpatialUnitSelectionPoint& from);

  inline ActionSpatialUnitSelectionPoint& operator=(const ActionSpatialUnitSelectionPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionSpatialUnitSelectionPoint(ActionSpatialUnitSelectionPoint&& from) noexcept
    : ActionSpatialUnitSelectionPoint() {
    *this = ::std::move(from);
  }

  inline ActionSpatialUnitSelectionPoint& operator=(ActionSpatialUnitSelectionPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSpatialUnitSelectionPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpatialUnitSelectionPoint* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialUnitSelectionPoint*>(
               &_ActionSpatialUnitSelectionPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ActionSpatialUnitSelectionPoint* other);
  friend void swap(ActionSpatialUnitSelectionPoint& a, ActionSpatialUnitSelectionPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionSpatialUnitSelectionPoint* New() const final {
    return CreateMaybeMessage<ActionSpatialUnitSelectionPoint>(NULL);
  }

  ActionSpatialUnitSelectionPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpatialUnitSelectionPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionSpatialUnitSelectionPoint& from);
  void MergeFrom(const ActionSpatialUnitSelectionPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialUnitSelectionPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionSpatialUnitSelectionPoint_Type Type;
  static const Type Select =
    ActionSpatialUnitSelectionPoint_Type_Select;
  static const Type Toggle =
    ActionSpatialUnitSelectionPoint_Type_Toggle;
  static const Type AllType =
    ActionSpatialUnitSelectionPoint_Type_AllType;
  static const Type AddAllType =
    ActionSpatialUnitSelectionPoint_Type_AddAllType;
  static inline bool Type_IsValid(int value) {
    return ActionSpatialUnitSelectionPoint_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ActionSpatialUnitSelectionPoint_Type_Type_MIN;
  static const Type Type_MAX =
    ActionSpatialUnitSelectionPoint_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ActionSpatialUnitSelectionPoint_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ActionSpatialUnitSelectionPoint_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ActionSpatialUnitSelectionPoint_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ActionSpatialUnitSelectionPoint_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.PointI selection_screen_coord = 1;
  bool has_selection_screen_coord() const;
  void clear_selection_screen_coord();
  static const int kSelectionScreenCoordFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::PointI& _internal_selection_screen_coord() const;
  public:
  const ::SCRAPIProtocol::PointI& selection_screen_coord() const;
  ::SCRAPIProtocol::PointI* release_selection_screen_coord();
  ::SCRAPIProtocol::PointI* mutable_selection_screen_coord();
  void set_allocated_selection_screen_coord(::SCRAPIProtocol::PointI* selection_screen_coord);

  // optional .SCRAPIProtocol.ActionSpatialUnitSelectionPoint.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint_Type type() const;
  void set_type(::SCRAPIProtocol::ActionSpatialUnitSelectionPoint_Type value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionSpatialUnitSelectionPoint)
 private:
  void set_has_selection_screen_coord();
  void clear_has_selection_screen_coord();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::PointI* selection_screen_coord_;
  int type_;
  friend struct ::protobuf_spatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionSpatialUnitSelectionRect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionSpatialUnitSelectionRect) */ {
 public:
  ActionSpatialUnitSelectionRect();
  virtual ~ActionSpatialUnitSelectionRect();

  ActionSpatialUnitSelectionRect(const ActionSpatialUnitSelectionRect& from);

  inline ActionSpatialUnitSelectionRect& operator=(const ActionSpatialUnitSelectionRect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionSpatialUnitSelectionRect(ActionSpatialUnitSelectionRect&& from) noexcept
    : ActionSpatialUnitSelectionRect() {
    *this = ::std::move(from);
  }

  inline ActionSpatialUnitSelectionRect& operator=(ActionSpatialUnitSelectionRect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSpatialUnitSelectionRect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpatialUnitSelectionRect* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialUnitSelectionRect*>(
               &_ActionSpatialUnitSelectionRect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ActionSpatialUnitSelectionRect* other);
  friend void swap(ActionSpatialUnitSelectionRect& a, ActionSpatialUnitSelectionRect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionSpatialUnitSelectionRect* New() const final {
    return CreateMaybeMessage<ActionSpatialUnitSelectionRect>(NULL);
  }

  ActionSpatialUnitSelectionRect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpatialUnitSelectionRect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionSpatialUnitSelectionRect& from);
  void MergeFrom(const ActionSpatialUnitSelectionRect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialUnitSelectionRect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.RectangleI selection_screen_coord = 1;
  int selection_screen_coord_size() const;
  void clear_selection_screen_coord();
  static const int kSelectionScreenCoordFieldNumber = 1;
  ::SCRAPIProtocol::RectangleI* mutable_selection_screen_coord(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::RectangleI >*
      mutable_selection_screen_coord();
  const ::SCRAPIProtocol::RectangleI& selection_screen_coord(int index) const;
  ::SCRAPIProtocol::RectangleI* add_selection_screen_coord();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::RectangleI >&
      selection_screen_coord() const;

  // optional bool selection_add = 2;
  bool has_selection_add() const;
  void clear_selection_add();
  static const int kSelectionAddFieldNumber = 2;
  bool selection_add() const;
  void set_selection_add(bool value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionSpatialUnitSelectionRect)
 private:
  void set_has_selection_add();
  void clear_has_selection_add();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::RectangleI > selection_screen_coord_;
  bool selection_add_;
  friend struct ::protobuf_spatial_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObservationFeatureLayer

// optional .SCRAPIProtocol.FeatureLayers renders = 1;
inline bool ObservationFeatureLayer::has_renders() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObservationFeatureLayer::set_has_renders() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObservationFeatureLayer::clear_has_renders() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObservationFeatureLayer::clear_renders() {
  if (renders_ != NULL) renders_->Clear();
  clear_has_renders();
}
inline const ::SCRAPIProtocol::FeatureLayers& ObservationFeatureLayer::_internal_renders() const {
  return *renders_;
}
inline const ::SCRAPIProtocol::FeatureLayers& ObservationFeatureLayer::renders() const {
  const ::SCRAPIProtocol::FeatureLayers* p = renders_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationFeatureLayer.renders)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::FeatureLayers*>(
      &::SCRAPIProtocol::_FeatureLayers_default_instance_);
}
inline ::SCRAPIProtocol::FeatureLayers* ObservationFeatureLayer::release_renders() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationFeatureLayer.renders)
  clear_has_renders();
  ::SCRAPIProtocol::FeatureLayers* temp = renders_;
  renders_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::FeatureLayers* ObservationFeatureLayer::mutable_renders() {
  set_has_renders();
  if (renders_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::FeatureLayers>(GetArenaNoVirtual());
    renders_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationFeatureLayer.renders)
  return renders_;
}
inline void ObservationFeatureLayer::set_allocated_renders(::SCRAPIProtocol::FeatureLayers* renders) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete renders_;
  }
  if (renders) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      renders = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, renders, submessage_arena);
    }
    set_has_renders();
  } else {
    clear_has_renders();
  }
  renders_ = renders;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ObservationFeatureLayer.renders)
}

// optional .SCRAPIProtocol.FeatureLayersMinimap minimap_renders = 2;
inline bool ObservationFeatureLayer::has_minimap_renders() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObservationFeatureLayer::set_has_minimap_renders() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObservationFeatureLayer::clear_has_minimap_renders() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObservationFeatureLayer::clear_minimap_renders() {
  if (minimap_renders_ != NULL) minimap_renders_->Clear();
  clear_has_minimap_renders();
}
inline const ::SCRAPIProtocol::FeatureLayersMinimap& ObservationFeatureLayer::_internal_minimap_renders() const {
  return *minimap_renders_;
}
inline const ::SCRAPIProtocol::FeatureLayersMinimap& ObservationFeatureLayer::minimap_renders() const {
  const ::SCRAPIProtocol::FeatureLayersMinimap* p = minimap_renders_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationFeatureLayer.minimap_renders)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::FeatureLayersMinimap*>(
      &::SCRAPIProtocol::_FeatureLayersMinimap_default_instance_);
}
inline ::SCRAPIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::release_minimap_renders() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationFeatureLayer.minimap_renders)
  clear_has_minimap_renders();
  ::SCRAPIProtocol::FeatureLayersMinimap* temp = minimap_renders_;
  minimap_renders_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::mutable_minimap_renders() {
  set_has_minimap_renders();
  if (minimap_renders_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::FeatureLayersMinimap>(GetArenaNoVirtual());
    minimap_renders_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationFeatureLayer.minimap_renders)
  return minimap_renders_;
}
inline void ObservationFeatureLayer::set_allocated_minimap_renders(::SCRAPIProtocol::FeatureLayersMinimap* minimap_renders) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete minimap_renders_;
  }
  if (minimap_renders) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      minimap_renders = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, minimap_renders, submessage_arena);
    }
    set_has_minimap_renders();
  } else {
    clear_has_minimap_renders();
  }
  minimap_renders_ = minimap_renders;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ObservationFeatureLayer.minimap_renders)
}

// -------------------------------------------------------------------

// FeatureLayers

// optional .SCRAPIProtocol.ImageData height_map = 1;
inline bool FeatureLayers::has_height_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureLayers::set_has_height_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureLayers::clear_has_height_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_height_map() const {
  return *height_map_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::height_map() const {
  const ::SCRAPIProtocol::ImageData* p = height_map_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.height_map)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_height_map() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.height_map)
  clear_has_height_map();
  ::SCRAPIProtocol::ImageData* temp = height_map_;
  height_map_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_height_map() {
  set_has_height_map();
  if (height_map_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    height_map_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.height_map)
  return height_map_;
}
inline void FeatureLayers::set_allocated_height_map(::SCRAPIProtocol::ImageData* height_map) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(height_map_);
  }
  if (height_map) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      height_map = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, height_map, submessage_arena);
    }
    set_has_height_map();
  } else {
    clear_has_height_map();
  }
  height_map_ = height_map;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.height_map)
}

// optional .SCRAPIProtocol.ImageData visibility_map = 2;
inline bool FeatureLayers::has_visibility_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureLayers::set_has_visibility_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureLayers::clear_has_visibility_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_visibility_map() const {
  return *visibility_map_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::visibility_map() const {
  const ::SCRAPIProtocol::ImageData* p = visibility_map_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.visibility_map)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_visibility_map() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.visibility_map)
  clear_has_visibility_map();
  ::SCRAPIProtocol::ImageData* temp = visibility_map_;
  visibility_map_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_visibility_map() {
  set_has_visibility_map();
  if (visibility_map_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    visibility_map_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.visibility_map)
  return visibility_map_;
}
inline void FeatureLayers::set_allocated_visibility_map(::SCRAPIProtocol::ImageData* visibility_map) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(visibility_map_);
  }
  if (visibility_map) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      visibility_map = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, visibility_map, submessage_arena);
    }
    set_has_visibility_map();
  } else {
    clear_has_visibility_map();
  }
  visibility_map_ = visibility_map;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.visibility_map)
}

// optional .SCRAPIProtocol.ImageData creep = 3;
inline bool FeatureLayers::has_creep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeatureLayers::set_has_creep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeatureLayers::clear_has_creep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_creep() const {
  return *creep_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::creep() const {
  const ::SCRAPIProtocol::ImageData* p = creep_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.creep)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_creep() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.creep)
  clear_has_creep();
  ::SCRAPIProtocol::ImageData* temp = creep_;
  creep_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_creep() {
  set_has_creep();
  if (creep_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    creep_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.creep)
  return creep_;
}
inline void FeatureLayers::set_allocated_creep(::SCRAPIProtocol::ImageData* creep) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(creep_);
  }
  if (creep) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      creep = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, creep, submessage_arena);
    }
    set_has_creep();
  } else {
    clear_has_creep();
  }
  creep_ = creep;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.creep)
}

// optional .SCRAPIProtocol.ImageData power = 4;
inline bool FeatureLayers::has_power() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeatureLayers::set_has_power() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeatureLayers::clear_has_power() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_power() const {
  return *power_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::power() const {
  const ::SCRAPIProtocol::ImageData* p = power_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.power)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_power() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.power)
  clear_has_power();
  ::SCRAPIProtocol::ImageData* temp = power_;
  power_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_power() {
  set_has_power();
  if (power_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    power_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.power)
  return power_;
}
inline void FeatureLayers::set_allocated_power(::SCRAPIProtocol::ImageData* power) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(power_);
  }
  if (power) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      power = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, power, submessage_arena);
    }
    set_has_power();
  } else {
    clear_has_power();
  }
  power_ = power;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.power)
}

// optional .SCRAPIProtocol.ImageData player_id = 5;
inline bool FeatureLayers::has_player_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeatureLayers::set_has_player_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeatureLayers::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_player_id() const {
  return *player_id_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::player_id() const {
  const ::SCRAPIProtocol::ImageData* p = player_id_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.player_id)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_player_id() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.player_id)
  clear_has_player_id();
  ::SCRAPIProtocol::ImageData* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    player_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.player_id)
  return player_id_;
}
inline void FeatureLayers::set_allocated_player_id(::SCRAPIProtocol::ImageData* player_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.player_id)
}

// optional .SCRAPIProtocol.ImageData unit_type = 6;
inline bool FeatureLayers::has_unit_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FeatureLayers::set_has_unit_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FeatureLayers::clear_has_unit_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_unit_type() const {
  return *unit_type_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::unit_type() const {
  const ::SCRAPIProtocol::ImageData* p = unit_type_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.unit_type)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_unit_type() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.unit_type)
  clear_has_unit_type();
  ::SCRAPIProtocol::ImageData* temp = unit_type_;
  unit_type_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_unit_type() {
  set_has_unit_type();
  if (unit_type_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    unit_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.unit_type)
  return unit_type_;
}
inline void FeatureLayers::set_allocated_unit_type(::SCRAPIProtocol::ImageData* unit_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_type_);
  }
  if (unit_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit_type, submessage_arena);
    }
    set_has_unit_type();
  } else {
    clear_has_unit_type();
  }
  unit_type_ = unit_type;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.unit_type)
}

// optional .SCRAPIProtocol.ImageData selected = 7;
inline bool FeatureLayers::has_selected() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FeatureLayers::set_has_selected() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FeatureLayers::clear_has_selected() {
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_selected() const {
  return *selected_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::selected() const {
  const ::SCRAPIProtocol::ImageData* p = selected_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.selected)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_selected() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.selected)
  clear_has_selected();
  ::SCRAPIProtocol::ImageData* temp = selected_;
  selected_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_selected() {
  set_has_selected();
  if (selected_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    selected_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.selected)
  return selected_;
}
inline void FeatureLayers::set_allocated_selected(::SCRAPIProtocol::ImageData* selected) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(selected_);
  }
  if (selected) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      selected = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, selected, submessage_arena);
    }
    set_has_selected();
  } else {
    clear_has_selected();
  }
  selected_ = selected;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.selected)
}

// optional .SCRAPIProtocol.ImageData unit_hit_points = 8;
inline bool FeatureLayers::has_unit_hit_points() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FeatureLayers::set_has_unit_hit_points() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FeatureLayers::clear_has_unit_hit_points() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_unit_hit_points() const {
  return *unit_hit_points_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::unit_hit_points() const {
  const ::SCRAPIProtocol::ImageData* p = unit_hit_points_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.unit_hit_points)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_unit_hit_points() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.unit_hit_points)
  clear_has_unit_hit_points();
  ::SCRAPIProtocol::ImageData* temp = unit_hit_points_;
  unit_hit_points_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_unit_hit_points() {
  set_has_unit_hit_points();
  if (unit_hit_points_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    unit_hit_points_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.unit_hit_points)
  return unit_hit_points_;
}
inline void FeatureLayers::set_allocated_unit_hit_points(::SCRAPIProtocol::ImageData* unit_hit_points) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_hit_points_);
  }
  if (unit_hit_points) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit_hit_points = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit_hit_points, submessage_arena);
    }
    set_has_unit_hit_points();
  } else {
    clear_has_unit_hit_points();
  }
  unit_hit_points_ = unit_hit_points;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.unit_hit_points)
}

// optional .SCRAPIProtocol.ImageData unit_hit_points_ratio = 17;
inline bool FeatureLayers::has_unit_hit_points_ratio() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FeatureLayers::set_has_unit_hit_points_ratio() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FeatureLayers::clear_has_unit_hit_points_ratio() {
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_unit_hit_points_ratio() const {
  return *unit_hit_points_ratio_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::unit_hit_points_ratio() const {
  const ::SCRAPIProtocol::ImageData* p = unit_hit_points_ratio_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.unit_hit_points_ratio)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_unit_hit_points_ratio() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.unit_hit_points_ratio)
  clear_has_unit_hit_points_ratio();
  ::SCRAPIProtocol::ImageData* temp = unit_hit_points_ratio_;
  unit_hit_points_ratio_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_unit_hit_points_ratio() {
  set_has_unit_hit_points_ratio();
  if (unit_hit_points_ratio_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    unit_hit_points_ratio_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.unit_hit_points_ratio)
  return unit_hit_points_ratio_;
}
inline void FeatureLayers::set_allocated_unit_hit_points_ratio(::SCRAPIProtocol::ImageData* unit_hit_points_ratio) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_hit_points_ratio_);
  }
  if (unit_hit_points_ratio) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit_hit_points_ratio = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit_hit_points_ratio, submessage_arena);
    }
    set_has_unit_hit_points_ratio();
  } else {
    clear_has_unit_hit_points_ratio();
  }
  unit_hit_points_ratio_ = unit_hit_points_ratio;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.unit_hit_points_ratio)
}

// optional .SCRAPIProtocol.ImageData unit_energy = 9;
inline bool FeatureLayers::has_unit_energy() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FeatureLayers::set_has_unit_energy() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FeatureLayers::clear_has_unit_energy() {
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_unit_energy() const {
  return *unit_energy_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::unit_energy() const {
  const ::SCRAPIProtocol::ImageData* p = unit_energy_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.unit_energy)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_unit_energy() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.unit_energy)
  clear_has_unit_energy();
  ::SCRAPIProtocol::ImageData* temp = unit_energy_;
  unit_energy_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_unit_energy() {
  set_has_unit_energy();
  if (unit_energy_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    unit_energy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.unit_energy)
  return unit_energy_;
}
inline void FeatureLayers::set_allocated_unit_energy(::SCRAPIProtocol::ImageData* unit_energy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_energy_);
  }
  if (unit_energy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit_energy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit_energy, submessage_arena);
    }
    set_has_unit_energy();
  } else {
    clear_has_unit_energy();
  }
  unit_energy_ = unit_energy;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.unit_energy)
}

// optional .SCRAPIProtocol.ImageData unit_energy_ratio = 18;
inline bool FeatureLayers::has_unit_energy_ratio() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void FeatureLayers::set_has_unit_energy_ratio() {
  _has_bits_[0] |= 0x00004000u;
}
inline void FeatureLayers::clear_has_unit_energy_ratio() {
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_unit_energy_ratio() const {
  return *unit_energy_ratio_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::unit_energy_ratio() const {
  const ::SCRAPIProtocol::ImageData* p = unit_energy_ratio_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.unit_energy_ratio)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_unit_energy_ratio() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.unit_energy_ratio)
  clear_has_unit_energy_ratio();
  ::SCRAPIProtocol::ImageData* temp = unit_energy_ratio_;
  unit_energy_ratio_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_unit_energy_ratio() {
  set_has_unit_energy_ratio();
  if (unit_energy_ratio_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    unit_energy_ratio_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.unit_energy_ratio)
  return unit_energy_ratio_;
}
inline void FeatureLayers::set_allocated_unit_energy_ratio(::SCRAPIProtocol::ImageData* unit_energy_ratio) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_energy_ratio_);
  }
  if (unit_energy_ratio) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit_energy_ratio = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit_energy_ratio, submessage_arena);
    }
    set_has_unit_energy_ratio();
  } else {
    clear_has_unit_energy_ratio();
  }
  unit_energy_ratio_ = unit_energy_ratio;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.unit_energy_ratio)
}

// optional .SCRAPIProtocol.ImageData unit_shields = 10;
inline bool FeatureLayers::has_unit_shields() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FeatureLayers::set_has_unit_shields() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FeatureLayers::clear_has_unit_shields() {
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_unit_shields() const {
  return *unit_shields_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::unit_shields() const {
  const ::SCRAPIProtocol::ImageData* p = unit_shields_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.unit_shields)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_unit_shields() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.unit_shields)
  clear_has_unit_shields();
  ::SCRAPIProtocol::ImageData* temp = unit_shields_;
  unit_shields_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_unit_shields() {
  set_has_unit_shields();
  if (unit_shields_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    unit_shields_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.unit_shields)
  return unit_shields_;
}
inline void FeatureLayers::set_allocated_unit_shields(::SCRAPIProtocol::ImageData* unit_shields) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_shields_);
  }
  if (unit_shields) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit_shields = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit_shields, submessage_arena);
    }
    set_has_unit_shields();
  } else {
    clear_has_unit_shields();
  }
  unit_shields_ = unit_shields;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.unit_shields)
}

// optional .SCRAPIProtocol.ImageData unit_shields_ratio = 19;
inline bool FeatureLayers::has_unit_shields_ratio() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void FeatureLayers::set_has_unit_shields_ratio() {
  _has_bits_[0] |= 0x00008000u;
}
inline void FeatureLayers::clear_has_unit_shields_ratio() {
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_unit_shields_ratio() const {
  return *unit_shields_ratio_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::unit_shields_ratio() const {
  const ::SCRAPIProtocol::ImageData* p = unit_shields_ratio_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.unit_shields_ratio)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_unit_shields_ratio() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.unit_shields_ratio)
  clear_has_unit_shields_ratio();
  ::SCRAPIProtocol::ImageData* temp = unit_shields_ratio_;
  unit_shields_ratio_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_unit_shields_ratio() {
  set_has_unit_shields_ratio();
  if (unit_shields_ratio_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    unit_shields_ratio_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.unit_shields_ratio)
  return unit_shields_ratio_;
}
inline void FeatureLayers::set_allocated_unit_shields_ratio(::SCRAPIProtocol::ImageData* unit_shields_ratio) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_shields_ratio_);
  }
  if (unit_shields_ratio) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit_shields_ratio = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit_shields_ratio, submessage_arena);
    }
    set_has_unit_shields_ratio();
  } else {
    clear_has_unit_shields_ratio();
  }
  unit_shields_ratio_ = unit_shields_ratio;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.unit_shields_ratio)
}

// optional .SCRAPIProtocol.ImageData player_relative = 11;
inline bool FeatureLayers::has_player_relative() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FeatureLayers::set_has_player_relative() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FeatureLayers::clear_has_player_relative() {
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_player_relative() const {
  return *player_relative_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::player_relative() const {
  const ::SCRAPIProtocol::ImageData* p = player_relative_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.player_relative)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_player_relative() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.player_relative)
  clear_has_player_relative();
  ::SCRAPIProtocol::ImageData* temp = player_relative_;
  player_relative_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_player_relative() {
  set_has_player_relative();
  if (player_relative_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    player_relative_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.player_relative)
  return player_relative_;
}
inline void FeatureLayers::set_allocated_player_relative(::SCRAPIProtocol::ImageData* player_relative) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(player_relative_);
  }
  if (player_relative) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_relative = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_relative, submessage_arena);
    }
    set_has_player_relative();
  } else {
    clear_has_player_relative();
  }
  player_relative_ = player_relative;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.player_relative)
}

// optional .SCRAPIProtocol.ImageData unit_density_aa = 14;
inline bool FeatureLayers::has_unit_density_aa() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FeatureLayers::set_has_unit_density_aa() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FeatureLayers::clear_has_unit_density_aa() {
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_unit_density_aa() const {
  return *unit_density_aa_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::unit_density_aa() const {
  const ::SCRAPIProtocol::ImageData* p = unit_density_aa_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.unit_density_aa)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_unit_density_aa() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.unit_density_aa)
  clear_has_unit_density_aa();
  ::SCRAPIProtocol::ImageData* temp = unit_density_aa_;
  unit_density_aa_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_unit_density_aa() {
  set_has_unit_density_aa();
  if (unit_density_aa_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    unit_density_aa_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.unit_density_aa)
  return unit_density_aa_;
}
inline void FeatureLayers::set_allocated_unit_density_aa(::SCRAPIProtocol::ImageData* unit_density_aa) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_density_aa_);
  }
  if (unit_density_aa) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit_density_aa = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit_density_aa, submessage_arena);
    }
    set_has_unit_density_aa();
  } else {
    clear_has_unit_density_aa();
  }
  unit_density_aa_ = unit_density_aa;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.unit_density_aa)
}

// optional .SCRAPIProtocol.ImageData unit_density = 15;
inline bool FeatureLayers::has_unit_density() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FeatureLayers::set_has_unit_density() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FeatureLayers::clear_has_unit_density() {
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_unit_density() const {
  return *unit_density_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::unit_density() const {
  const ::SCRAPIProtocol::ImageData* p = unit_density_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.unit_density)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_unit_density() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.unit_density)
  clear_has_unit_density();
  ::SCRAPIProtocol::ImageData* temp = unit_density_;
  unit_density_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_unit_density() {
  set_has_unit_density();
  if (unit_density_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    unit_density_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.unit_density)
  return unit_density_;
}
inline void FeatureLayers::set_allocated_unit_density(::SCRAPIProtocol::ImageData* unit_density) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_density_);
  }
  if (unit_density) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit_density = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit_density, submessage_arena);
    }
    set_has_unit_density();
  } else {
    clear_has_unit_density();
  }
  unit_density_ = unit_density;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.unit_density)
}

// optional .SCRAPIProtocol.ImageData effects = 20;
inline bool FeatureLayers::has_effects() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void FeatureLayers::set_has_effects() {
  _has_bits_[0] |= 0x00010000u;
}
inline void FeatureLayers::clear_has_effects() {
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::_internal_effects() const {
  return *effects_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayers::effects() const {
  const ::SCRAPIProtocol::ImageData* p = effects_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayers.effects)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::release_effects() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayers.effects)
  clear_has_effects();
  ::SCRAPIProtocol::ImageData* temp = effects_;
  effects_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayers::mutable_effects() {
  set_has_effects();
  if (effects_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    effects_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayers.effects)
  return effects_;
}
inline void FeatureLayers::set_allocated_effects(::SCRAPIProtocol::ImageData* effects) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(effects_);
  }
  if (effects) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      effects = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, effects, submessage_arena);
    }
    set_has_effects();
  } else {
    clear_has_effects();
  }
  effects_ = effects;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayers.effects)
}

// -------------------------------------------------------------------

// FeatureLayersMinimap

// optional .SCRAPIProtocol.ImageData height_map = 1;
inline bool FeatureLayersMinimap::has_height_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureLayersMinimap::set_has_height_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureLayersMinimap::clear_has_height_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::_internal_height_map() const {
  return *height_map_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::height_map() const {
  const ::SCRAPIProtocol::ImageData* p = height_map_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayersMinimap.height_map)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::release_height_map() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayersMinimap.height_map)
  clear_has_height_map();
  ::SCRAPIProtocol::ImageData* temp = height_map_;
  height_map_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::mutable_height_map() {
  set_has_height_map();
  if (height_map_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    height_map_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayersMinimap.height_map)
  return height_map_;
}
inline void FeatureLayersMinimap::set_allocated_height_map(::SCRAPIProtocol::ImageData* height_map) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(height_map_);
  }
  if (height_map) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      height_map = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, height_map, submessage_arena);
    }
    set_has_height_map();
  } else {
    clear_has_height_map();
  }
  height_map_ = height_map;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayersMinimap.height_map)
}

// optional .SCRAPIProtocol.ImageData visibility_map = 2;
inline bool FeatureLayersMinimap::has_visibility_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureLayersMinimap::set_has_visibility_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureLayersMinimap::clear_has_visibility_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::_internal_visibility_map() const {
  return *visibility_map_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::visibility_map() const {
  const ::SCRAPIProtocol::ImageData* p = visibility_map_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayersMinimap.visibility_map)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::release_visibility_map() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayersMinimap.visibility_map)
  clear_has_visibility_map();
  ::SCRAPIProtocol::ImageData* temp = visibility_map_;
  visibility_map_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::mutable_visibility_map() {
  set_has_visibility_map();
  if (visibility_map_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    visibility_map_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayersMinimap.visibility_map)
  return visibility_map_;
}
inline void FeatureLayersMinimap::set_allocated_visibility_map(::SCRAPIProtocol::ImageData* visibility_map) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(visibility_map_);
  }
  if (visibility_map) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      visibility_map = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, visibility_map, submessage_arena);
    }
    set_has_visibility_map();
  } else {
    clear_has_visibility_map();
  }
  visibility_map_ = visibility_map;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayersMinimap.visibility_map)
}

// optional .SCRAPIProtocol.ImageData creep = 3;
inline bool FeatureLayersMinimap::has_creep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeatureLayersMinimap::set_has_creep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeatureLayersMinimap::clear_has_creep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::_internal_creep() const {
  return *creep_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::creep() const {
  const ::SCRAPIProtocol::ImageData* p = creep_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayersMinimap.creep)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::release_creep() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayersMinimap.creep)
  clear_has_creep();
  ::SCRAPIProtocol::ImageData* temp = creep_;
  creep_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::mutable_creep() {
  set_has_creep();
  if (creep_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    creep_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayersMinimap.creep)
  return creep_;
}
inline void FeatureLayersMinimap::set_allocated_creep(::SCRAPIProtocol::ImageData* creep) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(creep_);
  }
  if (creep) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      creep = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, creep, submessage_arena);
    }
    set_has_creep();
  } else {
    clear_has_creep();
  }
  creep_ = creep;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayersMinimap.creep)
}

// optional .SCRAPIProtocol.ImageData camera = 4;
inline bool FeatureLayersMinimap::has_camera() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeatureLayersMinimap::set_has_camera() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeatureLayersMinimap::clear_has_camera() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::_internal_camera() const {
  return *camera_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::camera() const {
  const ::SCRAPIProtocol::ImageData* p = camera_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayersMinimap.camera)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::release_camera() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayersMinimap.camera)
  clear_has_camera();
  ::SCRAPIProtocol::ImageData* temp = camera_;
  camera_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::mutable_camera() {
  set_has_camera();
  if (camera_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    camera_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayersMinimap.camera)
  return camera_;
}
inline void FeatureLayersMinimap::set_allocated_camera(::SCRAPIProtocol::ImageData* camera) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(camera_);
  }
  if (camera) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      camera = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    set_has_camera();
  } else {
    clear_has_camera();
  }
  camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayersMinimap.camera)
}

// optional .SCRAPIProtocol.ImageData player_id = 5;
inline bool FeatureLayersMinimap::has_player_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeatureLayersMinimap::set_has_player_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeatureLayersMinimap::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::_internal_player_id() const {
  return *player_id_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::player_id() const {
  const ::SCRAPIProtocol::ImageData* p = player_id_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayersMinimap.player_id)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::release_player_id() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayersMinimap.player_id)
  clear_has_player_id();
  ::SCRAPIProtocol::ImageData* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    player_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayersMinimap.player_id)
  return player_id_;
}
inline void FeatureLayersMinimap::set_allocated_player_id(::SCRAPIProtocol::ImageData* player_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayersMinimap.player_id)
}

// optional .SCRAPIProtocol.ImageData player_relative = 6;
inline bool FeatureLayersMinimap::has_player_relative() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FeatureLayersMinimap::set_has_player_relative() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FeatureLayersMinimap::clear_has_player_relative() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::_internal_player_relative() const {
  return *player_relative_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::player_relative() const {
  const ::SCRAPIProtocol::ImageData* p = player_relative_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayersMinimap.player_relative)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::release_player_relative() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayersMinimap.player_relative)
  clear_has_player_relative();
  ::SCRAPIProtocol::ImageData* temp = player_relative_;
  player_relative_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::mutable_player_relative() {
  set_has_player_relative();
  if (player_relative_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    player_relative_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayersMinimap.player_relative)
  return player_relative_;
}
inline void FeatureLayersMinimap::set_allocated_player_relative(::SCRAPIProtocol::ImageData* player_relative) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(player_relative_);
  }
  if (player_relative) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_relative = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_relative, submessage_arena);
    }
    set_has_player_relative();
  } else {
    clear_has_player_relative();
  }
  player_relative_ = player_relative;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayersMinimap.player_relative)
}

// optional .SCRAPIProtocol.ImageData selected = 7;
inline bool FeatureLayersMinimap::has_selected() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FeatureLayersMinimap::set_has_selected() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FeatureLayersMinimap::clear_has_selected() {
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::_internal_selected() const {
  return *selected_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::selected() const {
  const ::SCRAPIProtocol::ImageData* p = selected_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayersMinimap.selected)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::release_selected() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayersMinimap.selected)
  clear_has_selected();
  ::SCRAPIProtocol::ImageData* temp = selected_;
  selected_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::mutable_selected() {
  set_has_selected();
  if (selected_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    selected_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayersMinimap.selected)
  return selected_;
}
inline void FeatureLayersMinimap::set_allocated_selected(::SCRAPIProtocol::ImageData* selected) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(selected_);
  }
  if (selected) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      selected = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, selected, submessage_arena);
    }
    set_has_selected();
  } else {
    clear_has_selected();
  }
  selected_ = selected;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayersMinimap.selected)
}

// optional .SCRAPIProtocol.ImageData unit_type = 8;
inline bool FeatureLayersMinimap::has_unit_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FeatureLayersMinimap::set_has_unit_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FeatureLayersMinimap::clear_has_unit_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::_internal_unit_type() const {
  return *unit_type_;
}
inline const ::SCRAPIProtocol::ImageData& FeatureLayersMinimap::unit_type() const {
  const ::SCRAPIProtocol::ImageData* p = unit_type_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.FeatureLayersMinimap.unit_type)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::release_unit_type() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.FeatureLayersMinimap.unit_type)
  clear_has_unit_type();
  ::SCRAPIProtocol::ImageData* temp = unit_type_;
  unit_type_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* FeatureLayersMinimap::mutable_unit_type() {
  set_has_unit_type();
  if (unit_type_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    unit_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.FeatureLayersMinimap.unit_type)
  return unit_type_;
}
inline void FeatureLayersMinimap::set_allocated_unit_type(::SCRAPIProtocol::ImageData* unit_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unit_type_);
  }
  if (unit_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit_type, submessage_arena);
    }
    set_has_unit_type();
  } else {
    clear_has_unit_type();
  }
  unit_type_ = unit_type;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.FeatureLayersMinimap.unit_type)
}

// -------------------------------------------------------------------

// ObservationRender

// optional .SCRAPIProtocol.ImageData map = 1;
inline bool ObservationRender::has_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObservationRender::set_has_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObservationRender::clear_has_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::ImageData& ObservationRender::_internal_map() const {
  return *map_;
}
inline const ::SCRAPIProtocol::ImageData& ObservationRender::map() const {
  const ::SCRAPIProtocol::ImageData* p = map_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationRender.map)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* ObservationRender::release_map() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationRender.map)
  clear_has_map();
  ::SCRAPIProtocol::ImageData* temp = map_;
  map_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* ObservationRender::mutable_map() {
  set_has_map();
  if (map_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    map_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationRender.map)
  return map_;
}
inline void ObservationRender::set_allocated_map(::SCRAPIProtocol::ImageData* map) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(map_);
  }
  if (map) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    set_has_map();
  } else {
    clear_has_map();
  }
  map_ = map;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ObservationRender.map)
}

// optional .SCRAPIProtocol.ImageData minimap = 2;
inline bool ObservationRender::has_minimap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObservationRender::set_has_minimap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObservationRender::clear_has_minimap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SCRAPIProtocol::ImageData& ObservationRender::_internal_minimap() const {
  return *minimap_;
}
inline const ::SCRAPIProtocol::ImageData& ObservationRender::minimap() const {
  const ::SCRAPIProtocol::ImageData* p = minimap_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationRender.minimap)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::ImageData*>(
      &::SCRAPIProtocol::_ImageData_default_instance_);
}
inline ::SCRAPIProtocol::ImageData* ObservationRender::release_minimap() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationRender.minimap)
  clear_has_minimap();
  ::SCRAPIProtocol::ImageData* temp = minimap_;
  minimap_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::ImageData* ObservationRender::mutable_minimap() {
  set_has_minimap();
  if (minimap_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::ImageData>(GetArenaNoVirtual());
    minimap_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationRender.minimap)
  return minimap_;
}
inline void ObservationRender::set_allocated_minimap(::SCRAPIProtocol::ImageData* minimap) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(minimap_);
  }
  if (minimap) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      minimap = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, minimap, submessage_arena);
    }
    set_has_minimap();
  } else {
    clear_has_minimap();
  }
  minimap_ = minimap;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ObservationRender.minimap)
}

// -------------------------------------------------------------------

// ActionSpatial

// optional .SCRAPIProtocol.ActionSpatialUnitCommand unit_command = 1;
inline bool ActionSpatial::has_unit_command() const {
  return action_case() == kUnitCommand;
}
inline void ActionSpatial::set_has_unit_command() {
  _oneof_case_[0] = kUnitCommand;
}
inline void ActionSpatial::clear_unit_command() {
  if (has_unit_command()) {
    delete action_.unit_command_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionSpatialUnitCommand& ActionSpatial::_internal_unit_command() const {
  return *action_.unit_command_;
}
inline ::SCRAPIProtocol::ActionSpatialUnitCommand* ActionSpatial::release_unit_command() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionSpatial.unit_command)
  if (has_unit_command()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionSpatialUnitCommand* temp = action_.unit_command_;
    action_.unit_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionSpatialUnitCommand& ActionSpatial::unit_command() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatial.unit_command)
  return has_unit_command()
      ? *action_.unit_command_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionSpatialUnitCommand*>(&::SCRAPIProtocol::_ActionSpatialUnitCommand_default_instance_);
}
inline ::SCRAPIProtocol::ActionSpatialUnitCommand* ActionSpatial::mutable_unit_command() {
  if (!has_unit_command()) {
    clear_action();
    set_has_unit_command();
    action_.unit_command_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionSpatialUnitCommand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionSpatial.unit_command)
  return action_.unit_command_;
}

// optional .SCRAPIProtocol.ActionSpatialCameraMove camera_move = 2;
inline bool ActionSpatial::has_camera_move() const {
  return action_case() == kCameraMove;
}
inline void ActionSpatial::set_has_camera_move() {
  _oneof_case_[0] = kCameraMove;
}
inline void ActionSpatial::clear_camera_move() {
  if (has_camera_move()) {
    delete action_.camera_move_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionSpatialCameraMove& ActionSpatial::_internal_camera_move() const {
  return *action_.camera_move_;
}
inline ::SCRAPIProtocol::ActionSpatialCameraMove* ActionSpatial::release_camera_move() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionSpatial.camera_move)
  if (has_camera_move()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionSpatialCameraMove* temp = action_.camera_move_;
    action_.camera_move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionSpatialCameraMove& ActionSpatial::camera_move() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatial.camera_move)
  return has_camera_move()
      ? *action_.camera_move_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionSpatialCameraMove*>(&::SCRAPIProtocol::_ActionSpatialCameraMove_default_instance_);
}
inline ::SCRAPIProtocol::ActionSpatialCameraMove* ActionSpatial::mutable_camera_move() {
  if (!has_camera_move()) {
    clear_action();
    set_has_camera_move();
    action_.camera_move_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionSpatialCameraMove >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionSpatial.camera_move)
  return action_.camera_move_;
}

// optional .SCRAPIProtocol.ActionSpatialUnitSelectionPoint unit_selection_point = 3;
inline bool ActionSpatial::has_unit_selection_point() const {
  return action_case() == kUnitSelectionPoint;
}
inline void ActionSpatial::set_has_unit_selection_point() {
  _oneof_case_[0] = kUnitSelectionPoint;
}
inline void ActionSpatial::clear_unit_selection_point() {
  if (has_unit_selection_point()) {
    delete action_.unit_selection_point_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint& ActionSpatial::_internal_unit_selection_point() const {
  return *action_.unit_selection_point_;
}
inline ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::release_unit_selection_point() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionSpatial.unit_selection_point)
  if (has_unit_selection_point()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint* temp = action_.unit_selection_point_;
    action_.unit_selection_point_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint& ActionSpatial::unit_selection_point() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatial.unit_selection_point)
  return has_unit_selection_point()
      ? *action_.unit_selection_point_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint*>(&::SCRAPIProtocol::_ActionSpatialUnitSelectionPoint_default_instance_);
}
inline ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::mutable_unit_selection_point() {
  if (!has_unit_selection_point()) {
    clear_action();
    set_has_unit_selection_point();
    action_.unit_selection_point_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionSpatial.unit_selection_point)
  return action_.unit_selection_point_;
}

// optional .SCRAPIProtocol.ActionSpatialUnitSelectionRect unit_selection_rect = 4;
inline bool ActionSpatial::has_unit_selection_rect() const {
  return action_case() == kUnitSelectionRect;
}
inline void ActionSpatial::set_has_unit_selection_rect() {
  _oneof_case_[0] = kUnitSelectionRect;
}
inline void ActionSpatial::clear_unit_selection_rect() {
  if (has_unit_selection_rect()) {
    delete action_.unit_selection_rect_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionSpatialUnitSelectionRect& ActionSpatial::_internal_unit_selection_rect() const {
  return *action_.unit_selection_rect_;
}
inline ::SCRAPIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::release_unit_selection_rect() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionSpatial.unit_selection_rect)
  if (has_unit_selection_rect()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionSpatialUnitSelectionRect* temp = action_.unit_selection_rect_;
    action_.unit_selection_rect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionSpatialUnitSelectionRect& ActionSpatial::unit_selection_rect() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatial.unit_selection_rect)
  return has_unit_selection_rect()
      ? *action_.unit_selection_rect_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionSpatialUnitSelectionRect*>(&::SCRAPIProtocol::_ActionSpatialUnitSelectionRect_default_instance_);
}
inline ::SCRAPIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::mutable_unit_selection_rect() {
  if (!has_unit_selection_rect()) {
    clear_action();
    set_has_unit_selection_rect();
    action_.unit_selection_rect_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionSpatialUnitSelectionRect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionSpatial.unit_selection_rect)
  return action_.unit_selection_rect_;
}

inline bool ActionSpatial::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionSpatial::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionSpatial::ActionCase ActionSpatial::action_case() const {
  return ActionSpatial::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionSpatialUnitCommand

// optional int32 ability_id = 1;
inline bool ActionSpatialUnitCommand::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSpatialUnitCommand::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSpatialUnitCommand::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionSpatialUnitCommand::clear_ability_id() {
  ability_id_ = 0;
  clear_has_ability_id();
}
inline ::google::protobuf::int32 ActionSpatialUnitCommand::ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatialUnitCommand.ability_id)
  return ability_id_;
}
inline void ActionSpatialUnitCommand::set_ability_id(::google::protobuf::int32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionSpatialUnitCommand.ability_id)
}

// optional .SCRAPIProtocol.PointI target_screen_coord = 2;
inline bool ActionSpatialUnitCommand::has_target_screen_coord() const {
  return target_case() == kTargetScreenCoord;
}
inline void ActionSpatialUnitCommand::set_has_target_screen_coord() {
  _oneof_case_[0] = kTargetScreenCoord;
}
inline const ::SCRAPIProtocol::PointI& ActionSpatialUnitCommand::_internal_target_screen_coord() const {
  return *target_.target_screen_coord_;
}
inline ::SCRAPIProtocol::PointI* ActionSpatialUnitCommand::release_target_screen_coord() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  if (has_target_screen_coord()) {
    clear_has_target();
      ::SCRAPIProtocol::PointI* temp = target_.target_screen_coord_;
    target_.target_screen_coord_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::PointI& ActionSpatialUnitCommand::target_screen_coord() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  return has_target_screen_coord()
      ? *target_.target_screen_coord_
      : *reinterpret_cast< ::SCRAPIProtocol::PointI*>(&::SCRAPIProtocol::_PointI_default_instance_);
}
inline ::SCRAPIProtocol::PointI* ActionSpatialUnitCommand::mutable_target_screen_coord() {
  if (!has_target_screen_coord()) {
    clear_target();
    set_has_target_screen_coord();
    target_.target_screen_coord_ = CreateMaybeMessage< ::SCRAPIProtocol::PointI >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  return target_.target_screen_coord_;
}

// optional .SCRAPIProtocol.PointI target_minimap_coord = 3;
inline bool ActionSpatialUnitCommand::has_target_minimap_coord() const {
  return target_case() == kTargetMinimapCoord;
}
inline void ActionSpatialUnitCommand::set_has_target_minimap_coord() {
  _oneof_case_[0] = kTargetMinimapCoord;
}
inline const ::SCRAPIProtocol::PointI& ActionSpatialUnitCommand::_internal_target_minimap_coord() const {
  return *target_.target_minimap_coord_;
}
inline ::SCRAPIProtocol::PointI* ActionSpatialUnitCommand::release_target_minimap_coord() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  if (has_target_minimap_coord()) {
    clear_has_target();
      ::SCRAPIProtocol::PointI* temp = target_.target_minimap_coord_;
    target_.target_minimap_coord_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::PointI& ActionSpatialUnitCommand::target_minimap_coord() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  return has_target_minimap_coord()
      ? *target_.target_minimap_coord_
      : *reinterpret_cast< ::SCRAPIProtocol::PointI*>(&::SCRAPIProtocol::_PointI_default_instance_);
}
inline ::SCRAPIProtocol::PointI* ActionSpatialUnitCommand::mutable_target_minimap_coord() {
  if (!has_target_minimap_coord()) {
    clear_target();
    set_has_target_minimap_coord();
    target_.target_minimap_coord_ = CreateMaybeMessage< ::SCRAPIProtocol::PointI >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  return target_.target_minimap_coord_;
}

// optional bool queue_command = 4;
inline bool ActionSpatialUnitCommand::has_queue_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionSpatialUnitCommand::set_has_queue_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionSpatialUnitCommand::clear_has_queue_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionSpatialUnitCommand::clear_queue_command() {
  queue_command_ = false;
  clear_has_queue_command();
}
inline bool ActionSpatialUnitCommand::queue_command() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatialUnitCommand.queue_command)
  return queue_command_;
}
inline void ActionSpatialUnitCommand::set_queue_command(bool value) {
  set_has_queue_command();
  queue_command_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionSpatialUnitCommand.queue_command)
}

inline bool ActionSpatialUnitCommand::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void ActionSpatialUnitCommand::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline ActionSpatialUnitCommand::TargetCase ActionSpatialUnitCommand::target_case() const {
  return ActionSpatialUnitCommand::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionSpatialCameraMove

// optional .SCRAPIProtocol.PointI center_minimap = 1;
inline bool ActionSpatialCameraMove::has_center_minimap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSpatialCameraMove::set_has_center_minimap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSpatialCameraMove::clear_has_center_minimap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::PointI& ActionSpatialCameraMove::_internal_center_minimap() const {
  return *center_minimap_;
}
inline const ::SCRAPIProtocol::PointI& ActionSpatialCameraMove::center_minimap() const {
  const ::SCRAPIProtocol::PointI* p = center_minimap_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatialCameraMove.center_minimap)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::PointI*>(
      &::SCRAPIProtocol::_PointI_default_instance_);
}
inline ::SCRAPIProtocol::PointI* ActionSpatialCameraMove::release_center_minimap() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionSpatialCameraMove.center_minimap)
  clear_has_center_minimap();
  ::SCRAPIProtocol::PointI* temp = center_minimap_;
  center_minimap_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::PointI* ActionSpatialCameraMove::mutable_center_minimap() {
  set_has_center_minimap();
  if (center_minimap_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::PointI>(GetArenaNoVirtual());
    center_minimap_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionSpatialCameraMove.center_minimap)
  return center_minimap_;
}
inline void ActionSpatialCameraMove::set_allocated_center_minimap(::SCRAPIProtocol::PointI* center_minimap) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(center_minimap_);
  }
  if (center_minimap) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center_minimap = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center_minimap, submessage_arena);
    }
    set_has_center_minimap();
  } else {
    clear_has_center_minimap();
  }
  center_minimap_ = center_minimap;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ActionSpatialCameraMove.center_minimap)
}

// -------------------------------------------------------------------

// ActionSpatialUnitSelectionPoint

// optional .SCRAPIProtocol.PointI selection_screen_coord = 1;
inline bool ActionSpatialUnitSelectionPoint::has_selection_screen_coord() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSpatialUnitSelectionPoint::set_has_selection_screen_coord() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSpatialUnitSelectionPoint::clear_has_selection_screen_coord() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SCRAPIProtocol::PointI& ActionSpatialUnitSelectionPoint::_internal_selection_screen_coord() const {
  return *selection_screen_coord_;
}
inline const ::SCRAPIProtocol::PointI& ActionSpatialUnitSelectionPoint::selection_screen_coord() const {
  const ::SCRAPIProtocol::PointI* p = selection_screen_coord_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::PointI*>(
      &::SCRAPIProtocol::_PointI_default_instance_);
}
inline ::SCRAPIProtocol::PointI* ActionSpatialUnitSelectionPoint::release_selection_screen_coord() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  clear_has_selection_screen_coord();
  ::SCRAPIProtocol::PointI* temp = selection_screen_coord_;
  selection_screen_coord_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::PointI* ActionSpatialUnitSelectionPoint::mutable_selection_screen_coord() {
  set_has_selection_screen_coord();
  if (selection_screen_coord_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::PointI>(GetArenaNoVirtual());
    selection_screen_coord_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  return selection_screen_coord_;
}
inline void ActionSpatialUnitSelectionPoint::set_allocated_selection_screen_coord(::SCRAPIProtocol::PointI* selection_screen_coord) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(selection_screen_coord_);
  }
  if (selection_screen_coord) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      selection_screen_coord = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, selection_screen_coord, submessage_arena);
    }
    set_has_selection_screen_coord();
  } else {
    clear_has_selection_screen_coord();
  }
  selection_screen_coord_ = selection_screen_coord;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
}

// optional .SCRAPIProtocol.ActionSpatialUnitSelectionPoint.Type type = 2;
inline bool ActionSpatialUnitSelectionPoint::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionSpatialUnitSelectionPoint::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionSpatialUnitSelectionPoint::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionSpatialUnitSelectionPoint::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint::type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatialUnitSelectionPoint.type)
  return static_cast< ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint_Type >(type_);
}
inline void ActionSpatialUnitSelectionPoint::set_type(::SCRAPIProtocol::ActionSpatialUnitSelectionPoint_Type value) {
  assert(::SCRAPIProtocol::ActionSpatialUnitSelectionPoint_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionSpatialUnitSelectionPoint.type)
}

// -------------------------------------------------------------------

// ActionSpatialUnitSelectionRect

// repeated .SCRAPIProtocol.RectangleI selection_screen_coord = 1;
inline int ActionSpatialUnitSelectionRect::selection_screen_coord_size() const {
  return selection_screen_coord_.size();
}
inline ::SCRAPIProtocol::RectangleI* ActionSpatialUnitSelectionRect::mutable_selection_screen_coord(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return selection_screen_coord_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::RectangleI >*
ActionSpatialUnitSelectionRect::mutable_selection_screen_coord() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return &selection_screen_coord_;
}
inline const ::SCRAPIProtocol::RectangleI& ActionSpatialUnitSelectionRect::selection_screen_coord(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return selection_screen_coord_.Get(index);
}
inline ::SCRAPIProtocol::RectangleI* ActionSpatialUnitSelectionRect::add_selection_screen_coord() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return selection_screen_coord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::RectangleI >&
ActionSpatialUnitSelectionRect::selection_screen_coord() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return selection_screen_coord_;
}

// optional bool selection_add = 2;
inline bool ActionSpatialUnitSelectionRect::has_selection_add() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSpatialUnitSelectionRect::set_has_selection_add() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSpatialUnitSelectionRect::clear_has_selection_add() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionSpatialUnitSelectionRect::clear_selection_add() {
  selection_add_ = false;
  clear_has_selection_add();
}
inline bool ActionSpatialUnitSelectionRect::selection_add() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSpatialUnitSelectionRect.selection_add)
  return selection_add_;
}
inline void ActionSpatialUnitSelectionRect::set_selection_add(bool value) {
  set_has_selection_add();
  selection_add_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionSpatialUnitSelectionRect.selection_add)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SCRAPIProtocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint_Type>() {
  return ::SCRAPIProtocol::ActionSpatialUnitSelectionPoint_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_spatial_2eproto
