// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ui.proto

#ifndef PROTOBUF_INCLUDED_ui_2eproto
#define PROTOBUF_INCLUDED_ui_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ui_2eproto 

namespace protobuf_ui_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ui_2eproto
namespace SCRAPIProtocol {
class ActionCargoPanelUnload;
class ActionCargoPanelUnloadDefaultTypeInternal;
extern ActionCargoPanelUnloadDefaultTypeInternal _ActionCargoPanelUnload_default_instance_;
class ActionControlGroup;
class ActionControlGroupDefaultTypeInternal;
extern ActionControlGroupDefaultTypeInternal _ActionControlGroup_default_instance_;
class ActionMultiPanel;
class ActionMultiPanelDefaultTypeInternal;
extern ActionMultiPanelDefaultTypeInternal _ActionMultiPanel_default_instance_;
class ActionProductionPanelRemoveFromQueue;
class ActionProductionPanelRemoveFromQueueDefaultTypeInternal;
extern ActionProductionPanelRemoveFromQueueDefaultTypeInternal _ActionProductionPanelRemoveFromQueue_default_instance_;
class ActionSelectArmy;
class ActionSelectArmyDefaultTypeInternal;
extern ActionSelectArmyDefaultTypeInternal _ActionSelectArmy_default_instance_;
class ActionSelectIdleWorker;
class ActionSelectIdleWorkerDefaultTypeInternal;
extern ActionSelectIdleWorkerDefaultTypeInternal _ActionSelectIdleWorker_default_instance_;
class ActionSelectLarva;
class ActionSelectLarvaDefaultTypeInternal;
extern ActionSelectLarvaDefaultTypeInternal _ActionSelectLarva_default_instance_;
class ActionSelectWarpGates;
class ActionSelectWarpGatesDefaultTypeInternal;
extern ActionSelectWarpGatesDefaultTypeInternal _ActionSelectWarpGates_default_instance_;
class ActionToggleAutocast;
class ActionToggleAutocastDefaultTypeInternal;
extern ActionToggleAutocastDefaultTypeInternal _ActionToggleAutocast_default_instance_;
class ActionUI;
class ActionUIDefaultTypeInternal;
extern ActionUIDefaultTypeInternal _ActionUI_default_instance_;
class CargoPanel;
class CargoPanelDefaultTypeInternal;
extern CargoPanelDefaultTypeInternal _CargoPanel_default_instance_;
class ControlGroup;
class ControlGroupDefaultTypeInternal;
extern ControlGroupDefaultTypeInternal _ControlGroup_default_instance_;
class MultiPanel;
class MultiPanelDefaultTypeInternal;
extern MultiPanelDefaultTypeInternal _MultiPanel_default_instance_;
class ObservationUI;
class ObservationUIDefaultTypeInternal;
extern ObservationUIDefaultTypeInternal _ObservationUI_default_instance_;
class ProductionPanel;
class ProductionPanelDefaultTypeInternal;
extern ProductionPanelDefaultTypeInternal _ProductionPanel_default_instance_;
class SinglePanel;
class SinglePanelDefaultTypeInternal;
extern SinglePanelDefaultTypeInternal _SinglePanel_default_instance_;
class UnitInfo;
class UnitInfoDefaultTypeInternal;
extern UnitInfoDefaultTypeInternal _UnitInfo_default_instance_;
}  // namespace SCRAPIProtocol
namespace google {
namespace protobuf {
template<> ::SCRAPIProtocol::ActionCargoPanelUnload* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionCargoPanelUnload>(Arena*);
template<> ::SCRAPIProtocol::ActionControlGroup* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionControlGroup>(Arena*);
template<> ::SCRAPIProtocol::ActionMultiPanel* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionMultiPanel>(Arena*);
template<> ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue>(Arena*);
template<> ::SCRAPIProtocol::ActionSelectArmy* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionSelectArmy>(Arena*);
template<> ::SCRAPIProtocol::ActionSelectIdleWorker* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionSelectIdleWorker>(Arena*);
template<> ::SCRAPIProtocol::ActionSelectLarva* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionSelectLarva>(Arena*);
template<> ::SCRAPIProtocol::ActionSelectWarpGates* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionSelectWarpGates>(Arena*);
template<> ::SCRAPIProtocol::ActionToggleAutocast* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionToggleAutocast>(Arena*);
template<> ::SCRAPIProtocol::ActionUI* Arena::CreateMaybeMessage<::SCRAPIProtocol::ActionUI>(Arena*);
template<> ::SCRAPIProtocol::CargoPanel* Arena::CreateMaybeMessage<::SCRAPIProtocol::CargoPanel>(Arena*);
template<> ::SCRAPIProtocol::ControlGroup* Arena::CreateMaybeMessage<::SCRAPIProtocol::ControlGroup>(Arena*);
template<> ::SCRAPIProtocol::MultiPanel* Arena::CreateMaybeMessage<::SCRAPIProtocol::MultiPanel>(Arena*);
template<> ::SCRAPIProtocol::ObservationUI* Arena::CreateMaybeMessage<::SCRAPIProtocol::ObservationUI>(Arena*);
template<> ::SCRAPIProtocol::ProductionPanel* Arena::CreateMaybeMessage<::SCRAPIProtocol::ProductionPanel>(Arena*);
template<> ::SCRAPIProtocol::SinglePanel* Arena::CreateMaybeMessage<::SCRAPIProtocol::SinglePanel>(Arena*);
template<> ::SCRAPIProtocol::UnitInfo* Arena::CreateMaybeMessage<::SCRAPIProtocol::UnitInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace SCRAPIProtocol {

enum ActionControlGroup_ControlGroupAction {
  ActionControlGroup_ControlGroupAction_Recall = 1,
  ActionControlGroup_ControlGroupAction_Set = 2,
  ActionControlGroup_ControlGroupAction_Append = 3,
  ActionControlGroup_ControlGroupAction_SetAndSteal = 4,
  ActionControlGroup_ControlGroupAction_AppendAndSteal = 5
};
bool ActionControlGroup_ControlGroupAction_IsValid(int value);
const ActionControlGroup_ControlGroupAction ActionControlGroup_ControlGroupAction_ControlGroupAction_MIN = ActionControlGroup_ControlGroupAction_Recall;
const ActionControlGroup_ControlGroupAction ActionControlGroup_ControlGroupAction_ControlGroupAction_MAX = ActionControlGroup_ControlGroupAction_AppendAndSteal;
const int ActionControlGroup_ControlGroupAction_ControlGroupAction_ARRAYSIZE = ActionControlGroup_ControlGroupAction_ControlGroupAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionControlGroup_ControlGroupAction_descriptor();
inline const ::std::string& ActionControlGroup_ControlGroupAction_Name(ActionControlGroup_ControlGroupAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionControlGroup_ControlGroupAction_descriptor(), value);
}
inline bool ActionControlGroup_ControlGroupAction_Parse(
    const ::std::string& name, ActionControlGroup_ControlGroupAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionControlGroup_ControlGroupAction>(
    ActionControlGroup_ControlGroupAction_descriptor(), name, value);
}
enum ActionSelectIdleWorker_Type {
  ActionSelectIdleWorker_Type_Set = 1,
  ActionSelectIdleWorker_Type_Add = 2,
  ActionSelectIdleWorker_Type_All = 3,
  ActionSelectIdleWorker_Type_AddAll = 4
};
bool ActionSelectIdleWorker_Type_IsValid(int value);
const ActionSelectIdleWorker_Type ActionSelectIdleWorker_Type_Type_MIN = ActionSelectIdleWorker_Type_Set;
const ActionSelectIdleWorker_Type ActionSelectIdleWorker_Type_Type_MAX = ActionSelectIdleWorker_Type_AddAll;
const int ActionSelectIdleWorker_Type_Type_ARRAYSIZE = ActionSelectIdleWorker_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionSelectIdleWorker_Type_descriptor();
inline const ::std::string& ActionSelectIdleWorker_Type_Name(ActionSelectIdleWorker_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionSelectIdleWorker_Type_descriptor(), value);
}
inline bool ActionSelectIdleWorker_Type_Parse(
    const ::std::string& name, ActionSelectIdleWorker_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionSelectIdleWorker_Type>(
    ActionSelectIdleWorker_Type_descriptor(), name, value);
}
enum ActionMultiPanel_Type {
  ActionMultiPanel_Type_SingleSelect = 1,
  ActionMultiPanel_Type_DeselectUnit = 2,
  ActionMultiPanel_Type_SelectAllOfType = 3,
  ActionMultiPanel_Type_DeselectAllOfType = 4
};
bool ActionMultiPanel_Type_IsValid(int value);
const ActionMultiPanel_Type ActionMultiPanel_Type_Type_MIN = ActionMultiPanel_Type_SingleSelect;
const ActionMultiPanel_Type ActionMultiPanel_Type_Type_MAX = ActionMultiPanel_Type_DeselectAllOfType;
const int ActionMultiPanel_Type_Type_ARRAYSIZE = ActionMultiPanel_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionMultiPanel_Type_descriptor();
inline const ::std::string& ActionMultiPanel_Type_Name(ActionMultiPanel_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionMultiPanel_Type_descriptor(), value);
}
inline bool ActionMultiPanel_Type_Parse(
    const ::std::string& name, ActionMultiPanel_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionMultiPanel_Type>(
    ActionMultiPanel_Type_descriptor(), name, value);
}
// ===================================================================

class ObservationUI : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ObservationUI) */ {
 public:
  ObservationUI();
  virtual ~ObservationUI();

  ObservationUI(const ObservationUI& from);

  inline ObservationUI& operator=(const ObservationUI& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObservationUI(ObservationUI&& from) noexcept
    : ObservationUI() {
    *this = ::std::move(from);
  }

  inline ObservationUI& operator=(ObservationUI&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObservationUI& default_instance();

  enum PanelCase {
    kSingle = 2,
    kMulti = 3,
    kCargo = 4,
    kProduction = 5,
    PANEL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObservationUI* internal_default_instance() {
    return reinterpret_cast<const ObservationUI*>(
               &_ObservationUI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ObservationUI* other);
  friend void swap(ObservationUI& a, ObservationUI& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObservationUI* New() const final {
    return CreateMaybeMessage<ObservationUI>(NULL);
  }

  ObservationUI* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObservationUI>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObservationUI& from);
  void MergeFrom(const ObservationUI& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObservationUI* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.ControlGroup groups = 1;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 1;
  ::SCRAPIProtocol::ControlGroup* mutable_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ControlGroup >*
      mutable_groups();
  const ::SCRAPIProtocol::ControlGroup& groups(int index) const;
  ::SCRAPIProtocol::ControlGroup* add_groups();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ControlGroup >&
      groups() const;

  // optional .SCRAPIProtocol.SinglePanel single = 2;
  bool has_single() const;
  void clear_single();
  static const int kSingleFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::SinglePanel& _internal_single() const;
  public:
  const ::SCRAPIProtocol::SinglePanel& single() const;
  ::SCRAPIProtocol::SinglePanel* release_single();
  ::SCRAPIProtocol::SinglePanel* mutable_single();
  void set_allocated_single(::SCRAPIProtocol::SinglePanel* single);

  // optional .SCRAPIProtocol.MultiPanel multi = 3;
  bool has_multi() const;
  void clear_multi();
  static const int kMultiFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::MultiPanel& _internal_multi() const;
  public:
  const ::SCRAPIProtocol::MultiPanel& multi() const;
  ::SCRAPIProtocol::MultiPanel* release_multi();
  ::SCRAPIProtocol::MultiPanel* mutable_multi();
  void set_allocated_multi(::SCRAPIProtocol::MultiPanel* multi);

  // optional .SCRAPIProtocol.CargoPanel cargo = 4;
  bool has_cargo() const;
  void clear_cargo();
  static const int kCargoFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::CargoPanel& _internal_cargo() const;
  public:
  const ::SCRAPIProtocol::CargoPanel& cargo() const;
  ::SCRAPIProtocol::CargoPanel* release_cargo();
  ::SCRAPIProtocol::CargoPanel* mutable_cargo();
  void set_allocated_cargo(::SCRAPIProtocol::CargoPanel* cargo);

  // optional .SCRAPIProtocol.ProductionPanel production = 5;
  bool has_production() const;
  void clear_production();
  static const int kProductionFieldNumber = 5;
  private:
  const ::SCRAPIProtocol::ProductionPanel& _internal_production() const;
  public:
  const ::SCRAPIProtocol::ProductionPanel& production() const;
  ::SCRAPIProtocol::ProductionPanel* release_production();
  ::SCRAPIProtocol::ProductionPanel* mutable_production();
  void set_allocated_production(::SCRAPIProtocol::ProductionPanel* production);

  void clear_panel();
  PanelCase panel_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ObservationUI)
 private:
  void set_has_single();
  void set_has_multi();
  void set_has_cargo();
  void set_has_production();

  inline bool has_panel() const;
  inline void clear_has_panel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ControlGroup > groups_;
  union PanelUnion {
    PanelUnion() {}
    ::SCRAPIProtocol::SinglePanel* single_;
    ::SCRAPIProtocol::MultiPanel* multi_;
    ::SCRAPIProtocol::CargoPanel* cargo_;
    ::SCRAPIProtocol::ProductionPanel* production_;
  } panel_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControlGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ControlGroup) */ {
 public:
  ControlGroup();
  virtual ~ControlGroup();

  ControlGroup(const ControlGroup& from);

  inline ControlGroup& operator=(const ControlGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlGroup(ControlGroup&& from) noexcept
    : ControlGroup() {
    *this = ::std::move(from);
  }

  inline ControlGroup& operator=(ControlGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlGroup* internal_default_instance() {
    return reinterpret_cast<const ControlGroup*>(
               &_ControlGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ControlGroup* other);
  friend void swap(ControlGroup& a, ControlGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlGroup* New() const final {
    return CreateMaybeMessage<ControlGroup>(NULL);
  }

  ControlGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlGroup& from);
  void MergeFrom(const ControlGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 control_group_index = 1;
  bool has_control_group_index() const;
  void clear_control_group_index();
  static const int kControlGroupIndexFieldNumber = 1;
  ::google::protobuf::uint32 control_group_index() const;
  void set_control_group_index(::google::protobuf::uint32 value);

  // optional uint32 leader_unit_type = 2;
  bool has_leader_unit_type() const;
  void clear_leader_unit_type();
  static const int kLeaderUnitTypeFieldNumber = 2;
  ::google::protobuf::uint32 leader_unit_type() const;
  void set_leader_unit_type(::google::protobuf::uint32 value);

  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ControlGroup)
 private:
  void set_has_control_group_index();
  void clear_has_control_group_index();
  void set_has_leader_unit_type();
  void clear_has_leader_unit_type();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 control_group_index_;
  ::google::protobuf::uint32 leader_unit_type_;
  ::google::protobuf::uint32 count_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.UnitInfo) */ {
 public:
  UnitInfo();
  virtual ~UnitInfo();

  UnitInfo(const UnitInfo& from);

  inline UnitInfo& operator=(const UnitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitInfo(UnitInfo&& from) noexcept
    : UnitInfo() {
    *this = ::std::move(from);
  }

  inline UnitInfo& operator=(UnitInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitInfo* internal_default_instance() {
    return reinterpret_cast<const UnitInfo*>(
               &_UnitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UnitInfo* other);
  friend void swap(UnitInfo& a, UnitInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitInfo* New() const final {
    return CreateMaybeMessage<UnitInfo>(NULL);
  }

  UnitInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitInfo& from);
  void MergeFrom(const UnitInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.UnitInfo add_on = 8;
  bool has_add_on() const;
  void clear_add_on();
  static const int kAddOnFieldNumber = 8;
  private:
  const ::SCRAPIProtocol::UnitInfo& _internal_add_on() const;
  public:
  const ::SCRAPIProtocol::UnitInfo& add_on() const;
  ::SCRAPIProtocol::UnitInfo* release_add_on();
  ::SCRAPIProtocol::UnitInfo* mutable_add_on();
  void set_allocated_add_on(::SCRAPIProtocol::UnitInfo* add_on);

  // optional uint32 unit_type = 1;
  bool has_unit_type() const;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 1;
  ::google::protobuf::uint32 unit_type() const;
  void set_unit_type(::google::protobuf::uint32 value);

  // optional uint32 player_relative = 2;
  bool has_player_relative() const;
  void clear_player_relative();
  static const int kPlayerRelativeFieldNumber = 2;
  ::google::protobuf::uint32 player_relative() const;
  void set_player_relative(::google::protobuf::uint32 value);

  // optional int32 health = 3;
  bool has_health() const;
  void clear_health();
  static const int kHealthFieldNumber = 3;
  ::google::protobuf::int32 health() const;
  void set_health(::google::protobuf::int32 value);

  // optional int32 shields = 4;
  bool has_shields() const;
  void clear_shields();
  static const int kShieldsFieldNumber = 4;
  ::google::protobuf::int32 shields() const;
  void set_shields(::google::protobuf::int32 value);

  // optional int32 energy = 5;
  bool has_energy() const;
  void clear_energy();
  static const int kEnergyFieldNumber = 5;
  ::google::protobuf::int32 energy() const;
  void set_energy(::google::protobuf::int32 value);

  // optional int32 transport_slots_taken = 6;
  bool has_transport_slots_taken() const;
  void clear_transport_slots_taken();
  static const int kTransportSlotsTakenFieldNumber = 6;
  ::google::protobuf::int32 transport_slots_taken() const;
  void set_transport_slots_taken(::google::protobuf::int32 value);

  // optional float build_progress = 7;
  bool has_build_progress() const;
  void clear_build_progress();
  static const int kBuildProgressFieldNumber = 7;
  float build_progress() const;
  void set_build_progress(float value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.UnitInfo)
 private:
  void set_has_unit_type();
  void clear_has_unit_type();
  void set_has_player_relative();
  void clear_has_player_relative();
  void set_has_health();
  void clear_has_health();
  void set_has_shields();
  void clear_has_shields();
  void set_has_energy();
  void clear_has_energy();
  void set_has_transport_slots_taken();
  void clear_has_transport_slots_taken();
  void set_has_build_progress();
  void clear_has_build_progress();
  void set_has_add_on();
  void clear_has_add_on();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::UnitInfo* add_on_;
  ::google::protobuf::uint32 unit_type_;
  ::google::protobuf::uint32 player_relative_;
  ::google::protobuf::int32 health_;
  ::google::protobuf::int32 shields_;
  ::google::protobuf::int32 energy_;
  ::google::protobuf::int32 transport_slots_taken_;
  float build_progress_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SinglePanel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.SinglePanel) */ {
 public:
  SinglePanel();
  virtual ~SinglePanel();

  SinglePanel(const SinglePanel& from);

  inline SinglePanel& operator=(const SinglePanel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SinglePanel(SinglePanel&& from) noexcept
    : SinglePanel() {
    *this = ::std::move(from);
  }

  inline SinglePanel& operator=(SinglePanel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SinglePanel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SinglePanel* internal_default_instance() {
    return reinterpret_cast<const SinglePanel*>(
               &_SinglePanel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SinglePanel* other);
  friend void swap(SinglePanel& a, SinglePanel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SinglePanel* New() const final {
    return CreateMaybeMessage<SinglePanel>(NULL);
  }

  SinglePanel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SinglePanel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SinglePanel& from);
  void MergeFrom(const SinglePanel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SinglePanel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.UnitInfo unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::UnitInfo& _internal_unit() const;
  public:
  const ::SCRAPIProtocol::UnitInfo& unit() const;
  ::SCRAPIProtocol::UnitInfo* release_unit();
  ::SCRAPIProtocol::UnitInfo* mutable_unit();
  void set_allocated_unit(::SCRAPIProtocol::UnitInfo* unit);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.SinglePanel)
 private:
  void set_has_unit();
  void clear_has_unit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SCRAPIProtocol::UnitInfo* unit_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiPanel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.MultiPanel) */ {
 public:
  MultiPanel();
  virtual ~MultiPanel();

  MultiPanel(const MultiPanel& from);

  inline MultiPanel& operator=(const MultiPanel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiPanel(MultiPanel&& from) noexcept
    : MultiPanel() {
    *this = ::std::move(from);
  }

  inline MultiPanel& operator=(MultiPanel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiPanel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiPanel* internal_default_instance() {
    return reinterpret_cast<const MultiPanel*>(
               &_MultiPanel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MultiPanel* other);
  friend void swap(MultiPanel& a, MultiPanel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiPanel* New() const final {
    return CreateMaybeMessage<MultiPanel>(NULL);
  }

  MultiPanel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiPanel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiPanel& from);
  void MergeFrom(const MultiPanel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiPanel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.UnitInfo units = 1;
  int units_size() const;
  void clear_units();
  static const int kUnitsFieldNumber = 1;
  ::SCRAPIProtocol::UnitInfo* mutable_units(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >*
      mutable_units();
  const ::SCRAPIProtocol::UnitInfo& units(int index) const;
  ::SCRAPIProtocol::UnitInfo* add_units();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >&
      units() const;

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.MultiPanel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo > units_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CargoPanel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.CargoPanel) */ {
 public:
  CargoPanel();
  virtual ~CargoPanel();

  CargoPanel(const CargoPanel& from);

  inline CargoPanel& operator=(const CargoPanel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CargoPanel(CargoPanel&& from) noexcept
    : CargoPanel() {
    *this = ::std::move(from);
  }

  inline CargoPanel& operator=(CargoPanel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CargoPanel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CargoPanel* internal_default_instance() {
    return reinterpret_cast<const CargoPanel*>(
               &_CargoPanel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CargoPanel* other);
  friend void swap(CargoPanel& a, CargoPanel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CargoPanel* New() const final {
    return CreateMaybeMessage<CargoPanel>(NULL);
  }

  CargoPanel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CargoPanel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CargoPanel& from);
  void MergeFrom(const CargoPanel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CargoPanel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.UnitInfo passengers = 2;
  int passengers_size() const;
  void clear_passengers();
  static const int kPassengersFieldNumber = 2;
  ::SCRAPIProtocol::UnitInfo* mutable_passengers(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >*
      mutable_passengers();
  const ::SCRAPIProtocol::UnitInfo& passengers(int index) const;
  ::SCRAPIProtocol::UnitInfo* add_passengers();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >&
      passengers() const;

  // optional .SCRAPIProtocol.UnitInfo unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::UnitInfo& _internal_unit() const;
  public:
  const ::SCRAPIProtocol::UnitInfo& unit() const;
  ::SCRAPIProtocol::UnitInfo* release_unit();
  ::SCRAPIProtocol::UnitInfo* mutable_unit();
  void set_allocated_unit(::SCRAPIProtocol::UnitInfo* unit);

  // optional int32 slots_available = 3;
  bool has_slots_available() const;
  void clear_slots_available();
  static const int kSlotsAvailableFieldNumber = 3;
  ::google::protobuf::int32 slots_available() const;
  void set_slots_available(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.CargoPanel)
 private:
  void set_has_unit();
  void clear_has_unit();
  void set_has_slots_available();
  void clear_has_slots_available();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo > passengers_;
  ::SCRAPIProtocol::UnitInfo* unit_;
  ::google::protobuf::int32 slots_available_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProductionPanel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ProductionPanel) */ {
 public:
  ProductionPanel();
  virtual ~ProductionPanel();

  ProductionPanel(const ProductionPanel& from);

  inline ProductionPanel& operator=(const ProductionPanel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProductionPanel(ProductionPanel&& from) noexcept
    : ProductionPanel() {
    *this = ::std::move(from);
  }

  inline ProductionPanel& operator=(ProductionPanel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductionPanel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProductionPanel* internal_default_instance() {
    return reinterpret_cast<const ProductionPanel*>(
               &_ProductionPanel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ProductionPanel* other);
  friend void swap(ProductionPanel& a, ProductionPanel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProductionPanel* New() const final {
    return CreateMaybeMessage<ProductionPanel>(NULL);
  }

  ProductionPanel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProductionPanel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProductionPanel& from);
  void MergeFrom(const ProductionPanel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductionPanel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCRAPIProtocol.UnitInfo build_queue = 2;
  int build_queue_size() const;
  void clear_build_queue();
  static const int kBuildQueueFieldNumber = 2;
  ::SCRAPIProtocol::UnitInfo* mutable_build_queue(int index);
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >*
      mutable_build_queue();
  const ::SCRAPIProtocol::UnitInfo& build_queue(int index) const;
  ::SCRAPIProtocol::UnitInfo* add_build_queue();
  const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >&
      build_queue() const;

  // optional .SCRAPIProtocol.UnitInfo unit = 1;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::UnitInfo& _internal_unit() const;
  public:
  const ::SCRAPIProtocol::UnitInfo& unit() const;
  ::SCRAPIProtocol::UnitInfo* release_unit();
  ::SCRAPIProtocol::UnitInfo* mutable_unit();
  void set_allocated_unit(::SCRAPIProtocol::UnitInfo* unit);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ProductionPanel)
 private:
  void set_has_unit();
  void clear_has_unit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo > build_queue_;
  ::SCRAPIProtocol::UnitInfo* unit_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionUI : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionUI) */ {
 public:
  ActionUI();
  virtual ~ActionUI();

  ActionUI(const ActionUI& from);

  inline ActionUI& operator=(const ActionUI& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionUI(ActionUI&& from) noexcept
    : ActionUI() {
    *this = ::std::move(from);
  }

  inline ActionUI& operator=(ActionUI&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionUI& default_instance();

  enum ActionCase {
    kControlGroup = 1,
    kSelectArmy = 2,
    kSelectWarpGates = 3,
    kSelectLarva = 4,
    kSelectIdleWorker = 5,
    kMultiPanel = 6,
    kCargoPanel = 7,
    kProductionPanel = 8,
    kToggleAutocast = 9,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionUI* internal_default_instance() {
    return reinterpret_cast<const ActionUI*>(
               &_ActionUI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ActionUI* other);
  friend void swap(ActionUI& a, ActionUI& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionUI* New() const final {
    return CreateMaybeMessage<ActionUI>(NULL);
  }

  ActionUI* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionUI>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionUI& from);
  void MergeFrom(const ActionUI& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionUI* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ActionControlGroup control_group = 1;
  bool has_control_group() const;
  void clear_control_group();
  static const int kControlGroupFieldNumber = 1;
  private:
  const ::SCRAPIProtocol::ActionControlGroup& _internal_control_group() const;
  public:
  const ::SCRAPIProtocol::ActionControlGroup& control_group() const;
  ::SCRAPIProtocol::ActionControlGroup* release_control_group();
  ::SCRAPIProtocol::ActionControlGroup* mutable_control_group();
  void set_allocated_control_group(::SCRAPIProtocol::ActionControlGroup* control_group);

  // optional .SCRAPIProtocol.ActionSelectArmy select_army = 2;
  bool has_select_army() const;
  void clear_select_army();
  static const int kSelectArmyFieldNumber = 2;
  private:
  const ::SCRAPIProtocol::ActionSelectArmy& _internal_select_army() const;
  public:
  const ::SCRAPIProtocol::ActionSelectArmy& select_army() const;
  ::SCRAPIProtocol::ActionSelectArmy* release_select_army();
  ::SCRAPIProtocol::ActionSelectArmy* mutable_select_army();
  void set_allocated_select_army(::SCRAPIProtocol::ActionSelectArmy* select_army);

  // optional .SCRAPIProtocol.ActionSelectWarpGates select_warp_gates = 3;
  bool has_select_warp_gates() const;
  void clear_select_warp_gates();
  static const int kSelectWarpGatesFieldNumber = 3;
  private:
  const ::SCRAPIProtocol::ActionSelectWarpGates& _internal_select_warp_gates() const;
  public:
  const ::SCRAPIProtocol::ActionSelectWarpGates& select_warp_gates() const;
  ::SCRAPIProtocol::ActionSelectWarpGates* release_select_warp_gates();
  ::SCRAPIProtocol::ActionSelectWarpGates* mutable_select_warp_gates();
  void set_allocated_select_warp_gates(::SCRAPIProtocol::ActionSelectWarpGates* select_warp_gates);

  // optional .SCRAPIProtocol.ActionSelectLarva select_larva = 4;
  bool has_select_larva() const;
  void clear_select_larva();
  static const int kSelectLarvaFieldNumber = 4;
  private:
  const ::SCRAPIProtocol::ActionSelectLarva& _internal_select_larva() const;
  public:
  const ::SCRAPIProtocol::ActionSelectLarva& select_larva() const;
  ::SCRAPIProtocol::ActionSelectLarva* release_select_larva();
  ::SCRAPIProtocol::ActionSelectLarva* mutable_select_larva();
  void set_allocated_select_larva(::SCRAPIProtocol::ActionSelectLarva* select_larva);

  // optional .SCRAPIProtocol.ActionSelectIdleWorker select_idle_worker = 5;
  bool has_select_idle_worker() const;
  void clear_select_idle_worker();
  static const int kSelectIdleWorkerFieldNumber = 5;
  private:
  const ::SCRAPIProtocol::ActionSelectIdleWorker& _internal_select_idle_worker() const;
  public:
  const ::SCRAPIProtocol::ActionSelectIdleWorker& select_idle_worker() const;
  ::SCRAPIProtocol::ActionSelectIdleWorker* release_select_idle_worker();
  ::SCRAPIProtocol::ActionSelectIdleWorker* mutable_select_idle_worker();
  void set_allocated_select_idle_worker(::SCRAPIProtocol::ActionSelectIdleWorker* select_idle_worker);

  // optional .SCRAPIProtocol.ActionMultiPanel multi_panel = 6;
  bool has_multi_panel() const;
  void clear_multi_panel();
  static const int kMultiPanelFieldNumber = 6;
  private:
  const ::SCRAPIProtocol::ActionMultiPanel& _internal_multi_panel() const;
  public:
  const ::SCRAPIProtocol::ActionMultiPanel& multi_panel() const;
  ::SCRAPIProtocol::ActionMultiPanel* release_multi_panel();
  ::SCRAPIProtocol::ActionMultiPanel* mutable_multi_panel();
  void set_allocated_multi_panel(::SCRAPIProtocol::ActionMultiPanel* multi_panel);

  // optional .SCRAPIProtocol.ActionCargoPanelUnload cargo_panel = 7;
  bool has_cargo_panel() const;
  void clear_cargo_panel();
  static const int kCargoPanelFieldNumber = 7;
  private:
  const ::SCRAPIProtocol::ActionCargoPanelUnload& _internal_cargo_panel() const;
  public:
  const ::SCRAPIProtocol::ActionCargoPanelUnload& cargo_panel() const;
  ::SCRAPIProtocol::ActionCargoPanelUnload* release_cargo_panel();
  ::SCRAPIProtocol::ActionCargoPanelUnload* mutable_cargo_panel();
  void set_allocated_cargo_panel(::SCRAPIProtocol::ActionCargoPanelUnload* cargo_panel);

  // optional .SCRAPIProtocol.ActionProductionPanelRemoveFromQueue production_panel = 8;
  bool has_production_panel() const;
  void clear_production_panel();
  static const int kProductionPanelFieldNumber = 8;
  private:
  const ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue& _internal_production_panel() const;
  public:
  const ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue& production_panel() const;
  ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue* release_production_panel();
  ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue* mutable_production_panel();
  void set_allocated_production_panel(::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue* production_panel);

  // optional .SCRAPIProtocol.ActionToggleAutocast toggle_autocast = 9;
  bool has_toggle_autocast() const;
  void clear_toggle_autocast();
  static const int kToggleAutocastFieldNumber = 9;
  private:
  const ::SCRAPIProtocol::ActionToggleAutocast& _internal_toggle_autocast() const;
  public:
  const ::SCRAPIProtocol::ActionToggleAutocast& toggle_autocast() const;
  ::SCRAPIProtocol::ActionToggleAutocast* release_toggle_autocast();
  ::SCRAPIProtocol::ActionToggleAutocast* mutable_toggle_autocast();
  void set_allocated_toggle_autocast(::SCRAPIProtocol::ActionToggleAutocast* toggle_autocast);

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionUI)
 private:
  void set_has_control_group();
  void set_has_select_army();
  void set_has_select_warp_gates();
  void set_has_select_larva();
  void set_has_select_idle_worker();
  void set_has_multi_panel();
  void set_has_cargo_panel();
  void set_has_production_panel();
  void set_has_toggle_autocast();

  inline bool has_action() const;
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ActionUnion {
    ActionUnion() {}
    ::SCRAPIProtocol::ActionControlGroup* control_group_;
    ::SCRAPIProtocol::ActionSelectArmy* select_army_;
    ::SCRAPIProtocol::ActionSelectWarpGates* select_warp_gates_;
    ::SCRAPIProtocol::ActionSelectLarva* select_larva_;
    ::SCRAPIProtocol::ActionSelectIdleWorker* select_idle_worker_;
    ::SCRAPIProtocol::ActionMultiPanel* multi_panel_;
    ::SCRAPIProtocol::ActionCargoPanelUnload* cargo_panel_;
    ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue* production_panel_;
    ::SCRAPIProtocol::ActionToggleAutocast* toggle_autocast_;
  } action_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionControlGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionControlGroup) */ {
 public:
  ActionControlGroup();
  virtual ~ActionControlGroup();

  ActionControlGroup(const ActionControlGroup& from);

  inline ActionControlGroup& operator=(const ActionControlGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionControlGroup(ActionControlGroup&& from) noexcept
    : ActionControlGroup() {
    *this = ::std::move(from);
  }

  inline ActionControlGroup& operator=(ActionControlGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionControlGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionControlGroup* internal_default_instance() {
    return reinterpret_cast<const ActionControlGroup*>(
               &_ActionControlGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ActionControlGroup* other);
  friend void swap(ActionControlGroup& a, ActionControlGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionControlGroup* New() const final {
    return CreateMaybeMessage<ActionControlGroup>(NULL);
  }

  ActionControlGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionControlGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionControlGroup& from);
  void MergeFrom(const ActionControlGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionControlGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionControlGroup_ControlGroupAction ControlGroupAction;
  static const ControlGroupAction Recall =
    ActionControlGroup_ControlGroupAction_Recall;
  static const ControlGroupAction Set =
    ActionControlGroup_ControlGroupAction_Set;
  static const ControlGroupAction Append =
    ActionControlGroup_ControlGroupAction_Append;
  static const ControlGroupAction SetAndSteal =
    ActionControlGroup_ControlGroupAction_SetAndSteal;
  static const ControlGroupAction AppendAndSteal =
    ActionControlGroup_ControlGroupAction_AppendAndSteal;
  static inline bool ControlGroupAction_IsValid(int value) {
    return ActionControlGroup_ControlGroupAction_IsValid(value);
  }
  static const ControlGroupAction ControlGroupAction_MIN =
    ActionControlGroup_ControlGroupAction_ControlGroupAction_MIN;
  static const ControlGroupAction ControlGroupAction_MAX =
    ActionControlGroup_ControlGroupAction_ControlGroupAction_MAX;
  static const int ControlGroupAction_ARRAYSIZE =
    ActionControlGroup_ControlGroupAction_ControlGroupAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ControlGroupAction_descriptor() {
    return ActionControlGroup_ControlGroupAction_descriptor();
  }
  static inline const ::std::string& ControlGroupAction_Name(ControlGroupAction value) {
    return ActionControlGroup_ControlGroupAction_Name(value);
  }
  static inline bool ControlGroupAction_Parse(const ::std::string& name,
      ControlGroupAction* value) {
    return ActionControlGroup_ControlGroupAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 control_group_index = 2;
  bool has_control_group_index() const;
  void clear_control_group_index();
  static const int kControlGroupIndexFieldNumber = 2;
  ::google::protobuf::uint32 control_group_index() const;
  void set_control_group_index(::google::protobuf::uint32 value);

  // optional .SCRAPIProtocol.ActionControlGroup.ControlGroupAction action = 1;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::SCRAPIProtocol::ActionControlGroup_ControlGroupAction action() const;
  void set_action(::SCRAPIProtocol::ActionControlGroup_ControlGroupAction value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionControlGroup)
 private:
  void set_has_action();
  void clear_has_action();
  void set_has_control_group_index();
  void clear_has_control_group_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 control_group_index_;
  int action_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionSelectArmy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionSelectArmy) */ {
 public:
  ActionSelectArmy();
  virtual ~ActionSelectArmy();

  ActionSelectArmy(const ActionSelectArmy& from);

  inline ActionSelectArmy& operator=(const ActionSelectArmy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionSelectArmy(ActionSelectArmy&& from) noexcept
    : ActionSelectArmy() {
    *this = ::std::move(from);
  }

  inline ActionSelectArmy& operator=(ActionSelectArmy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSelectArmy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSelectArmy* internal_default_instance() {
    return reinterpret_cast<const ActionSelectArmy*>(
               &_ActionSelectArmy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ActionSelectArmy* other);
  friend void swap(ActionSelectArmy& a, ActionSelectArmy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionSelectArmy* New() const final {
    return CreateMaybeMessage<ActionSelectArmy>(NULL);
  }

  ActionSelectArmy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionSelectArmy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionSelectArmy& from);
  void MergeFrom(const ActionSelectArmy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSelectArmy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool selection_add = 1;
  bool has_selection_add() const;
  void clear_selection_add();
  static const int kSelectionAddFieldNumber = 1;
  bool selection_add() const;
  void set_selection_add(bool value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionSelectArmy)
 private:
  void set_has_selection_add();
  void clear_has_selection_add();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool selection_add_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionSelectWarpGates : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionSelectWarpGates) */ {
 public:
  ActionSelectWarpGates();
  virtual ~ActionSelectWarpGates();

  ActionSelectWarpGates(const ActionSelectWarpGates& from);

  inline ActionSelectWarpGates& operator=(const ActionSelectWarpGates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionSelectWarpGates(ActionSelectWarpGates&& from) noexcept
    : ActionSelectWarpGates() {
    *this = ::std::move(from);
  }

  inline ActionSelectWarpGates& operator=(ActionSelectWarpGates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSelectWarpGates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSelectWarpGates* internal_default_instance() {
    return reinterpret_cast<const ActionSelectWarpGates*>(
               &_ActionSelectWarpGates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ActionSelectWarpGates* other);
  friend void swap(ActionSelectWarpGates& a, ActionSelectWarpGates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionSelectWarpGates* New() const final {
    return CreateMaybeMessage<ActionSelectWarpGates>(NULL);
  }

  ActionSelectWarpGates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionSelectWarpGates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionSelectWarpGates& from);
  void MergeFrom(const ActionSelectWarpGates& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSelectWarpGates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool selection_add = 1;
  bool has_selection_add() const;
  void clear_selection_add();
  static const int kSelectionAddFieldNumber = 1;
  bool selection_add() const;
  void set_selection_add(bool value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionSelectWarpGates)
 private:
  void set_has_selection_add();
  void clear_has_selection_add();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool selection_add_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionSelectLarva : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionSelectLarva) */ {
 public:
  ActionSelectLarva();
  virtual ~ActionSelectLarva();

  ActionSelectLarva(const ActionSelectLarva& from);

  inline ActionSelectLarva& operator=(const ActionSelectLarva& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionSelectLarva(ActionSelectLarva&& from) noexcept
    : ActionSelectLarva() {
    *this = ::std::move(from);
  }

  inline ActionSelectLarva& operator=(ActionSelectLarva&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSelectLarva& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSelectLarva* internal_default_instance() {
    return reinterpret_cast<const ActionSelectLarva*>(
               &_ActionSelectLarva_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ActionSelectLarva* other);
  friend void swap(ActionSelectLarva& a, ActionSelectLarva& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionSelectLarva* New() const final {
    return CreateMaybeMessage<ActionSelectLarva>(NULL);
  }

  ActionSelectLarva* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionSelectLarva>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionSelectLarva& from);
  void MergeFrom(const ActionSelectLarva& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSelectLarva* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionSelectLarva)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionSelectIdleWorker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionSelectIdleWorker) */ {
 public:
  ActionSelectIdleWorker();
  virtual ~ActionSelectIdleWorker();

  ActionSelectIdleWorker(const ActionSelectIdleWorker& from);

  inline ActionSelectIdleWorker& operator=(const ActionSelectIdleWorker& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionSelectIdleWorker(ActionSelectIdleWorker&& from) noexcept
    : ActionSelectIdleWorker() {
    *this = ::std::move(from);
  }

  inline ActionSelectIdleWorker& operator=(ActionSelectIdleWorker&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSelectIdleWorker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSelectIdleWorker* internal_default_instance() {
    return reinterpret_cast<const ActionSelectIdleWorker*>(
               &_ActionSelectIdleWorker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ActionSelectIdleWorker* other);
  friend void swap(ActionSelectIdleWorker& a, ActionSelectIdleWorker& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionSelectIdleWorker* New() const final {
    return CreateMaybeMessage<ActionSelectIdleWorker>(NULL);
  }

  ActionSelectIdleWorker* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionSelectIdleWorker>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionSelectIdleWorker& from);
  void MergeFrom(const ActionSelectIdleWorker& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSelectIdleWorker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionSelectIdleWorker_Type Type;
  static const Type Set =
    ActionSelectIdleWorker_Type_Set;
  static const Type Add =
    ActionSelectIdleWorker_Type_Add;
  static const Type All =
    ActionSelectIdleWorker_Type_All;
  static const Type AddAll =
    ActionSelectIdleWorker_Type_AddAll;
  static inline bool Type_IsValid(int value) {
    return ActionSelectIdleWorker_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ActionSelectIdleWorker_Type_Type_MIN;
  static const Type Type_MAX =
    ActionSelectIdleWorker_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ActionSelectIdleWorker_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ActionSelectIdleWorker_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ActionSelectIdleWorker_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ActionSelectIdleWorker_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SCRAPIProtocol.ActionSelectIdleWorker.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::SCRAPIProtocol::ActionSelectIdleWorker_Type type() const;
  void set_type(::SCRAPIProtocol::ActionSelectIdleWorker_Type value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionSelectIdleWorker)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int type_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionMultiPanel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionMultiPanel) */ {
 public:
  ActionMultiPanel();
  virtual ~ActionMultiPanel();

  ActionMultiPanel(const ActionMultiPanel& from);

  inline ActionMultiPanel& operator=(const ActionMultiPanel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionMultiPanel(ActionMultiPanel&& from) noexcept
    : ActionMultiPanel() {
    *this = ::std::move(from);
  }

  inline ActionMultiPanel& operator=(ActionMultiPanel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionMultiPanel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionMultiPanel* internal_default_instance() {
    return reinterpret_cast<const ActionMultiPanel*>(
               &_ActionMultiPanel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ActionMultiPanel* other);
  friend void swap(ActionMultiPanel& a, ActionMultiPanel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionMultiPanel* New() const final {
    return CreateMaybeMessage<ActionMultiPanel>(NULL);
  }

  ActionMultiPanel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionMultiPanel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionMultiPanel& from);
  void MergeFrom(const ActionMultiPanel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionMultiPanel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionMultiPanel_Type Type;
  static const Type SingleSelect =
    ActionMultiPanel_Type_SingleSelect;
  static const Type DeselectUnit =
    ActionMultiPanel_Type_DeselectUnit;
  static const Type SelectAllOfType =
    ActionMultiPanel_Type_SelectAllOfType;
  static const Type DeselectAllOfType =
    ActionMultiPanel_Type_DeselectAllOfType;
  static inline bool Type_IsValid(int value) {
    return ActionMultiPanel_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ActionMultiPanel_Type_Type_MIN;
  static const Type Type_MAX =
    ActionMultiPanel_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ActionMultiPanel_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ActionMultiPanel_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ActionMultiPanel_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ActionMultiPanel_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 unit_index = 2;
  bool has_unit_index() const;
  void clear_unit_index();
  static const int kUnitIndexFieldNumber = 2;
  ::google::protobuf::int32 unit_index() const;
  void set_unit_index(::google::protobuf::int32 value);

  // optional .SCRAPIProtocol.ActionMultiPanel.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::SCRAPIProtocol::ActionMultiPanel_Type type() const;
  void set_type(::SCRAPIProtocol::ActionMultiPanel_Type value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionMultiPanel)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_unit_index();
  void clear_has_unit_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 unit_index_;
  int type_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionCargoPanelUnload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionCargoPanelUnload) */ {
 public:
  ActionCargoPanelUnload();
  virtual ~ActionCargoPanelUnload();

  ActionCargoPanelUnload(const ActionCargoPanelUnload& from);

  inline ActionCargoPanelUnload& operator=(const ActionCargoPanelUnload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionCargoPanelUnload(ActionCargoPanelUnload&& from) noexcept
    : ActionCargoPanelUnload() {
    *this = ::std::move(from);
  }

  inline ActionCargoPanelUnload& operator=(ActionCargoPanelUnload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionCargoPanelUnload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionCargoPanelUnload* internal_default_instance() {
    return reinterpret_cast<const ActionCargoPanelUnload*>(
               &_ActionCargoPanelUnload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ActionCargoPanelUnload* other);
  friend void swap(ActionCargoPanelUnload& a, ActionCargoPanelUnload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionCargoPanelUnload* New() const final {
    return CreateMaybeMessage<ActionCargoPanelUnload>(NULL);
  }

  ActionCargoPanelUnload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionCargoPanelUnload>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionCargoPanelUnload& from);
  void MergeFrom(const ActionCargoPanelUnload& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionCargoPanelUnload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 unit_index = 1;
  bool has_unit_index() const;
  void clear_unit_index();
  static const int kUnitIndexFieldNumber = 1;
  ::google::protobuf::int32 unit_index() const;
  void set_unit_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionCargoPanelUnload)
 private:
  void set_has_unit_index();
  void clear_has_unit_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 unit_index_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionProductionPanelRemoveFromQueue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionProductionPanelRemoveFromQueue) */ {
 public:
  ActionProductionPanelRemoveFromQueue();
  virtual ~ActionProductionPanelRemoveFromQueue();

  ActionProductionPanelRemoveFromQueue(const ActionProductionPanelRemoveFromQueue& from);

  inline ActionProductionPanelRemoveFromQueue& operator=(const ActionProductionPanelRemoveFromQueue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionProductionPanelRemoveFromQueue(ActionProductionPanelRemoveFromQueue&& from) noexcept
    : ActionProductionPanelRemoveFromQueue() {
    *this = ::std::move(from);
  }

  inline ActionProductionPanelRemoveFromQueue& operator=(ActionProductionPanelRemoveFromQueue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionProductionPanelRemoveFromQueue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionProductionPanelRemoveFromQueue* internal_default_instance() {
    return reinterpret_cast<const ActionProductionPanelRemoveFromQueue*>(
               &_ActionProductionPanelRemoveFromQueue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ActionProductionPanelRemoveFromQueue* other);
  friend void swap(ActionProductionPanelRemoveFromQueue& a, ActionProductionPanelRemoveFromQueue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionProductionPanelRemoveFromQueue* New() const final {
    return CreateMaybeMessage<ActionProductionPanelRemoveFromQueue>(NULL);
  }

  ActionProductionPanelRemoveFromQueue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionProductionPanelRemoveFromQueue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionProductionPanelRemoveFromQueue& from);
  void MergeFrom(const ActionProductionPanelRemoveFromQueue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionProductionPanelRemoveFromQueue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 unit_index = 1;
  bool has_unit_index() const;
  void clear_unit_index();
  static const int kUnitIndexFieldNumber = 1;
  ::google::protobuf::int32 unit_index() const;
  void set_unit_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionProductionPanelRemoveFromQueue)
 private:
  void set_has_unit_index();
  void clear_has_unit_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 unit_index_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionToggleAutocast : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCRAPIProtocol.ActionToggleAutocast) */ {
 public:
  ActionToggleAutocast();
  virtual ~ActionToggleAutocast();

  ActionToggleAutocast(const ActionToggleAutocast& from);

  inline ActionToggleAutocast& operator=(const ActionToggleAutocast& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionToggleAutocast(ActionToggleAutocast&& from) noexcept
    : ActionToggleAutocast() {
    *this = ::std::move(from);
  }

  inline ActionToggleAutocast& operator=(ActionToggleAutocast&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionToggleAutocast& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionToggleAutocast* internal_default_instance() {
    return reinterpret_cast<const ActionToggleAutocast*>(
               &_ActionToggleAutocast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ActionToggleAutocast* other);
  friend void swap(ActionToggleAutocast& a, ActionToggleAutocast& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionToggleAutocast* New() const final {
    return CreateMaybeMessage<ActionToggleAutocast>(NULL);
  }

  ActionToggleAutocast* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionToggleAutocast>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionToggleAutocast& from);
  void MergeFrom(const ActionToggleAutocast& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionToggleAutocast* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  ::google::protobuf::int32 ability_id() const;
  void set_ability_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SCRAPIProtocol.ActionToggleAutocast)
 private:
  void set_has_ability_id();
  void clear_has_ability_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 ability_id_;
  friend struct ::protobuf_ui_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObservationUI

// repeated .SCRAPIProtocol.ControlGroup groups = 1;
inline int ObservationUI::groups_size() const {
  return groups_.size();
}
inline void ObservationUI::clear_groups() {
  groups_.Clear();
}
inline ::SCRAPIProtocol::ControlGroup* ObservationUI::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationUI.groups)
  return groups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ControlGroup >*
ObservationUI::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ObservationUI.groups)
  return &groups_;
}
inline const ::SCRAPIProtocol::ControlGroup& ObservationUI::groups(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationUI.groups)
  return groups_.Get(index);
}
inline ::SCRAPIProtocol::ControlGroup* ObservationUI::add_groups() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ObservationUI.groups)
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::ControlGroup >&
ObservationUI::groups() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ObservationUI.groups)
  return groups_;
}

// optional .SCRAPIProtocol.SinglePanel single = 2;
inline bool ObservationUI::has_single() const {
  return panel_case() == kSingle;
}
inline void ObservationUI::set_has_single() {
  _oneof_case_[0] = kSingle;
}
inline void ObservationUI::clear_single() {
  if (has_single()) {
    delete panel_.single_;
    clear_has_panel();
  }
}
inline const ::SCRAPIProtocol::SinglePanel& ObservationUI::_internal_single() const {
  return *panel_.single_;
}
inline ::SCRAPIProtocol::SinglePanel* ObservationUI::release_single() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationUI.single)
  if (has_single()) {
    clear_has_panel();
      ::SCRAPIProtocol::SinglePanel* temp = panel_.single_;
    panel_.single_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::SinglePanel& ObservationUI::single() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationUI.single)
  return has_single()
      ? *panel_.single_
      : *reinterpret_cast< ::SCRAPIProtocol::SinglePanel*>(&::SCRAPIProtocol::_SinglePanel_default_instance_);
}
inline ::SCRAPIProtocol::SinglePanel* ObservationUI::mutable_single() {
  if (!has_single()) {
    clear_panel();
    set_has_single();
    panel_.single_ = CreateMaybeMessage< ::SCRAPIProtocol::SinglePanel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationUI.single)
  return panel_.single_;
}

// optional .SCRAPIProtocol.MultiPanel multi = 3;
inline bool ObservationUI::has_multi() const {
  return panel_case() == kMulti;
}
inline void ObservationUI::set_has_multi() {
  _oneof_case_[0] = kMulti;
}
inline void ObservationUI::clear_multi() {
  if (has_multi()) {
    delete panel_.multi_;
    clear_has_panel();
  }
}
inline const ::SCRAPIProtocol::MultiPanel& ObservationUI::_internal_multi() const {
  return *panel_.multi_;
}
inline ::SCRAPIProtocol::MultiPanel* ObservationUI::release_multi() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationUI.multi)
  if (has_multi()) {
    clear_has_panel();
      ::SCRAPIProtocol::MultiPanel* temp = panel_.multi_;
    panel_.multi_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::MultiPanel& ObservationUI::multi() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationUI.multi)
  return has_multi()
      ? *panel_.multi_
      : *reinterpret_cast< ::SCRAPIProtocol::MultiPanel*>(&::SCRAPIProtocol::_MultiPanel_default_instance_);
}
inline ::SCRAPIProtocol::MultiPanel* ObservationUI::mutable_multi() {
  if (!has_multi()) {
    clear_panel();
    set_has_multi();
    panel_.multi_ = CreateMaybeMessage< ::SCRAPIProtocol::MultiPanel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationUI.multi)
  return panel_.multi_;
}

// optional .SCRAPIProtocol.CargoPanel cargo = 4;
inline bool ObservationUI::has_cargo() const {
  return panel_case() == kCargo;
}
inline void ObservationUI::set_has_cargo() {
  _oneof_case_[0] = kCargo;
}
inline void ObservationUI::clear_cargo() {
  if (has_cargo()) {
    delete panel_.cargo_;
    clear_has_panel();
  }
}
inline const ::SCRAPIProtocol::CargoPanel& ObservationUI::_internal_cargo() const {
  return *panel_.cargo_;
}
inline ::SCRAPIProtocol::CargoPanel* ObservationUI::release_cargo() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationUI.cargo)
  if (has_cargo()) {
    clear_has_panel();
      ::SCRAPIProtocol::CargoPanel* temp = panel_.cargo_;
    panel_.cargo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::CargoPanel& ObservationUI::cargo() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationUI.cargo)
  return has_cargo()
      ? *panel_.cargo_
      : *reinterpret_cast< ::SCRAPIProtocol::CargoPanel*>(&::SCRAPIProtocol::_CargoPanel_default_instance_);
}
inline ::SCRAPIProtocol::CargoPanel* ObservationUI::mutable_cargo() {
  if (!has_cargo()) {
    clear_panel();
    set_has_cargo();
    panel_.cargo_ = CreateMaybeMessage< ::SCRAPIProtocol::CargoPanel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationUI.cargo)
  return panel_.cargo_;
}

// optional .SCRAPIProtocol.ProductionPanel production = 5;
inline bool ObservationUI::has_production() const {
  return panel_case() == kProduction;
}
inline void ObservationUI::set_has_production() {
  _oneof_case_[0] = kProduction;
}
inline void ObservationUI::clear_production() {
  if (has_production()) {
    delete panel_.production_;
    clear_has_panel();
  }
}
inline const ::SCRAPIProtocol::ProductionPanel& ObservationUI::_internal_production() const {
  return *panel_.production_;
}
inline ::SCRAPIProtocol::ProductionPanel* ObservationUI::release_production() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ObservationUI.production)
  if (has_production()) {
    clear_has_panel();
      ::SCRAPIProtocol::ProductionPanel* temp = panel_.production_;
    panel_.production_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ProductionPanel& ObservationUI::production() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ObservationUI.production)
  return has_production()
      ? *panel_.production_
      : *reinterpret_cast< ::SCRAPIProtocol::ProductionPanel*>(&::SCRAPIProtocol::_ProductionPanel_default_instance_);
}
inline ::SCRAPIProtocol::ProductionPanel* ObservationUI::mutable_production() {
  if (!has_production()) {
    clear_panel();
    set_has_production();
    panel_.production_ = CreateMaybeMessage< ::SCRAPIProtocol::ProductionPanel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ObservationUI.production)
  return panel_.production_;
}

inline bool ObservationUI::has_panel() const {
  return panel_case() != PANEL_NOT_SET;
}
inline void ObservationUI::clear_has_panel() {
  _oneof_case_[0] = PANEL_NOT_SET;
}
inline ObservationUI::PanelCase ObservationUI::panel_case() const {
  return ObservationUI::PanelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControlGroup

// optional uint32 control_group_index = 1;
inline bool ControlGroup::has_control_group_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlGroup::set_has_control_group_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlGroup::clear_has_control_group_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlGroup::clear_control_group_index() {
  control_group_index_ = 0u;
  clear_has_control_group_index();
}
inline ::google::protobuf::uint32 ControlGroup::control_group_index() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ControlGroup.control_group_index)
  return control_group_index_;
}
inline void ControlGroup::set_control_group_index(::google::protobuf::uint32 value) {
  set_has_control_group_index();
  control_group_index_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ControlGroup.control_group_index)
}

// optional uint32 leader_unit_type = 2;
inline bool ControlGroup::has_leader_unit_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlGroup::set_has_leader_unit_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlGroup::clear_has_leader_unit_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlGroup::clear_leader_unit_type() {
  leader_unit_type_ = 0u;
  clear_has_leader_unit_type();
}
inline ::google::protobuf::uint32 ControlGroup::leader_unit_type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ControlGroup.leader_unit_type)
  return leader_unit_type_;
}
inline void ControlGroup::set_leader_unit_type(::google::protobuf::uint32 value) {
  set_has_leader_unit_type();
  leader_unit_type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ControlGroup.leader_unit_type)
}

// optional uint32 count = 3;
inline bool ControlGroup::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControlGroup::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControlGroup::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControlGroup::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 ControlGroup::count() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ControlGroup.count)
  return count_;
}
inline void ControlGroup::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ControlGroup.count)
}

// -------------------------------------------------------------------

// UnitInfo

// optional uint32 unit_type = 1;
inline bool UnitInfo::has_unit_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnitInfo::set_has_unit_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnitInfo::clear_has_unit_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnitInfo::clear_unit_type() {
  unit_type_ = 0u;
  clear_has_unit_type();
}
inline ::google::protobuf::uint32 UnitInfo::unit_type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitInfo.unit_type)
  return unit_type_;
}
inline void UnitInfo::set_unit_type(::google::protobuf::uint32 value) {
  set_has_unit_type();
  unit_type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitInfo.unit_type)
}

// optional uint32 player_relative = 2;
inline bool UnitInfo::has_player_relative() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnitInfo::set_has_player_relative() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnitInfo::clear_has_player_relative() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnitInfo::clear_player_relative() {
  player_relative_ = 0u;
  clear_has_player_relative();
}
inline ::google::protobuf::uint32 UnitInfo::player_relative() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitInfo.player_relative)
  return player_relative_;
}
inline void UnitInfo::set_player_relative(::google::protobuf::uint32 value) {
  set_has_player_relative();
  player_relative_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitInfo.player_relative)
}

// optional int32 health = 3;
inline bool UnitInfo::has_health() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnitInfo::set_has_health() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnitInfo::clear_has_health() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnitInfo::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline ::google::protobuf::int32 UnitInfo::health() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitInfo.health)
  return health_;
}
inline void UnitInfo::set_health(::google::protobuf::int32 value) {
  set_has_health();
  health_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitInfo.health)
}

// optional int32 shields = 4;
inline bool UnitInfo::has_shields() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UnitInfo::set_has_shields() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UnitInfo::clear_has_shields() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UnitInfo::clear_shields() {
  shields_ = 0;
  clear_has_shields();
}
inline ::google::protobuf::int32 UnitInfo::shields() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitInfo.shields)
  return shields_;
}
inline void UnitInfo::set_shields(::google::protobuf::int32 value) {
  set_has_shields();
  shields_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitInfo.shields)
}

// optional int32 energy = 5;
inline bool UnitInfo::has_energy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UnitInfo::set_has_energy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UnitInfo::clear_has_energy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UnitInfo::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline ::google::protobuf::int32 UnitInfo::energy() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitInfo.energy)
  return energy_;
}
inline void UnitInfo::set_energy(::google::protobuf::int32 value) {
  set_has_energy();
  energy_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitInfo.energy)
}

// optional int32 transport_slots_taken = 6;
inline bool UnitInfo::has_transport_slots_taken() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UnitInfo::set_has_transport_slots_taken() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UnitInfo::clear_has_transport_slots_taken() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UnitInfo::clear_transport_slots_taken() {
  transport_slots_taken_ = 0;
  clear_has_transport_slots_taken();
}
inline ::google::protobuf::int32 UnitInfo::transport_slots_taken() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitInfo.transport_slots_taken)
  return transport_slots_taken_;
}
inline void UnitInfo::set_transport_slots_taken(::google::protobuf::int32 value) {
  set_has_transport_slots_taken();
  transport_slots_taken_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitInfo.transport_slots_taken)
}

// optional float build_progress = 7;
inline bool UnitInfo::has_build_progress() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UnitInfo::set_has_build_progress() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UnitInfo::clear_has_build_progress() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UnitInfo::clear_build_progress() {
  build_progress_ = 0;
  clear_has_build_progress();
}
inline float UnitInfo::build_progress() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitInfo.build_progress)
  return build_progress_;
}
inline void UnitInfo::set_build_progress(float value) {
  set_has_build_progress();
  build_progress_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.UnitInfo.build_progress)
}

// optional .SCRAPIProtocol.UnitInfo add_on = 8;
inline bool UnitInfo::has_add_on() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitInfo::set_has_add_on() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitInfo::clear_has_add_on() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitInfo::clear_add_on() {
  if (add_on_ != NULL) add_on_->Clear();
  clear_has_add_on();
}
inline const ::SCRAPIProtocol::UnitInfo& UnitInfo::_internal_add_on() const {
  return *add_on_;
}
inline const ::SCRAPIProtocol::UnitInfo& UnitInfo::add_on() const {
  const ::SCRAPIProtocol::UnitInfo* p = add_on_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.UnitInfo.add_on)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::UnitInfo*>(
      &::SCRAPIProtocol::_UnitInfo_default_instance_);
}
inline ::SCRAPIProtocol::UnitInfo* UnitInfo::release_add_on() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.UnitInfo.add_on)
  clear_has_add_on();
  ::SCRAPIProtocol::UnitInfo* temp = add_on_;
  add_on_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::UnitInfo* UnitInfo::mutable_add_on() {
  set_has_add_on();
  if (add_on_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::UnitInfo>(GetArenaNoVirtual());
    add_on_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.UnitInfo.add_on)
  return add_on_;
}
inline void UnitInfo::set_allocated_add_on(::SCRAPIProtocol::UnitInfo* add_on) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete add_on_;
  }
  if (add_on) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      add_on = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, add_on, submessage_arena);
    }
    set_has_add_on();
  } else {
    clear_has_add_on();
  }
  add_on_ = add_on;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.UnitInfo.add_on)
}

// -------------------------------------------------------------------

// SinglePanel

// optional .SCRAPIProtocol.UnitInfo unit = 1;
inline bool SinglePanel::has_unit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SinglePanel::set_has_unit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SinglePanel::clear_has_unit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SinglePanel::clear_unit() {
  if (unit_ != NULL) unit_->Clear();
  clear_has_unit();
}
inline const ::SCRAPIProtocol::UnitInfo& SinglePanel::_internal_unit() const {
  return *unit_;
}
inline const ::SCRAPIProtocol::UnitInfo& SinglePanel::unit() const {
  const ::SCRAPIProtocol::UnitInfo* p = unit_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.SinglePanel.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::UnitInfo*>(
      &::SCRAPIProtocol::_UnitInfo_default_instance_);
}
inline ::SCRAPIProtocol::UnitInfo* SinglePanel::release_unit() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.SinglePanel.unit)
  clear_has_unit();
  ::SCRAPIProtocol::UnitInfo* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::UnitInfo* SinglePanel::mutable_unit() {
  set_has_unit();
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::UnitInfo>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.SinglePanel.unit)
  return unit_;
}
inline void SinglePanel::set_allocated_unit(::SCRAPIProtocol::UnitInfo* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unit_;
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    set_has_unit();
  } else {
    clear_has_unit();
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.SinglePanel.unit)
}

// -------------------------------------------------------------------

// MultiPanel

// repeated .SCRAPIProtocol.UnitInfo units = 1;
inline int MultiPanel::units_size() const {
  return units_.size();
}
inline void MultiPanel::clear_units() {
  units_.Clear();
}
inline ::SCRAPIProtocol::UnitInfo* MultiPanel::mutable_units(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.MultiPanel.units)
  return units_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >*
MultiPanel::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.MultiPanel.units)
  return &units_;
}
inline const ::SCRAPIProtocol::UnitInfo& MultiPanel::units(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.MultiPanel.units)
  return units_.Get(index);
}
inline ::SCRAPIProtocol::UnitInfo* MultiPanel::add_units() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.MultiPanel.units)
  return units_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >&
MultiPanel::units() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.MultiPanel.units)
  return units_;
}

// -------------------------------------------------------------------

// CargoPanel

// optional .SCRAPIProtocol.UnitInfo unit = 1;
inline bool CargoPanel::has_unit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CargoPanel::set_has_unit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CargoPanel::clear_has_unit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CargoPanel::clear_unit() {
  if (unit_ != NULL) unit_->Clear();
  clear_has_unit();
}
inline const ::SCRAPIProtocol::UnitInfo& CargoPanel::_internal_unit() const {
  return *unit_;
}
inline const ::SCRAPIProtocol::UnitInfo& CargoPanel::unit() const {
  const ::SCRAPIProtocol::UnitInfo* p = unit_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.CargoPanel.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::UnitInfo*>(
      &::SCRAPIProtocol::_UnitInfo_default_instance_);
}
inline ::SCRAPIProtocol::UnitInfo* CargoPanel::release_unit() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.CargoPanel.unit)
  clear_has_unit();
  ::SCRAPIProtocol::UnitInfo* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::UnitInfo* CargoPanel::mutable_unit() {
  set_has_unit();
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::UnitInfo>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.CargoPanel.unit)
  return unit_;
}
inline void CargoPanel::set_allocated_unit(::SCRAPIProtocol::UnitInfo* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unit_;
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    set_has_unit();
  } else {
    clear_has_unit();
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.CargoPanel.unit)
}

// repeated .SCRAPIProtocol.UnitInfo passengers = 2;
inline int CargoPanel::passengers_size() const {
  return passengers_.size();
}
inline void CargoPanel::clear_passengers() {
  passengers_.Clear();
}
inline ::SCRAPIProtocol::UnitInfo* CargoPanel::mutable_passengers(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.CargoPanel.passengers)
  return passengers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >*
CargoPanel::mutable_passengers() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.CargoPanel.passengers)
  return &passengers_;
}
inline const ::SCRAPIProtocol::UnitInfo& CargoPanel::passengers(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.CargoPanel.passengers)
  return passengers_.Get(index);
}
inline ::SCRAPIProtocol::UnitInfo* CargoPanel::add_passengers() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.CargoPanel.passengers)
  return passengers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >&
CargoPanel::passengers() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.CargoPanel.passengers)
  return passengers_;
}

// optional int32 slots_available = 3;
inline bool CargoPanel::has_slots_available() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CargoPanel::set_has_slots_available() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CargoPanel::clear_has_slots_available() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CargoPanel::clear_slots_available() {
  slots_available_ = 0;
  clear_has_slots_available();
}
inline ::google::protobuf::int32 CargoPanel::slots_available() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.CargoPanel.slots_available)
  return slots_available_;
}
inline void CargoPanel::set_slots_available(::google::protobuf::int32 value) {
  set_has_slots_available();
  slots_available_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.CargoPanel.slots_available)
}

// -------------------------------------------------------------------

// ProductionPanel

// optional .SCRAPIProtocol.UnitInfo unit = 1;
inline bool ProductionPanel::has_unit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductionPanel::set_has_unit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductionPanel::clear_has_unit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductionPanel::clear_unit() {
  if (unit_ != NULL) unit_->Clear();
  clear_has_unit();
}
inline const ::SCRAPIProtocol::UnitInfo& ProductionPanel::_internal_unit() const {
  return *unit_;
}
inline const ::SCRAPIProtocol::UnitInfo& ProductionPanel::unit() const {
  const ::SCRAPIProtocol::UnitInfo* p = unit_;
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ProductionPanel.unit)
  return p != NULL ? *p : *reinterpret_cast<const ::SCRAPIProtocol::UnitInfo*>(
      &::SCRAPIProtocol::_UnitInfo_default_instance_);
}
inline ::SCRAPIProtocol::UnitInfo* ProductionPanel::release_unit() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ProductionPanel.unit)
  clear_has_unit();
  ::SCRAPIProtocol::UnitInfo* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline ::SCRAPIProtocol::UnitInfo* ProductionPanel::mutable_unit() {
  set_has_unit();
  if (unit_ == NULL) {
    auto* p = CreateMaybeMessage<::SCRAPIProtocol::UnitInfo>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ProductionPanel.unit)
  return unit_;
}
inline void ProductionPanel::set_allocated_unit(::SCRAPIProtocol::UnitInfo* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unit_;
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    set_has_unit();
  } else {
    clear_has_unit();
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:SCRAPIProtocol.ProductionPanel.unit)
}

// repeated .SCRAPIProtocol.UnitInfo build_queue = 2;
inline int ProductionPanel::build_queue_size() const {
  return build_queue_.size();
}
inline void ProductionPanel::clear_build_queue() {
  build_queue_.Clear();
}
inline ::SCRAPIProtocol::UnitInfo* ProductionPanel::mutable_build_queue(int index) {
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ProductionPanel.build_queue)
  return build_queue_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >*
ProductionPanel::mutable_build_queue() {
  // @@protoc_insertion_point(field_mutable_list:SCRAPIProtocol.ProductionPanel.build_queue)
  return &build_queue_;
}
inline const ::SCRAPIProtocol::UnitInfo& ProductionPanel::build_queue(int index) const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ProductionPanel.build_queue)
  return build_queue_.Get(index);
}
inline ::SCRAPIProtocol::UnitInfo* ProductionPanel::add_build_queue() {
  // @@protoc_insertion_point(field_add:SCRAPIProtocol.ProductionPanel.build_queue)
  return build_queue_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCRAPIProtocol::UnitInfo >&
ProductionPanel::build_queue() const {
  // @@protoc_insertion_point(field_list:SCRAPIProtocol.ProductionPanel.build_queue)
  return build_queue_;
}

// -------------------------------------------------------------------

// ActionUI

// optional .SCRAPIProtocol.ActionControlGroup control_group = 1;
inline bool ActionUI::has_control_group() const {
  return action_case() == kControlGroup;
}
inline void ActionUI::set_has_control_group() {
  _oneof_case_[0] = kControlGroup;
}
inline void ActionUI::clear_control_group() {
  if (has_control_group()) {
    delete action_.control_group_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionControlGroup& ActionUI::_internal_control_group() const {
  return *action_.control_group_;
}
inline ::SCRAPIProtocol::ActionControlGroup* ActionUI::release_control_group() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionUI.control_group)
  if (has_control_group()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionControlGroup* temp = action_.control_group_;
    action_.control_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionControlGroup& ActionUI::control_group() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionUI.control_group)
  return has_control_group()
      ? *action_.control_group_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionControlGroup*>(&::SCRAPIProtocol::_ActionControlGroup_default_instance_);
}
inline ::SCRAPIProtocol::ActionControlGroup* ActionUI::mutable_control_group() {
  if (!has_control_group()) {
    clear_action();
    set_has_control_group();
    action_.control_group_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionControlGroup >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionUI.control_group)
  return action_.control_group_;
}

// optional .SCRAPIProtocol.ActionSelectArmy select_army = 2;
inline bool ActionUI::has_select_army() const {
  return action_case() == kSelectArmy;
}
inline void ActionUI::set_has_select_army() {
  _oneof_case_[0] = kSelectArmy;
}
inline void ActionUI::clear_select_army() {
  if (has_select_army()) {
    delete action_.select_army_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionSelectArmy& ActionUI::_internal_select_army() const {
  return *action_.select_army_;
}
inline ::SCRAPIProtocol::ActionSelectArmy* ActionUI::release_select_army() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionUI.select_army)
  if (has_select_army()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionSelectArmy* temp = action_.select_army_;
    action_.select_army_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionSelectArmy& ActionUI::select_army() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionUI.select_army)
  return has_select_army()
      ? *action_.select_army_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionSelectArmy*>(&::SCRAPIProtocol::_ActionSelectArmy_default_instance_);
}
inline ::SCRAPIProtocol::ActionSelectArmy* ActionUI::mutable_select_army() {
  if (!has_select_army()) {
    clear_action();
    set_has_select_army();
    action_.select_army_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionSelectArmy >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionUI.select_army)
  return action_.select_army_;
}

// optional .SCRAPIProtocol.ActionSelectWarpGates select_warp_gates = 3;
inline bool ActionUI::has_select_warp_gates() const {
  return action_case() == kSelectWarpGates;
}
inline void ActionUI::set_has_select_warp_gates() {
  _oneof_case_[0] = kSelectWarpGates;
}
inline void ActionUI::clear_select_warp_gates() {
  if (has_select_warp_gates()) {
    delete action_.select_warp_gates_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionSelectWarpGates& ActionUI::_internal_select_warp_gates() const {
  return *action_.select_warp_gates_;
}
inline ::SCRAPIProtocol::ActionSelectWarpGates* ActionUI::release_select_warp_gates() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionUI.select_warp_gates)
  if (has_select_warp_gates()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionSelectWarpGates* temp = action_.select_warp_gates_;
    action_.select_warp_gates_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionSelectWarpGates& ActionUI::select_warp_gates() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionUI.select_warp_gates)
  return has_select_warp_gates()
      ? *action_.select_warp_gates_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionSelectWarpGates*>(&::SCRAPIProtocol::_ActionSelectWarpGates_default_instance_);
}
inline ::SCRAPIProtocol::ActionSelectWarpGates* ActionUI::mutable_select_warp_gates() {
  if (!has_select_warp_gates()) {
    clear_action();
    set_has_select_warp_gates();
    action_.select_warp_gates_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionSelectWarpGates >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionUI.select_warp_gates)
  return action_.select_warp_gates_;
}

// optional .SCRAPIProtocol.ActionSelectLarva select_larva = 4;
inline bool ActionUI::has_select_larva() const {
  return action_case() == kSelectLarva;
}
inline void ActionUI::set_has_select_larva() {
  _oneof_case_[0] = kSelectLarva;
}
inline void ActionUI::clear_select_larva() {
  if (has_select_larva()) {
    delete action_.select_larva_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionSelectLarva& ActionUI::_internal_select_larva() const {
  return *action_.select_larva_;
}
inline ::SCRAPIProtocol::ActionSelectLarva* ActionUI::release_select_larva() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionUI.select_larva)
  if (has_select_larva()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionSelectLarva* temp = action_.select_larva_;
    action_.select_larva_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionSelectLarva& ActionUI::select_larva() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionUI.select_larva)
  return has_select_larva()
      ? *action_.select_larva_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionSelectLarva*>(&::SCRAPIProtocol::_ActionSelectLarva_default_instance_);
}
inline ::SCRAPIProtocol::ActionSelectLarva* ActionUI::mutable_select_larva() {
  if (!has_select_larva()) {
    clear_action();
    set_has_select_larva();
    action_.select_larva_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionSelectLarva >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionUI.select_larva)
  return action_.select_larva_;
}

// optional .SCRAPIProtocol.ActionSelectIdleWorker select_idle_worker = 5;
inline bool ActionUI::has_select_idle_worker() const {
  return action_case() == kSelectIdleWorker;
}
inline void ActionUI::set_has_select_idle_worker() {
  _oneof_case_[0] = kSelectIdleWorker;
}
inline void ActionUI::clear_select_idle_worker() {
  if (has_select_idle_worker()) {
    delete action_.select_idle_worker_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionSelectIdleWorker& ActionUI::_internal_select_idle_worker() const {
  return *action_.select_idle_worker_;
}
inline ::SCRAPIProtocol::ActionSelectIdleWorker* ActionUI::release_select_idle_worker() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionUI.select_idle_worker)
  if (has_select_idle_worker()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionSelectIdleWorker* temp = action_.select_idle_worker_;
    action_.select_idle_worker_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionSelectIdleWorker& ActionUI::select_idle_worker() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionUI.select_idle_worker)
  return has_select_idle_worker()
      ? *action_.select_idle_worker_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionSelectIdleWorker*>(&::SCRAPIProtocol::_ActionSelectIdleWorker_default_instance_);
}
inline ::SCRAPIProtocol::ActionSelectIdleWorker* ActionUI::mutable_select_idle_worker() {
  if (!has_select_idle_worker()) {
    clear_action();
    set_has_select_idle_worker();
    action_.select_idle_worker_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionSelectIdleWorker >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionUI.select_idle_worker)
  return action_.select_idle_worker_;
}

// optional .SCRAPIProtocol.ActionMultiPanel multi_panel = 6;
inline bool ActionUI::has_multi_panel() const {
  return action_case() == kMultiPanel;
}
inline void ActionUI::set_has_multi_panel() {
  _oneof_case_[0] = kMultiPanel;
}
inline void ActionUI::clear_multi_panel() {
  if (has_multi_panel()) {
    delete action_.multi_panel_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionMultiPanel& ActionUI::_internal_multi_panel() const {
  return *action_.multi_panel_;
}
inline ::SCRAPIProtocol::ActionMultiPanel* ActionUI::release_multi_panel() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionUI.multi_panel)
  if (has_multi_panel()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionMultiPanel* temp = action_.multi_panel_;
    action_.multi_panel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionMultiPanel& ActionUI::multi_panel() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionUI.multi_panel)
  return has_multi_panel()
      ? *action_.multi_panel_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionMultiPanel*>(&::SCRAPIProtocol::_ActionMultiPanel_default_instance_);
}
inline ::SCRAPIProtocol::ActionMultiPanel* ActionUI::mutable_multi_panel() {
  if (!has_multi_panel()) {
    clear_action();
    set_has_multi_panel();
    action_.multi_panel_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionMultiPanel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionUI.multi_panel)
  return action_.multi_panel_;
}

// optional .SCRAPIProtocol.ActionCargoPanelUnload cargo_panel = 7;
inline bool ActionUI::has_cargo_panel() const {
  return action_case() == kCargoPanel;
}
inline void ActionUI::set_has_cargo_panel() {
  _oneof_case_[0] = kCargoPanel;
}
inline void ActionUI::clear_cargo_panel() {
  if (has_cargo_panel()) {
    delete action_.cargo_panel_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionCargoPanelUnload& ActionUI::_internal_cargo_panel() const {
  return *action_.cargo_panel_;
}
inline ::SCRAPIProtocol::ActionCargoPanelUnload* ActionUI::release_cargo_panel() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionUI.cargo_panel)
  if (has_cargo_panel()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionCargoPanelUnload* temp = action_.cargo_panel_;
    action_.cargo_panel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionCargoPanelUnload& ActionUI::cargo_panel() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionUI.cargo_panel)
  return has_cargo_panel()
      ? *action_.cargo_panel_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionCargoPanelUnload*>(&::SCRAPIProtocol::_ActionCargoPanelUnload_default_instance_);
}
inline ::SCRAPIProtocol::ActionCargoPanelUnload* ActionUI::mutable_cargo_panel() {
  if (!has_cargo_panel()) {
    clear_action();
    set_has_cargo_panel();
    action_.cargo_panel_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionCargoPanelUnload >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionUI.cargo_panel)
  return action_.cargo_panel_;
}

// optional .SCRAPIProtocol.ActionProductionPanelRemoveFromQueue production_panel = 8;
inline bool ActionUI::has_production_panel() const {
  return action_case() == kProductionPanel;
}
inline void ActionUI::set_has_production_panel() {
  _oneof_case_[0] = kProductionPanel;
}
inline void ActionUI::clear_production_panel() {
  if (has_production_panel()) {
    delete action_.production_panel_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue& ActionUI::_internal_production_panel() const {
  return *action_.production_panel_;
}
inline ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue* ActionUI::release_production_panel() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionUI.production_panel)
  if (has_production_panel()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue* temp = action_.production_panel_;
    action_.production_panel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue& ActionUI::production_panel() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionUI.production_panel)
  return has_production_panel()
      ? *action_.production_panel_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue*>(&::SCRAPIProtocol::_ActionProductionPanelRemoveFromQueue_default_instance_);
}
inline ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue* ActionUI::mutable_production_panel() {
  if (!has_production_panel()) {
    clear_action();
    set_has_production_panel();
    action_.production_panel_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionProductionPanelRemoveFromQueue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionUI.production_panel)
  return action_.production_panel_;
}

// optional .SCRAPIProtocol.ActionToggleAutocast toggle_autocast = 9;
inline bool ActionUI::has_toggle_autocast() const {
  return action_case() == kToggleAutocast;
}
inline void ActionUI::set_has_toggle_autocast() {
  _oneof_case_[0] = kToggleAutocast;
}
inline void ActionUI::clear_toggle_autocast() {
  if (has_toggle_autocast()) {
    delete action_.toggle_autocast_;
    clear_has_action();
  }
}
inline const ::SCRAPIProtocol::ActionToggleAutocast& ActionUI::_internal_toggle_autocast() const {
  return *action_.toggle_autocast_;
}
inline ::SCRAPIProtocol::ActionToggleAutocast* ActionUI::release_toggle_autocast() {
  // @@protoc_insertion_point(field_release:SCRAPIProtocol.ActionUI.toggle_autocast)
  if (has_toggle_autocast()) {
    clear_has_action();
      ::SCRAPIProtocol::ActionToggleAutocast* temp = action_.toggle_autocast_;
    action_.toggle_autocast_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SCRAPIProtocol::ActionToggleAutocast& ActionUI::toggle_autocast() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionUI.toggle_autocast)
  return has_toggle_autocast()
      ? *action_.toggle_autocast_
      : *reinterpret_cast< ::SCRAPIProtocol::ActionToggleAutocast*>(&::SCRAPIProtocol::_ActionToggleAutocast_default_instance_);
}
inline ::SCRAPIProtocol::ActionToggleAutocast* ActionUI::mutable_toggle_autocast() {
  if (!has_toggle_autocast()) {
    clear_action();
    set_has_toggle_autocast();
    action_.toggle_autocast_ = CreateMaybeMessage< ::SCRAPIProtocol::ActionToggleAutocast >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCRAPIProtocol.ActionUI.toggle_autocast)
  return action_.toggle_autocast_;
}

inline bool ActionUI::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionUI::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionUI::ActionCase ActionUI::action_case() const {
  return ActionUI::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionControlGroup

// optional .SCRAPIProtocol.ActionControlGroup.ControlGroupAction action = 1;
inline bool ActionControlGroup::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionControlGroup::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionControlGroup::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionControlGroup::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::SCRAPIProtocol::ActionControlGroup_ControlGroupAction ActionControlGroup::action() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionControlGroup.action)
  return static_cast< ::SCRAPIProtocol::ActionControlGroup_ControlGroupAction >(action_);
}
inline void ActionControlGroup::set_action(::SCRAPIProtocol::ActionControlGroup_ControlGroupAction value) {
  assert(::SCRAPIProtocol::ActionControlGroup_ControlGroupAction_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionControlGroup.action)
}

// optional uint32 control_group_index = 2;
inline bool ActionControlGroup::has_control_group_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionControlGroup::set_has_control_group_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionControlGroup::clear_has_control_group_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionControlGroup::clear_control_group_index() {
  control_group_index_ = 0u;
  clear_has_control_group_index();
}
inline ::google::protobuf::uint32 ActionControlGroup::control_group_index() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionControlGroup.control_group_index)
  return control_group_index_;
}
inline void ActionControlGroup::set_control_group_index(::google::protobuf::uint32 value) {
  set_has_control_group_index();
  control_group_index_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionControlGroup.control_group_index)
}

// -------------------------------------------------------------------

// ActionSelectArmy

// optional bool selection_add = 1;
inline bool ActionSelectArmy::has_selection_add() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSelectArmy::set_has_selection_add() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSelectArmy::clear_has_selection_add() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionSelectArmy::clear_selection_add() {
  selection_add_ = false;
  clear_has_selection_add();
}
inline bool ActionSelectArmy::selection_add() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSelectArmy.selection_add)
  return selection_add_;
}
inline void ActionSelectArmy::set_selection_add(bool value) {
  set_has_selection_add();
  selection_add_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionSelectArmy.selection_add)
}

// -------------------------------------------------------------------

// ActionSelectWarpGates

// optional bool selection_add = 1;
inline bool ActionSelectWarpGates::has_selection_add() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSelectWarpGates::set_has_selection_add() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSelectWarpGates::clear_has_selection_add() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionSelectWarpGates::clear_selection_add() {
  selection_add_ = false;
  clear_has_selection_add();
}
inline bool ActionSelectWarpGates::selection_add() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSelectWarpGates.selection_add)
  return selection_add_;
}
inline void ActionSelectWarpGates::set_selection_add(bool value) {
  set_has_selection_add();
  selection_add_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionSelectWarpGates.selection_add)
}

// -------------------------------------------------------------------

// ActionSelectLarva

// -------------------------------------------------------------------

// ActionSelectIdleWorker

// optional .SCRAPIProtocol.ActionSelectIdleWorker.Type type = 1;
inline bool ActionSelectIdleWorker::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSelectIdleWorker::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSelectIdleWorker::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionSelectIdleWorker::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SCRAPIProtocol::ActionSelectIdleWorker_Type ActionSelectIdleWorker::type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionSelectIdleWorker.type)
  return static_cast< ::SCRAPIProtocol::ActionSelectIdleWorker_Type >(type_);
}
inline void ActionSelectIdleWorker::set_type(::SCRAPIProtocol::ActionSelectIdleWorker_Type value) {
  assert(::SCRAPIProtocol::ActionSelectIdleWorker_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionSelectIdleWorker.type)
}

// -------------------------------------------------------------------

// ActionMultiPanel

// optional .SCRAPIProtocol.ActionMultiPanel.Type type = 1;
inline bool ActionMultiPanel::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionMultiPanel::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionMultiPanel::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionMultiPanel::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SCRAPIProtocol::ActionMultiPanel_Type ActionMultiPanel::type() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionMultiPanel.type)
  return static_cast< ::SCRAPIProtocol::ActionMultiPanel_Type >(type_);
}
inline void ActionMultiPanel::set_type(::SCRAPIProtocol::ActionMultiPanel_Type value) {
  assert(::SCRAPIProtocol::ActionMultiPanel_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionMultiPanel.type)
}

// optional int32 unit_index = 2;
inline bool ActionMultiPanel::has_unit_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionMultiPanel::set_has_unit_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionMultiPanel::clear_has_unit_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionMultiPanel::clear_unit_index() {
  unit_index_ = 0;
  clear_has_unit_index();
}
inline ::google::protobuf::int32 ActionMultiPanel::unit_index() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionMultiPanel.unit_index)
  return unit_index_;
}
inline void ActionMultiPanel::set_unit_index(::google::protobuf::int32 value) {
  set_has_unit_index();
  unit_index_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionMultiPanel.unit_index)
}

// -------------------------------------------------------------------

// ActionCargoPanelUnload

// optional int32 unit_index = 1;
inline bool ActionCargoPanelUnload::has_unit_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionCargoPanelUnload::set_has_unit_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionCargoPanelUnload::clear_has_unit_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionCargoPanelUnload::clear_unit_index() {
  unit_index_ = 0;
  clear_has_unit_index();
}
inline ::google::protobuf::int32 ActionCargoPanelUnload::unit_index() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionCargoPanelUnload.unit_index)
  return unit_index_;
}
inline void ActionCargoPanelUnload::set_unit_index(::google::protobuf::int32 value) {
  set_has_unit_index();
  unit_index_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionCargoPanelUnload.unit_index)
}

// -------------------------------------------------------------------

// ActionProductionPanelRemoveFromQueue

// optional int32 unit_index = 1;
inline bool ActionProductionPanelRemoveFromQueue::has_unit_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionProductionPanelRemoveFromQueue::set_has_unit_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionProductionPanelRemoveFromQueue::clear_has_unit_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionProductionPanelRemoveFromQueue::clear_unit_index() {
  unit_index_ = 0;
  clear_has_unit_index();
}
inline ::google::protobuf::int32 ActionProductionPanelRemoveFromQueue::unit_index() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionProductionPanelRemoveFromQueue.unit_index)
  return unit_index_;
}
inline void ActionProductionPanelRemoveFromQueue::set_unit_index(::google::protobuf::int32 value) {
  set_has_unit_index();
  unit_index_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionProductionPanelRemoveFromQueue.unit_index)
}

// -------------------------------------------------------------------

// ActionToggleAutocast

// optional int32 ability_id = 1;
inline bool ActionToggleAutocast::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionToggleAutocast::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionToggleAutocast::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionToggleAutocast::clear_ability_id() {
  ability_id_ = 0;
  clear_has_ability_id();
}
inline ::google::protobuf::int32 ActionToggleAutocast::ability_id() const {
  // @@protoc_insertion_point(field_get:SCRAPIProtocol.ActionToggleAutocast.ability_id)
  return ability_id_;
}
inline void ActionToggleAutocast::set_ability_id(::google::protobuf::int32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SCRAPIProtocol.ActionToggleAutocast.ability_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SCRAPIProtocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SCRAPIProtocol::ActionControlGroup_ControlGroupAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ActionControlGroup_ControlGroupAction>() {
  return ::SCRAPIProtocol::ActionControlGroup_ControlGroupAction_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::ActionSelectIdleWorker_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ActionSelectIdleWorker_Type>() {
  return ::SCRAPIProtocol::ActionSelectIdleWorker_Type_descriptor();
}
template <> struct is_proto_enum< ::SCRAPIProtocol::ActionMultiPanel_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCRAPIProtocol::ActionMultiPanel_Type>() {
  return ::SCRAPIProtocol::ActionMultiPanel_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ui_2eproto
